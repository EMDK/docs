var docs = [{"key":"api-AdditionalData","name":"AdditionalData","md":"#AdditionalData\n\nThis class holds additional data information.\n\n\n**Version:**\n\n1.0\n\n\n##Public Methods\n###getTip()\nReturns the tip value.\n\n**Returns:**\n\nTip value as double.\n\n###getCashBack()\nReturns the cash back value entered.\n\n**Returns:**\n\nCashback value as double.\n\n###getSurchargeIndicator()\nReturns the surcharge value is accepted by the user or not.\n\n**Returns:**\n\nboolean - Checks whether the surcharge value is accepted by the user or not.\n"},{"key":"api-BarcodeInterfaceConfig","name":"InterfaceConfig ","md":"#InterfaceConfig \n\n\n**Version:**\n\n3.1\n\n##Public Fields\n###displayBluetoothAddressBarcode\n\n> Note: default = true\n\n\nWhen using Bluetooth (Imager) scanners, the pairing process between the mobile computer and Bluetooth scanner may require scanning the Bluetooth address of the mobile computer.  If this value is set to true, the Bluetooth address will be displayed as a barcode when the Scanner.enable() function is called. This feature eliminates the need to open the external tools such as Bluetooth Pairing Utility in order to display the pairing barcode. Also if the user wants to set this parameter he/she should use the InterfaceConfig class before calling Scanner.enable().\n\n\n> Note: If the Bluetooth scanner has already connected, it will not display the barcode during Scanner.enable() even though this parameter is set to true.\n\n**Type:**\n\nboolean\n\n###connectionEstablishTime \n\n> Note: default = true\n\n\nTimeout in seconds that Scanner.enable() will block before returning if an external scanner connection is not established. This is currently applicable to Bluetooth scanners only. Also if the user wants to set this parameter he/she should use the InterfaceConfig class before calling Scanner.enable().\n\n**Type:**\n\nint"},{"key":"api-BarcodeManager-ScannerConnectionListener-ConnectionStatus","name":"BarcodeManager.ScannerConnectionListener.ConnectionStatus","md":"#BarcodeManager.ScannerConnectionListener.ConnectionStatus\n\nThe ConnectionStatus class provides the information about status of scanner connection changes.\n\n##Constructors\n\n###ConnectionStatus()\n\n##Public Methods\n###getConnectionState()\nReturns the device connection state of pluggable scanner.\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[BarcodeManager.ConnectionState](#api-BarcodeManager?BarcodeManager.ConnectionState): Returns the connection state. \n\n###getScannerInfo()\nReturns the ScannerInfo obj of scanner for which the data is returned.\n\n**Returns:**\n\n[ScannerInfo](#api-ScannerInfo): Returns ScannerInfo obj of the pluggable scanner."},{"key":"api-BarcodeManager-ScannerConnectionListener","name":"BarcodeManager.ScannerConnectionListener","md":"#BarcodeManager.ScannerConnectionListener\n\nThis interface is called to notify the client when the scanner device has been connected or disconnected to the mobile device.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements ScannerConnectionListener\n    {\n       .. .. .. \n    } \n\n\n**Version:**\n\n3.1\n\n##Public Methods\n###onConnectionChange(ScannerInfo scannerInfo, ConnectionState connectionState)\nCalled to notify the client when the scanner device has been connected or disconnected to the mobile device.\n\n**Parameters:**\n\n**scannerInfo** - The [ScannerInfo](#api-ScannerInfo) object of the affected scanner.\n\n**connectionState** - The new [connection state](#api-BarcodeManager?BarcodeManager.ConnectionState).\n\n**Returns:**\n\nvoid\n\n"},{"key":"api-BarcodeManager","name":"BarcodeManager","md":"#BarcodeManager\n\nThis is the primary object to access the barcode scanning feature.\n\n**Example Usage:**\n\n    :::java\n    public class MainActivity extends Activity implements EMDKListener, StatusListener, DataListener, ScannerConnectionListener {\n    \n      Override:\n      protected void onCreate(Bundle savedInstanceState) { \n      //.. \n      EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this); \n      }\n\n      Override:\n      public void onOpened(EMDKManager emdkManager) { \n      this.emdkManager = emdkManager; \n      } \n\n       //... \n       barcodeManager = (BarcodeManager)this.emdkManager.getInstance(FEATURE_TYPE.BARCODE); \n       //... \n       Scanner scanner = barcodeManager.getDevice(DeviceIdentifier.DEFAULT); \n       scanner.enable(); \n       scanner.addDataListener(callbackObj); scanner.addStatusListener(callbackObj); \n       scanner.read(); \n       //... \n       scanner.cancelRead(); \n       //... \n       scanner.disable(); \n       //.. \n       EMDKManager.release(FEATURE_TYPE.BARCODE);  \n    } \n\n\n**Version:**\n\n1.0\n\n##Public Methods\n\n###public void addConnectionListener(BarcodeManager.ScannerConnectionListener connectionListener)\nAdd ScannerConnectionListener to receive scanner connection changes via callback.\n\n**Parameters:**\n\nconnectionListener -\n\n**Returns:**\n\nvoid\n\n\n###removeConnectionListener\npublic void removeConnectionListener(BarcodeManager.ScannerConnectionListener connectionListener)\nRemove ScannerConnectionListener to receive scanner connection changes via callback.\n\n**Parameters:**\n\nconnectionListener -\n\n**Returns:**\n\nvoid\n\n###getDevice(ScannerInfo scannerInfo)\nThis method returns the scanner object if the scanner info specified is valid and scanner info object can obtain from the BarcoderManager.getSupportedDevices(). The scanner object created will be singleton object for a specific scanner.\n\n**Parameters:**\n\n**scannerInfo** - friendlyName The scanner friendly name.\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[Scanner](#api-Scanner) - Returns the scanner object if scanner friendly name is valid. Otherwise null is returned.\n\n###getDevice(BarcodeManager.DeviceIdentifier deviceIdentifier)\nThis method returns the scanner object based on device identifier specified. The scanner object created will be signleton object for a specific scanner.\n\n**Parameters:**\n\n**deviceIdentifier** - The device identifier specifies which scanner the application wants.\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[Scanner](#api-Scanner) - [Scanner](#api-Scanner) object if the device identifier specified is valid on the device. Otherwise null is returned.\n\n###getSupportedDevicesInfo()\nReturns list of supported scanner devices information.\n\n**Returns:**\n\njava.util.List&lt;com.symbol.emdk.barcode.[ScannerInfo](#api-ScannerInfo)&gt; - Returns list of supported scanner devices information.\n\n\n###addConnectionListener(BarcodeManager.ScannerConnectionListener connectionListener)\nAdd ScannerConnectionListener to receive scanner connection changes via callback.\n\n**Parameters:**\n\nconnectionListener - [BarcodeManager.ScannerConnectionListener](#api-BarcodeManager-ScannerConnectionListener)\n\n\n###removeConnectionListener(BarcodeManager.ScannerConnectionListener connectionListener)\nRemove ScannerConnectionListener to receive scanner connection changes via callback.\n\n**Parameters:**\n\nconnectionListener - [BarcodeManager.ScannerConnectionListener](#api-BarcodeManager-ScannerConnectionListener)\n\n\n##Public Enums\n###BarcodeManager.ConnectionState\nConnection states of a scanner device.\n\n**Values:**\n\n**CONNECTED** - Indicates that a pluggable scanner was connected.\n\n**DISCONNECTED** - Indicates that a pluggable scanner was removed and no longer avail for scanning.\n\n###BarcodeManager.DeviceIdentifier\nDefines specific scanner devices of each type.\n\n**Values:**\n\n**DEFAULT**\n\n**INTERNAL_CAMERA1**\n\n**INTERNAL_IMAGER1**\n\n**INTERNAL_LASER1**\n\n**BLUETOOTH_IMAGER1**\n\n###BarcodeManager.ScannerResults\nDefines all the error codes the barcode scanning API returns. \n\n**Values:**\n\n**SUCCESS** - Success.\n\n**FAILURE** - Failure.\n\n**ALREADY_SCANNING** - Scanning in progress.\n\n**SCANNER_IN_USE** - Cannot enable scanner and is already in use.\n\n**VF_ERROR** - View finder error.\n\n**INVALID_VALUE** - The value is invalid.\n\n**SCAN_PARAM_NOT_SUPPORTED** - Particular parameter not supported.\n\n**SCAN_DATA_FAILURE** - Unexpected scan data\n\n**SCAN_PARAM_READ_ONLY** - Read only parameters.\n\n**LENGTH_MISMATCH** - Decoded barcode does not meet length requirements.\n\n**SCANNER_OPERATION_FAILURE** - Scanner operation failed.\n\n**FEATURE_NOT_SUPPORTED** - The feature is not supported.\n\n**SCANNER_NOT_SUPPORTED** - Scanner not supported.\n\n**SCANNER_NOT_ENABLED** - The scanner device is not enabled.\n\n**SCANNER_TIMED_OUT** - The timer out error occurred.\n\n**INVALID_OBJECT** - The object is not valid.\n\n**NO_DATA_LISTENER** - Scan read is issued without adding the data listener.\n\n**TRIGGER_KEY_REG_FAILED** - Failed to register for the hard trigger key notification.\n\n**TRIGGER_KEY_IN_USE** - Trigger key is already used by other user.\n\n**TRIGGER_KEY_UNREG_FAILED** - Failed to unRegister for the hard trigger key notification.\n\n**SCANNER_INIT_FAILURE** - Scanner initialization failed.\n\n**SCANNER_DEINIT_FAILURE** - Scanner de-initialization failed.\n\n**UNDEFINED** - Error code not defined."},{"key":"api-Collection-ScanData","name":"Collection.ScanData","md":"#Collection.ScanData\n\nThe ScanData object gives information on the barcode data scanned. \n\n**Example Usage:**\n\n\t:::java\n\tArrayList<ScanData> scanDataList = scanDataCollection.getScanData();\n     for(ScanData scanData :scanDataList) { \n      String data = scanData.getData(); \n      LABEL_TYPE labelType = scanData.getLabelType(); \n      String timeStamp = scanData.getTimeStamp(); \n     }\n\n**Version:**\n\n3.0\n\n##Public Methods\n###getData()\nReturns the scanned barcode data.\n\n**Returns:**\n\njava.lang.String - Returns barcode data\n\n###getLabelType()\nReturns label type of the scanned data.\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[ScanDataCollection.LabelType](#api-ScanDataCollection?ScanDataCollection.LabelType) - Returns LabelType\n\n###getTimeStamp()\nReturns the time at which the barcode was scanned. The time format is \"yyyy-MM-dd HH:mm:ss.nnnnnnnnn\"\n\n**Returns:**\n\njava.lang.String - Returns time stamp string\n"},{"key":"api-EMDKBase","name":"EMDKBase","md":"#EMDKBase\nThis is the base class for all the EMDK manager classes derived from.\n\n**Version:**\n\n1.0\n"},{"key":"api-EMDKManager-EMDKListener","name":"EMDKManager.EMDKListener","md":"#EMDKManager.EMDKListener\nThis is the interface for the callback to notify the opening and closing status of the EMDK. On a successful opening, the EMDKManager object will be returned. An interface for notifying clients when they the EMDKManager is ready to use or closed abruptly.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements EMDKListener\n\n\t.. .. ..\n\n\tEMDKManager.getEMDKManager(getApplicationContext(), emdkListener);\n\n\n**Version:**\n\n2.0\n\n##Public Methods\n###onClosed()\nCalled to notify the client that this EMDKManager object has been abruptly closed. The clients must call to call [EMDKManager.release()](#api-EMDKManager?release()) to free all the resources used by EMDKManager even after onClosed(). Notifies user upon a abrupt closing of EMDKManager.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onClosed()\n\t{\n\n\t}\n\n\n**Returns:**\n\nvoid\n\n###onOpened(EMDKManager emdkManager)\nCalled to notify the client when the EMDKManager object has been opened and its ready to use.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkManager)\n\t{\n\n\t}\n\n\n**Parameters:**\n\n**emdkManager**\n\n**Returns:**\n\nvoid\n"},{"key":"api-EMDKManager","name":"EMDKManager","md":"#EMDKManager\n\nThe EMDKManager class is the key class in Android EMDK. This class provides access to different classes for the supported features. Clients should call EMDKManager.getEMDKManager(Context, EMDKManager.EMDKListener), to get the EMDKManager object. Each application implements EMDKListener interface. The EMDKManager object will be returned on successful opening through the EMDKListener callback.\n\n**Example Usage:**\n\n\t:::java\n\tEMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), emdkListener);\n\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getEMDKManager(Context context, EMDKManager.EMDKListener emdkListener)\nThis is static method and it is the key function to get the EMDKManager object. Clients must implement [EMDKManager.EMDKListener](#api-EMDKManager-EMDKListener) to get notified of the EMDK manager status and to get the EMDKManager object.\n\n**Example Usage:**\n\n\t:::java\n\tEMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), emdkListener);\n\n\n**Parameters:**\n\n**context** - The application context should be provided by the user.\n**emdkListener** - The EMDK Listener for listener callbacks.\n\n**Returns:**\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n###getInstance(EMDKManager.FEATURE_TYPE featureType)\nThis method returns an object instance which has derived from [EMDKBase](#api-EMDKBase). Based on the type given, the object needs to be type-casted before used. Calling this method [EMDKManager.getInstance(FEATURE_TYPE)](#api-EMDKManager?getInstance(EMDKManager.FEATURE_TYPE featureType)) before EMDKManager opened will return null.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);\n\tVersionManager versionManager = (VersionManager)emdkmanager.getInstance(FEATURE_TYPE.VERSION);\n\tBarcodeManager barcodeManager = (BarcodeManager)emdkmanager.getInstance(FEATURE_TYPE.BARCODE); \n\t}\n\n\n**Parameters:**\n\n**featureType** - The [EMDKManager.FEATURE_TYPE](#api-EMDKManager?FEATURE_TYPE) the object to be created.\n\n**Returns:**\n\ncom.symbol.emdk.EMDKBase - Object derived from [EMDKBase](#api-EMDKBase) to be type-casted to the appropriate type. Currently [ProfileManager](#api-ProfileManager), [VersionManager](#api-VersionManager) and [BarcodeManager](#api-BarcodeManager) are returned based on the [EMDKManager.FEATURE_TYPE](#api-EMDKManager?FEATURE_TYPE) given in.\n\n###release()\nThis method releases all the resources constructed by EMDKManager. EMDKManager can't be used after this call. The clients should call this method only before exiting the application.\n\n**Example Usage:**\n\n\t:::java\n\temdkManager.release();\n\n\n**Returns:**\n\nvoid\n\n###release(EMDKManager.FEATURE_TYPE featureType)\nThis method releases resources of a given manager type. Instance variable is not required as multiple instances are not allowed by design.\n\n**Example Usage:**\n\n\t:::java\n\temdkManager.release(EMDKManager.FEATURE_TYPE.PROFILE);\n\n\n**Parameters:**\n\n**featureType** - Type of [EMDKManager.FEATURE_TYPE](#api-EMDKManager?FEATURE_TYPE) to be released. Only the given feature related manager will be cleared if it has been constructed.\n\n**Returns:**\n\nvoid\n\n##Public Enums\n###FEATURE_TYPE\nThis lists all the features exposed by the EMDK.\n\n**Example Usage:**\n\n\t:::java\n\tFEATURE_TYPE.PROFILE\n\n\n**Values:**\n\n**PROFILE** - EMDK feature type profile\n\n**VERSION** - EMDK feature type version\n\n**BARCODE** - EMDK feature type for Barcode Scanning\n\n**SCANANDPAIR** - EMDK feature type for ScanAndPair\n\n**SIMULSCAN** - EMDK feature type for SimulScan & Document Capture"},{"key":"api-EMDKResults","name":"EMDKResults","md":"#EMDKResults\nClass for holding EMDK result data.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tProfileConfig profileConfigObj = new ProfileConfig();\n\tProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);\n\tEMDKResults results = profileManager.processProfile(\"Profile Name\", ProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t}\n\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getExtendedStatusMessage()\nReturn the extended status information string. If there is not any extended information this returns empty string \"\".\n\n**Returns:**\n\nString - Extended status information String.\n\n\n###getTotalFeaturesCount()\nReturn the total number of features in the profile. Currently these values will be available when the process profile is called to check profile compatibility. This will return -1 if the value is not used/set.\n\n**Returns:**\n\nint - Returns the total number of features in the profile.\n\n\n###getSuccessFeaturesCount()\nReturn the total number of features in profile request is success. Currently these values will be available when the process profile is called to check profile compatibility. This will return -1 if the value is not used/set.\n\n**Returns:**\n\nint - Returns the total number of features in profile request is success.\n\n###getStatusDocument()\nGets status results from process profile as xml document.\n\n**Example Usage:**\n\n\t:::java\n\tDocument document = results.getStatusDocument();\n\n\n**Returns:**\n\norg.w3c.dom.Document - XML document.\n\n###getStatusString()\nGets status results from process profile as xml string.\n\n**Example Usage:**\n\n\t:::java\n\tString xml = results.getStatusString();\n\n\n**Returns:**\n\njava.lang.String - XML text.\n\n##Public Fields\n###statusCode\nGets status code result from process profile as enum value of type [EMDKResults.STATUS_CODE](#api-EMDKResults?STATUS_CODE)\t.\n\n**Example Usage:**\n\n\t:::java\n\tSTATUS_CODE statusCode = results.statusCode;\n\n\n**Type:**\n\ncom.symbol.emdk.[EMDKResults.STATUS_CODE](#api-EMDKResults?EMDKResults.STATUS_CODE)\n\n\n###extendedStatusCode\nGets status code result from process profile as enum value of type [EMDKResults.EXTENDED_STATUS_CODE](#api-EMDKResults?EMDKResults.EXTENDED_STATUS_CODE).\n\n**Example Usage:**\n\n\t:::java\n\tSTATUS_CODE statusCode = results.extendedErrorInfo.statusCodeEx;\n\n\n**Type:**\n\ncom.symbol.emdk.[EMDKResults.EXTENDED_STATUS_CODE](#api-EMDKResults?EMDKResults.EXTENDED_STATUS_CODE)\n\n##Public Enums\n###EMDKResults.STATUS_CODE\nDefines all the status codes the library returns.\n\n**Example Usage:**\n\n\t:::java\n\tresults.statusCode.SUCCESS;\n\n\n**Values:**\n\n* **SUCCESS** - Process profile was a success.\n\n* **FAILURE** - Process profile was a failure.\n\n* **UNKNOWN** - Process profile had mixed results.\n\n* **NULL_POINTER** - Process profile had a null value.\n\n* **EMPTY_PROFILENAME** - Profile name passed Process profile was empty.\n\n* **EMDK_NOT_OPENED** - EMDK is not opened\n\n* **CHECK_XML** - This is returned when multiple features are present in the profile. In such a case the only way to verify if the API call was successful is to analyze the XML.\n\n* **PREVIOUS_REQUEST_IN_PROGRESS** - The previous request is in progress, wait for it to complete before next request.\n\n* **PROCESSING** - The processing of profile started, the result will be returned through the data listener callback registered.\n\n* **NO_DATA_LISTENER** - The asynchronous method (Ex: processProfileAsync) is issued without adding the data listener.   \n\n\n###EMDKResults.EXTENDED_STATUS_CODE\nDefines all the extended status codes the library returns.\n\n**Example Usage:**\n\n\t:::java\n\tresults.extendedStatusInfo.extendedStatusCode;\n\n**Values:**\n\n* **NONE** - There is no extended status code.\n\n* **PROFILE_NOT_FOUND_IN_CONFIG** - Profile name not found in current EMDKConfig.xml\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String) when changing profile using Name Value pair, Document or ProfileConfig or when switching or activating profile\n\n* **FEATURE_TYPE_NOT_FOUND_IN_CONFIG** -Feature type not found in the profile in current EMDKConfig.xml.\n\n* **FEATURE_NAME_NOT_FOUND_IN_CONFIG** - Feature name not found for the feature in current EMDKConfig.xml.\t\n\n* **FEATURE_NAME_NOT_FOUND_EXTRADATA** - The feature name not found in extraData. \n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String) when specifying feature name (emdk_name) in the criteria.\n\n* **FEATURE_TYPE_NOT_FOUND_IN_EXTRADATA** - The feature type not found in extraData.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String)\n\n* **PROFILE_NOT_FOUND_IN_EXTRADATA** - The profile not found in extraData.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String) when merging profiles.\n\n* **FEATURE_NOT_UNIQUE_IN_CONFIG** - The Feature and feature name combination is not unique in current EMDKConfig.xml. In order to perform merge operation the feature and feature name combination are required to be unique.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String) when feature merging.\n\n* **FEATURE_NOT_UNIQUE_IN_EXTRADATA** - The Feature and feature name combination is not unique in provided extraData.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String) when feature merging\n\n* **DEPENDACY_COMPONENT_FALIURE** - Failed to access dependency component.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String) when it failed to connect to MX service.\n\n* **GENERAL_EXCEPTION_OCCURED** - Exception occurred while performing requested operation.\n\n* **NAMEVALUE_MISSMATCH_IN_CONFIG** - One or more names of parameters not found in current EMDKConfig.xml. This is due to the given name value pairs need to be equivalent to specified profile. So the operation is canceled.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String) when using name-value pair functionality\n\n* **NAMEVALUE_MISMATCH_IN_EXTRADATA** - One or more names of parameters not found in extraData. This is due to the given name value pairs need to be equivalent to specified feature name.\n\n* **INVALID_PROFILE_CONFIGURATION** -The current EMDKConfig.xml is invalid.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String)\n\n* **PROFILE_NAME_ERROR** - The give profileName format is invalid. The profile name criteria is required to be in profileName/feature type/feature Name format. This error occurred if it is not in that format.\n\t* Returned in: com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String)\n\n* **ACTIVITY_SELECTION_MERGING_NOT_SUPPORTED** - The ActivitySelection merging is not supported.\n\n* **INVALID_VALUE** - The parameters given are invalid.  \n\t* Returned in:\n\t\t* com.symbol.emdk.ProfileManager.processProfile(String, PROFILE_FLAG, Document)\n\t\t* com.symbol.emdk.ProfileManager.processProfile(String, PROFILE_FLAG, String[])\n\t\t* com.symbol.emdk.ProfileManager.processProfile(String, PROFILE_FLAG, ProfileConfig)\n\t\t* com.symbol.emdk.emdkservice.ProfileService.setProfile(String, String)\n\n* **APP_NOT_ALLOWED_TO_SUBMIT_XML** - Permission error. Application is not allowed to submit xml.\n\n"},{"key":"api-EmvData","name":"EmvData","md":"#EmvData\n\nThis class holds result and EMV data of the EMV related APIs.\n\n\n**Version:**\n\n1.0\n\n\n##Public Methods\n###getTagData()\nReturns EMV tag data list.\n\n**Returns:**\n\njava.util.ArrayList<[TagData](#api-TagData)> EMVData data list."},{"key":"api-MacData","name":"MacData ","md":"#MacData \n\nThis class holds MAC block information.\n\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getMacBlock()\nReturns the MacBlock String.\n\n**Returns:**\n\njava.lang.String"},{"key":"api-MenuData","name":"MenuData ","md":"#MenuData \n\nThis class holds the menu choices selected.\n\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getChoiceString()\nReturns the choice string selected by the user\n\n**Returns:**\n\njava.lang.String - Choice string selected by the user."},{"key":"api-ProfileConfig-ActivitySelection-ActivityElement","name":"ProfileConfig.ActivitySelection.ActivityElement","md":"#ProfileConfig.ActivitySelection.ActivityElement\nGets and Sets application's package name and its activities to the profile [ProfileConfig.ActivitySelection.ActivityElement](#api-ProfileConfig-ActivitySelection-ActivityElement).\n\n**Example Usage:**\n\n\t:::java\n\tArrayList<ActivityElement> activities = profileConfig.activitySelection.activities;\n\n\n**Version:**\n\n2.0\n\n##Constructors\n\n###ProfileConfig.ActivitySelection.ActivityElement**(String packageName, java.lang.String[] activities)\n\n**Parameters:**\n\n* packageName\n\n* activities\n\n##Public Fields\n\n###packageName\n\n**Type:**\n\njava.lang.String\n\n"},{"key":"api-ProfileConfig-ActivitySelection","name":"ProfileConfig.ActivitySelection","md":"#ProfileConfig.ActivitySelection\nClass for dealing with ActivitySelection of profile data ProfileConfig.activitySelection()\n\n**Example Usage:**\n\n\t:::java\n\tActivitySelection activitySelection = profileConfig.activitySelection;\n\n\n**Version:**\n\n2.0\n\n##Constructors\n###ProfileConfig.ActivitySelection()\n\n##Public Fields\n###activities\nGets and Sets activities to the profile ProfileConfig.ActivitySelection.activities.\n\n**Example Usage:**\n\n\t:::java\n\tActivitySelection activitySelection = profileConfig.activitySelection\n\n\n**Type:**\n\njava.util.ArrayList&lt;[com.symbol.emdk.ProfileConfig.ActivitySelection](#api-ProfileConfig-ActivitySelection)&gt;\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar\nHolds Codabar configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCodabar codabar = profileConfig.dataCapture.barcode.decoderParams.codabar;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###clsi_editing\nEnable this parameter to strip the start and stop characters and insert a space after the first, fifth, and tenth characters of a 14-character Codabar symbol. Enable this feature if the host system requires this data format (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcodabar.clsi_editing = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###length1\nUse to set decode lengths (default - 6).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = codabar.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = codabar.length2;\n\n\n**Type:**\n\nint\n\n###notis_editing\nEnable this parameter to strip the start and stop characters from a decoded Codabar symbol. Enable this feature if the host system requires this data format (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcodabar.notis_editing = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcodabar.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code11","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code11\nHolds Code 11 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode11 code11 = profileConfig.dataCapture.barcode.decoderParams.code11;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUse to set decode lengths (default - 4).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code11.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code11.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode11.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Code 11 data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode11.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###verify_check_digit\nCheck the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code. Use enum [ProfileConfig.VERIFY_CHECK_DIGIT](#api-ProfileConfig?VERIFY_CHECK_DIGIT).\n\n**Example Usage:**\n\n\t:::java\n\tcode11.verify_check_digit = VERIFY_CHECK_DIGIT.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.VERIFY_CHECK_DIGIT](#api-ProfileConfig?VERIFY_CHECK_DIGIT)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code128","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code128\nHolds Code128 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode128 code128 = profileConfig.dataCapture.barcode.decoderParams.code128;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###check_isbt_table\nThe ISBT specification includes a table that lists several types of ISBT bar codes that are commonly used in pairs. If ISBT128 Concat Mode is set, enable Check ISBT T able to concatenate only those pairs found in this table. Other types of ISBT codes are not concatenated (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.check_isbt_table = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###enable_ean128\nUse enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.enable_ean128 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###enable_plain\nFlag to enable other 128 sub types (besides GS1-128 and ISBT -128). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.enable_plain = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###isbt128_concat_mode\nSelect an option for concatenating pairs of ISBT code types. Use enum [ProfileConfig.ISBT128_CONTACT_MODE](#api-ProfileConfig?ISBT128_CONTACT_MODE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.isbt128_concat_mode = ISBT128_CONTACT_MODE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ISBT128_CONTACT_MODE](#api-ProfileConfig?ISBT128_CONTACT_MODE)\n\n###length1\nUse to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code128.length1;\n\n\n\n**Type:**\n\nint\n\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code128.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###security_level\nThe scanner of fers four levels of decode security for Code 128 bar codes. Select increasing levels of security for decreasing levels of bar code quality. There is an inverse relationship between security and scanner aggressiveness, so choose only that level of security necessary for any given application. Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.security_level = SECURITY_LEVEL.DEFAULT;\n\n\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code39","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code39\nHolds Code39 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode39 code39 = profileConfig.dataCapture.barcode.decoderParams.code39;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n###convert_to_code32\nCode 32 is a variant of Code 39 used by the Italian pharmaceutical industry (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.convert_to_code32 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###full_ascii\nCode 39 Full ASCII is a variant of Code 39 that pairs characters to encode the full ASCII character set (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.full_ascii = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###length1\nUse to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code39.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths 4 (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code39.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Code 39 data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_code32_prefix\nScan the appropriate bar code to enable or disable adding the prefix character \"A\" to all Code 32 bar codes (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.report_code32_prefix = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###security_level\nOptions: Security level 0 , Security Level 1 , Security Level 2 and Security Level 3 (default - Security level 1). Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.security_level = SECURITY_LEVEL.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n###verify_check_digit\nEnable this feature to check the integrity of all Code 39 symbols to verify that the data complies with a specified check digit algorithm. The digital scanner decodes only those Code 39 symbols that include a modulo 43 check digit. Enable this feature only if the Code 39 symbols contain a modulo 43 check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.verify_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code93","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code93\nHolds Code93 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode93 code93 = profileConfig.dataCapture.barcode.decoderParams.code93;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUse to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code93.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code93.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode93.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB\nHolds Composite AB configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tComposite_AB compositeAB = profileConfig.dataCapture.barcode.decoderParams.composite_AB;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###ucc_link_mode\nGets and Sets UCC Link Mode using [ProfileConfig.UCC_LINK_MODE](#api-ProfileConfig?UCC_LINK_MODE) enum;\n\n**Example Usage:**\n\n\t:::java\n\tcompositeAB.ucc_link_mode = UCC_LINK_MODE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.UCC_LINK_MODE](#api-ProfileConfig?UCC_LINK_MODE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5\nHolds Discrete 2 of 5 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tDiscrete_2of5 discrete_2of5 = profileConfig.dataCapture.barcode.decoderParams.discrete_2of5;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUsed to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = discrete_2of5.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUsed to set decode lengths (default - 14).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = discrete_2of5.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdiscrete_2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5\nHolds Interleaved 2 of 5 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tInterleaved_2of5 interleaved2of5 = profileConfig.dataCapture.barcode.decoderParams.interleaved_2of5;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###check_digit\nThe check digit type to verify. Use enum [ProfileConfig.CHECK_DIGIT_TYPE](#api-ProfileConfig?CHECK_DIGIT_TYPE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.check_digit = CHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CHECK_DIGIT_TYPE](#api-ProfileConfig?CHECK_DIGIT_TYPE)\n\n###convert_itf14_to_ean13\nConvert 14-character Interleaved 2 of 5 bar codes to EAN-13, and transmit as EAN-13. The Interleaved 2 of 5 bar code must be enabled and must have a leading zero and a valid EAN-13 check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.convert_itf14_to_ean13 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###length1\nUse to set decode lengths (default - 14).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = interleaved2of5.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 10).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = interleaved2of5.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Interleaved 2 of 5 data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###security_level\nSpecifies security level Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.security_level = SECURITY_LEVEL.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5\nHolds Matrix 2 of 5 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tMatrix_2of5 matrix2of5 = profileConfig.dataCapture.barcode.decoderParams.matrix_2of5;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUsed to set decode lengths (default - 10).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = matrix2of5.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUsed to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = matrix2of5.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmatrix2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Matrix 2 of 5 data with or without the check digit(default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmatrix2of5.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###verify_check_digit\nEnable this feature to check the integrity of all Matrix 2 of 5 symbols to verify that the data complies with a specified check digit algorithm (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmatrix2of5.verify_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.MSI","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.MSI\nHolds Codabar configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tMSI msi = profileConfig.dataCapture.barcode.decoderParams.msi;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###check_digit\nWith MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional. Use enum [ProfileConfig.CHECK_DIGIT](#api-ProfileConfig?CHECK_DIGIT).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.check_digit = CHECK_DIGIT.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CHECK_DIGIT](#api-ProfileConfig?CHECK_DIGIT)\n\n###check_digit_scheme\nTwo algorithms are possible for the verification of the second MSI check digit. Select the algorithm used to encode the check digit. Use enum [ProfileConfig.CHECK_DIGIT_SCHEME](#api-ProfileConfig?CHECK_DIGIT_SCHEME).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.check_digit_scheme = CHECK_DIGIT_SCHEME.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CHECK_DIGIT_SCHEME](#api-ProfileConfig?CHECK_DIGIT_SCHEME)\n\n###length1\nUse to set decode lengths (default - 4).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = msi.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = msi.length2\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit MSI data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal\nHolds UK Postal configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUK_Postal ukPostal = profileConfig.dataCapture.barcode.decoderParams.uk_Postal;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###report_check_digit\nTransmit UK Postal data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tukPostal.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA\nHolds UPCA configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUPCA upca = profileConfig.dataCapture.barcode.decoderParams.upca;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###preamble\nPreamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system. Use enum [ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE).\n\n**Example Usage:**\n\n\t:::java\n\tupca.preamble = PREAMBLE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE)\n\n###report_check_digit\nThe check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option (default - enabled) . Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupca.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0\nHolds UPCE0 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUPCE0 upce0 = profileConfig.dataCapture.barcode.decoderParams.upce0;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###convert_to_upca\nEnable to convert UPCE0 (zero suppressed) decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is af fected by UPC-A programming selections. Disable to transmit UPCE0 decoded data as UPCE0 data, without conversion (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce0.convert_to_upca = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###preamble\nPreamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system. Use enum [ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE).\n\n**Example Usage:**\n\n\t:::java\n\tupce0.preamble = PREAMBLE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE)\n\n###report_check_digit\nThe check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce0.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1\nHolds UPCE1 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUPCE1 upce1 = profileConfig.dataCapture.barcode.decoderParams.upce1;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###convert_to_upca\nEnable this to convert UPCE1 decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is af fected by UPC-A programming selections. Disable this to transmit UPCE1 decoded data as UPCE1 data, without conversion (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce1.convert_to_upca = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###preamble\nPreamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system. Use enum [ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE).\n\n**Example Usage:**\n\t:::java\n\tupce1.preamble = PREAMBLE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE)\n\n###report_check_digit\nThe check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce1.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-USPlanet","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.USPlanet","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.USPlanet\n\nHolds US Planet configuration settings.\n\n**Example Usage:**\n\n\t:::java\n \tUSPlanet usPlanet = profileConfig.dataCapture.barcode.decoderParams.usPlanet;\n\n\n##Public Fields\n\n###report_check_digit\nTransmit USPlanet data with or without the check digit. (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n Example Usage:\n\n \tusPlanet.report_check_digit = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-USPostnet","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.USPostnet","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.USPostnet\n\nHolds US Postnet configuration settings.\n\n **Example Usage:**\n\n \t:::java\n \tUSPostnet usPostnet = profileConfig.dataCapture.barcode.decoderParams.usPostnet;\n\n\n##Public Fields\n\n###report_check_digit\nTransmit USPostnet data with or without the check digit. (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n Example Usage:\n\n \tusPostnet.report_check_digit = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams","name":"ProfileConfig.DataCapture.Barcode.DecoderParams","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams\nHolds Decoder configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tDecoderParams decoderParams = profileConfig.dataCapture.barcode.decoderParams;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###codabar\nConfigures the Codabar Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.codabar.clsi_editing = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar)\n\n###code11\nConfigures the Code11 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code11](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code11.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code11](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11)\n\n###code128\nConfigures the Code128 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code128](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code128.enable_ean128 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code128](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128)\n\n###code39\nConfigures the Code39 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code39](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39).\n\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code39.full_ascii = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code39](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39)\n\n###code93\nConfigures the Code93 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code93](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code93.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code93](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93)\n\n###composite_AB\nConfigures the Composite AB Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.composite_AB.ucc_link_mode = UCC_LINK_MODE.ALWAYS_LINKED;\n\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB)\n\n###discrete_2of5\nConfigures the Discrete_2of5 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.discrete_2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5)\n\n###interleaved_2of5\nConfigures the Interleaved 2of5 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.interleaved_2of5.check_digit = CHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5)\n\n###matrix_2of5\nConfigures the Matrix 2of5 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.matrix_2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5)\n\n###msi\nConfigures the MSI Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.MSI](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.msi.check_digit = CHECK_DIGIT.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.MSI](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI)\n\n###uk_Postal\nConfigures the UK_Postal Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.uk_Postal.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal)\n\n###upca\nConfigures the UPCA Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.upca.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA)\n\n###upce0\nConfigures the UPCE0 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.upce0.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0)\n\n###upce1\nConfigures the UPCE1 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.upce1.convert_to_upca = ENABLED_STATE.DEFAULT;\n\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-Decoders","name":"ProfileConfig.DataCapture.Barcode.Decoders","md":"#ProfileConfig.DataCapture.Barcode.Decoders\nThe Decoders class provides access to enable or disable decoder barcode symbologies.\n\n**Example Usage:**\n\n\t:::java\n\tDecoders decoders = barcode.decoders;\n\tdecoders.upca = ENABLED_STATE.TRUE;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###australian_postal\nSets the Enabled State of Decoder Australian Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.australian_postal = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###aztec\nSets the Enabled State of Decoder Aztec. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.aztec = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###canadian_postal\nSets the Enabled State of Decoder Canadian Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.canadian_postal = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###chinese_2of5\nSets the Enabled State of Decoder Chinese 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.chinese_2of5 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###codabar\nSets the Enabled State of Decoder Codabar. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.codabar = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code11\nSets the Enabled State of Decoder Code11. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code11 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code128\nSets the Enabled State of Decoder Code 128. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code128 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code39\nSets the Enabled State of Decoder Code 39. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code39 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code93\nSets the Enabled State of Decoder Code 93. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code93 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###composite_ab\nSets the Enabled State of Decoder Composite AB. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.composite_ab = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###composite_c\nSets the Enabled State of Decoder Composite C. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.composite_c = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###d2of5\nSets the Enabled State of Decoder Discrete 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.d2of5 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###datamatrix\nSets the Enabled State of Decoder Data Matrix. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.datamatrix = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###dutch_postal\nSets the Enabled State of Decoder Dutch Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.dutch_postal = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###ean13\nSets the Enabled State of Decoder EAN-13. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.ean13 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###ean8\nSets the Enabled State of Decoder EAN-8. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.ean8 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###gs1_databar\nSets the Enabled State of Decoder Interleaved 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.gs1_databar = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###gs1_databar_exp\nSets the Enabled State of Decoder GS1 DataBar Expanded. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.gs1_databar_exp = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###gs1_databar_lim\nSets the Enabled State of Decoder GS1 DataBar Limited. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.gs1_databar_lim = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###i2of5\nUse enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.i2of5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###japanese_postal\nSets the Enabled State of Decoder Japan Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.japanese_postal = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###korean_3of5\nSets the Enabled State of Decoder Korean 3 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.korean_3of5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###matrix_2of5\nSets the Enabled State of Decoder Matrix 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.matrix_2of5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###maxicode\nSets the Enabled State of Decoder Maxicode. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.maxicode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###micropdf\nSets the Enabled State of Decoder Micro PDF. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.micropdf = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###microqr\nSets the Enabled State of Decoder Micro QR. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.microqr = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###msi\nSets the Enabled State of Decoder MSI. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.msi = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###pdf417\nSets the Enabled State of Decoder PDF417. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.pdf417 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###qrcode\nSets the Enabled State of Decoder QR Code. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.qrcode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###signature\nSets the Enabled State of Decoder Signature. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.signature = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###tlc39\nSets the Enabled State of Decoder TLC 39. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.tlc39 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###trioptic39\nSets the Enabled State of Decoder Trioptic 39. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.trioptic39 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###uk_postal\nSets the Enabled State of Decoder UK Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.uk_postal = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upca\nSets the Enabled State of Decoder UPCA. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.upca = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upce0\nSets the Enabled State of Decoder UPCE0. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.upce0 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upce1\nSets the Enabled State of Decoder UPCE1. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.upce1 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###us4state\nSets the Enabled State of Decoder US4State. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.us4state = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###us4state_fics\nSets the Enabled State of Decoder US4State FICS. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.us4state_fics = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###usplanet\nSets the Enabled State of Decoder US Planet. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.usplanet = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###uspostnet\nSets the Enabled State of Decoder US Postnet. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.uspostnet = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###webcode\nSets the Enabled State of Decoder Web Code. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.webcode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-ReaderParams","name":"ProfileConfig.DataCapture.Barcode.ReaderParams","md":"#ProfileConfig.DataCapture.Barcode.ReaderParams\nHolds reader configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tReaderParams readerParams = profileConfig.dataCapture.barcode.readerParams;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###beam_timer\nSets the maximum amount of time that the reader remains on (0 - 60,000 ms in increments of 100 ms). A value of 0 sets the reader to stay on indefinitely (default -15000).\n\n**Example Usage:**\n\n\t:::java\n\tint timer = readerParams.beam_timer;\n\n**Type:**\n\nint\n\n###illumination_mode\nTurns camera illumination on and off. This option is only available when camera is selected in the Barcode input Scanner selection option. Use enum [ProfileConfig.ILLUMINATION_MODE](#api-ProfileConfig?ILLUMINATION_MODE).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.illumination_mode = ILLUMINATION_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ILLUMINATION_MODE](#api-ProfileConfig?ILLUMINATION_MODE)\n\n###inverse_1d_mode\nThis parameter allows the user to select decoding on inverse 1D bar codes. Use enum [ProfileConfig.INVERSE_1D_MODE](#api-ProfileConfig?INVERSE_1D_MODE).\n\n**Example Usage:**\n\t\n\t:::java\n\treaderParams.inverse_1d_mode = INVERSE_1D_MODE.AUTO;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.INVERSE_1D_MODE](#api-ProfileConfig?INVERSE_1D_MODE)\n\n###lcd_mode\nEnables or disables LCD mode. LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones (imager only). Use enum [ProfileConfig.LCD_MODE](#api-ProfileConfig?LCD_MODE).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.lcd_mode = LCD_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.LCD_MODE](#api-ProfileConfig?LCD_MODE)\n\n###linear_security_level\nSets the number of times a bar code is read to confirm an accurate decode. Use enum [ProfileConfig.LINEAR_SECURITY_LEVEL](#api-ProfileConfig?LINEAR_SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.linear_security_level = LINEAR_SECURITY_LEVEL.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.LINEAR_SECURITY_LEVEL](#api-ProfileConfig?LINEAR_SECURITY_LEVEL)\n\n###low_power_timeout\nTime in milliseconds of non-use before dropping to a low-power mode.\n\n**Example Usage:**\n\n\t:::java\n\tint timeout = readerParams.low_power_timeout;\n\n**Type:**\n\nint\n\n###picklist\nAllows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is targeted for decode. Use enum [ProfileConfig.PICK_LIST](#api-ProfileConfig?PICK_LIST).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.picklist = PICK_LIST.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PICK_LIST](#api-ProfileConfig?PICK_LIST)\n\n###viewfinder_mode\nConfigures the Viewfinder modes supported for camera scanning. Use enum [ProfileConfig.VIEWFINDER_MODE](#api-ProfileConfig?VIEWFINDER_MODE).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.viewfinder_mode = VIEWFINDER_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.VIEWFINDER_MODE](#api-ProfileConfig?VIEWFINDER_MODE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-ScanParams","name":"ProfileConfig.DataCapture.Barcode.ScanParams","md":"#ProfileConfig.DataCapture.Barcode.ScanParams\nHolds scanning configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tScanParams scanParams = profileConfig.dataCapture.barcode.scanParams;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###code_id_type\nA Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol. Use enum [ProfileConfig.CODE_ID_TYPE](#api-ProfileConfig?CODE_ID_TYPE).\n\n**Example Usage:**\n\n\t:::java\n\tscanParams.code_id_type = CODE_ID_TYPE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CODE_ID_TYPE](#api-ProfileConfig?CODE_ID_TYPE)\n\n###datacapture_led_id\nData Capture LED ID\n\n**Example Usage:**\n\n\t:::java\n\tint led = scanParams.datacapture_led_id;\n\n**Type:**\n\nint\n\n###decode_audio_feedback_uri\nSelect an audio tone to sound upon a good decode.\n\n**Example Usage:**\n\n\t:::java\n\tString audioFeedback = scanParams.decode_audio_feedback_uri;\n\n**Type:**\n\njava.lang.String\n\n###decode_haptic_feedback\nEnable the device to vibrate upon a good decode (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tscanParams.decode_haptic_feedback = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###good_decode_led_timer\nTime for which Good Decode LED Notification Runs in milliseconds.\n\n**Example Usage:**\n\n\t:::java\n\tint ledTimer = scanParams.good_decode_led_timer;\n\n**Type:**\n\nint\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-UpcEanParams","name":"ProfileConfig.DataCapture.Barcode.UpcEanParams","md":"#ProfileConfig.DataCapture.Barcode.UpcEanParams\nHolds Upc Ean Params configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUpcEanParams upcEanParams = profileConfig.dataCapture.barcode.upcEanParams;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###bookland\nFlag to enable Bookland code decoding. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.bookland = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bookland_format\nSpecifies the bookland format to use. Use enum [ProfileConfig.BOOKLAND_FORMAT](#api-ProfileConfig?BOOKLAND_FORMAT).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.bookland_format = BOOKLAND_FORMAT.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.BOOKLAND_FORMAT](#api-ProfileConfig?BOOKLAND_FORMAT)\n\n###coupon\nEnables Coupon code decoding. Note that in order to successfully decode Coupon codes, all of the correct decoders must be enabled. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.coupon = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###coupon_report\nUsed to differentiate between old coupon (UPC/EAN and Code128) and new GS1 DataBar Coupons. NOTE: There is an Interim GS1 DataBar Coupon (UPC A and the GS1 DataBar), which is meant for smooth transition of adaption from old coupon format to new coupon format. If an interim coupon is presented to the scanner, it will read old or new portion of it, depending on the report mode setting. Use enum [ProfileConfig.COUPON_REPORT](#api-ProfileConfig?COUPON_REPORT).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.coupon_report = COUPON_REPORT.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.COUPON_REPORT](#api-ProfileConfig?COUPON_REPORT)\n\n###databar_to_upc_ean\nIf this is set it converts DataBar bar codes to UPC/EAN format. For this setting to work UPC/EAN symbologies must be enabled. A check in the checkbox indicates that the option is enabled. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.databar_to_upc_ean = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###linear_decode\nFlag to enable linear decode. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.linear_decode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###random_weight_check_digit\nFlag to enable random weight check digit verification. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.random_weight_check_digit = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###retry_count\nRetry count for auto-discriminating for supplementals. Possible values are 2 to 20 inclusive. Note that this flag is only considered if Supplemental Mode - UPC EAN is set to one of the following values: Supplementals Auto, Supplementals Smart, Supplementals 378-379 , Supplementals 978-979, Supplementals 977 or Supplementals 414-419-434-439 (2 to 20, default 10).\n\n**Example Usage:**\n\n\t:::java\n\tint retry = upcEanParams.retry_count;\n\n**Type:**\n\nint\n\n###security_level\nThe scanner of fers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application. Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\t\n\t:::java\n\tupcEanParams.security_level = SECURITY_LEVEL.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n###supplemental2\nFlag to enable length 2 supplementals. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.supplemental2 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###supplemental5\nFlag to enable length 5 supplementals. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.supplemental5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###supplemental_mode\nThe supplemental mode. Use enum [ProfileConfig.SUPPLEMENTAL_MODE](#api-ProfileConfig?SUPPLEMENTAL_MODE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.supplemental_mode = SUPPLEMENTAL_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SUPPLEMENTAL_MODE](#api-ProfileConfig?SUPPLEMENTAL_MODE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode","name":"ProfileConfig.DataCapture.Barcode","md":"#ProfileConfig.DataCapture.Barcode\nHolds Barcode configuration settings\n\n**Example Usage:**\n\n\t:::java\n\tBarcode barcode = profileConfig.dataCapture.barcode;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###decoderParams\nGets and Sets DecoderParams configuration object [ProfileConfig.DataCapture.Barcode.DecoderParams](#api-ProfileConfig-DataCapture-Barcode-DecoderParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.decoderParams.upca.preamble = PREAMBLE.SYS_CHAR;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams](#api-ProfileConfig-DataCapture-Barcode-DecoderParams)\n\n###decoders\nGets and Sets Decoders configuration object [ProfileConfig.DataCapture.Barcode.Decoders](#api-ProfileConfig-DataCapture-Barcode-Decoders).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.decoders.codabar = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.Decoders](#api-ProfileConfig-DataCapture-Barcode-Decoders)\n\n###readerParams\nGets and Sets ReaderParams configuration object [ProfileConfig.DataCapture.Barcode.ReaderParams](#api-ProfileConfig-DataCapture-Barcode-ReaderParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.readerParams.illumination_mode = ILLUMINATION_MODE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.ReaderParams](#api-ProfileConfig-DataCapture-Barcode-ReaderParams)\n\n###scanParams\nGets and Sets ScanParams configuration object [ProfileConfig.DataCapture.Barcode.ScanParams](#api-ProfileConfig-DataCapture-Barcode-ScanParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.ScanParams.decode_haptic_feedback = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.ScanParams](#api-ProfileConfig-DataCapture-Barcode-ScanParams)\n\n###scannerSelection\nGets and Sets scanner selection [ProfileConfig.DEVICETYPES](#api-ProfileConfig?DEVICETYPES).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.scannerSelection = DEVICETYPES.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DEVICETYPES](#api-ProfileConfig?DEVICETYPES)\n\n###scanner_input_enabled\nGets and Sets scanner enabled state [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.scanner_input_enabled = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upcEanParams\nGets and Sets UpcEanParams configuration object [ProfileConfig.DataCapture.Barcode.UpcEanParams](#api-ProfileConfig-DataCapture-Barcode-UpcEanParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.upcEanParams.linear_decode = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.UpcEanParams](#api-ProfileConfig-DataCapture-Barcode-UpcEanParams)\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting","name":"ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting","md":"#ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting\nHolds Basic Data Formatting configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tBasicDataFormatting basicDataFormatting = profileConfig.dataCapture.dataDelivery.intent.basicDataFormatting;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###bdf_enabled\nEnables or disables Basic Data Formatting (default - enabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\t\n\t:::java\n\tbasicDataFormatting.bdf_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_prefix\nAdd characters to the beginning of the data when sent.\n\n**Example Usage:**\n\t\n\t:::java\n\tString prefix = basicDataFormatting.bdf_prefix;\n\n**Type:**\n\njava.lang.String\n\n###bdf_send_data\nSet to transfer the captured data to the foreground application. Disabling this option prevents the actual data from being transmitted. However, the prefix and suf fix strings, if present, are still transmitted even when this option is disabled (default - enabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_data = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_send_enter\nSet to append an Enter character to the end of the processed data(default - disabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_enter = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_send_hex\nSet to send the data in hexadecimal format(default - disabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_hex = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_send_tab\nSet to append a tab character to the end of the processed data(default - disabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_tab = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_suffix\nAdd characters to the end of the data when sent.\n\n**Example Usage:**\n\n\t:::java\n\tString suffix = basicDataFormatting.bdf_suffix;\n\n**Type:**\n\njava.lang.String\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery-Intent","name":"ProfileConfig.DataCapture.DataDelivery.Intent","md":"#ProfileConfig.DataCapture.DataDelivery.Intent\nHolds Intent configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tIntent intent = profileConfig.Intent;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###action\nGets and Sets the intent action.\n\n**Example Usage:**\n\n\t:::java\n\tString action = intent.action;\n\n**Type:**\n\njava.lang.String\n\n###basicDataFormatting\nGets and Sets intent INTENT_DELIVERY configuration object [ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting).\n\n**Example Usage:**\n\n\t:::java\n\tintent.BasicDataFormatting.bdf_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting)\n\n###category\nGets and Sets the intent category.\n\n**Example Usage:**\n\n\t:::java\n\tString category = intent.category;\n\n**Type:**\n\njava.lang.String\n\n###delivery\nGets and Sets intent INTENT_DELIVERY configuration enum [ProfileConfig.INTENT_DELIVERY](#api-ProfileConfig?INTENT_DELIVERY).\n\n**Example Usage:**\n\n\t:::java\n\tintent.delivery = INTENT_DELIVERY.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.INTENT_DELIVERY](#api-ProfileConfig?INTENT_DELIVERY)\n\n###output_enabled\nGets and Sets intent ENABLED_STATE configuration enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tintent.output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery-Keystroke","name":"ProfileConfig.DataCapture.DataDelivery.Keystroke","md":"#ProfileConfig.DataCapture.DataDelivery.Keystroke\nHolds Keystroke configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tKeystroke keystroke = profileConfig.dataCapture.dataDelivery.keystroke;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n\n###basicDataFormatting\nGets and Sets keystroke basic data formatting configuration object [ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting).\n\n**Example Usage:**\n\n\t:::java\n\tkeystroke.BasicDataFormatting.bdf_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting)\n\n###ime_output_enabled\nGets and Sets keystroke ENABLED_STATE configuration enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tkeystroke.ime_output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###keystroke_action_char\nGets and Sets keystroke ACTION_KEY_CHAR configuration enum [ProfileConfig.ACTION_KEY_CHAR](#api-ProfileConfig?ACTION_KEY_CHAR).\n\n**Example Usage:**\n\n\t:::java\n\tkeystroke.keystroke_action_char = ACTION_KEY_CHAR.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ACTION_KEY_CHAR](#api-ProfileConfig?ACTION_KEY_CHAR)\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery","name":"ProfileConfig.DataCapture.DataDelivery","md":"#ProfileConfig.DataCapture.DataDelivery\nClass for dealing with DataDelivery profile data ProfileConfig.DataCapture.DataDelivery.\n\n**Example Usage:**\n\n\t:::java\n\tDataDelivery dataDelivery = profileConfig.dataCapture.dataDelivery;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###intent\nGets and Sets Intent configuration object [ProfileConfig.DataCapture.DataDelivery.Intent](#api-ProfileConfig-DataCapture-DataDelivery-Intent).\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.dataDelivery.intent.output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.Intent](#api-ProfileConfig-DataCapture-DataDelivery-Intent)\n\n###keystroke\nGets and Sets Keystroke configuration object [ProfileConfig.DataCapture.DataDelivery.Keystroke](#api-ProfileConfig-DataCapture-DataDelivery-Keystroke).\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.dataDelivery.keystroke.ime_output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.Keystroke](#api-ProfileConfig-DataCapture-DataDelivery-Keystroke)\n\n"},{"key":"api-ProfileConfig-DataCapture-MSR","name":"ProfileConfig.DataCapture.MSR","md":"#ProfileConfig.DataCapture.MSR\nHolds MSR configuration settings\n\n**Example Usage:**\n\n\t:::java\n\tMSR msr = profileConfig.dataCapture.msr;\n\n**Version:**\n\n2.0\n\n##Constructors\n\n###ProfileConfig.DataCapture.MSR()\n\n##Public Fields\n\n###msr_input_enabled\nGets and Sets MSR enabled configuration enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmsr.msr_input_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture","name":"ProfileConfig.DataCapture","md":"#ProfileConfig.DataCapture\nClass for dealing with data capture profile data ProfileConfig.DataCapture\n\n**Example Usage:**\n\n\t:::java\n\tDataCapture dataCapture = profileConfig.dataCapture;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###barcode\nGets and Sets Barcode configuration object.\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.barcode.decoders.code11 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode](#api-ProfileConfig-DataCapture-Barcode)\n\n###dataDelivery\nGets and Sets DataDelivery configuration object.\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.dataDelivery.keystroke.ime_output_enabled = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery](#api-ProfileConfig-DataCapture-DataDelivery)\n\n###msr\nGets and Sets MSR configuration object.\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.msr.msr_input_enabled = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.MSR](#api-ProfileConfig-DataCapture-MSR)\n\n\n"},{"key":"api-ProfileConfig","name":"ProfileConfig","md":"#ProfileConfig\nClass for dealing with profile data\n\n**Example Usage:**\n\n\t:::java\n\tProfileConfig profileConfig = new ProfileConfig();\n\n**Version:**\n\n1.0\n\n##Constructors\n\n###ProfileConfig()\nCreates a new instance of ProfileConfig.\n\n**Example Usage:**\n\n\t:::java\n\tProfileConfig profileConfig = new ProfileConfig();\n\n\n##Public Fields\n###activitySelection\nGets and Sets the activity selection for the profiles [ProfileConfig.ActivitySelection](#api-ProfileConfig-ActivitySelection). If no activities are associated to profile, the profile will be associated to that application for that session.\n\n**Example Usage:**\n\n\t:::java\n\tActivitySelection activitySelection = profileConfig.activitySelection;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ActivitySelection](#api-ProfileConfig-ActivitySelection)\n\n###dataCapture\nGets and Sets the profiles DataCapture object [ProfileConfig.DataCapture](#api-ProfileConfig-DataCapture).\n\n**Example Usage:**\n\n\t:::java\n\tDataCapture dataCapture = profileConfig.dataCapture;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture](#api-ProfileConfig-DataCapture)\n\n###modifiedDate\nGets and Sets the profiles modified date string.\n\n**Example Usage:**\n\n\t:::java\n\tString profileDate = profileConfig.modifiedDate;\n\n\n**Type:**\n\njava.lang.String\n\n###profileName\nGets and Sets the profile name.\n\n**Example Usage:**\n\n\t:::java\n\tString profileName = profileConfig.profileName;\n\n\n**Type:**\n\njava.lang.String\n\n##Public Enums\n###ACTION_KEY_CHAR\nKeystroke Output Action key character enables decoding of a special character embedded within a bar code or MSR data for use in native Android applications. This feature is helpful when populating or executing a form.\n\n**Example Usage:**\n\n\t:::java\n\tACTION_KEY_CHAR.NONE;\n\n\n**Values:**\n\n* **DEFAULT** - Default action key character configured on the device.\n\n* **NONE** - Action key character feature is disabled.\n\n* **TAB** - Tab character code in a bar code is processed. When DataWedge detects this character code in a bar code, move the focus to the next field.\n\n* **LINEFEED** - Line feed character code in a bar code is processed. When DataWedge detects this character code in a bar code, move the focus to the next field.\n\n* **CARRIAGERETURN** - Carriage return character code in a bar code is processed. When DataWedge detects this character code in a bar code, move the focus to the next field.\n\n###BOOKLAND_FORMAT\nLists the Bookland formats\n\n**Example Usage:**\n\n\t:::java\n\tBOOKLAND_FORMAT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default bookland format configured on device.\n\n* **ISBN_10** - 978 reported in 10 digit mode.\n\n* **ISBN_13** - 978/979 transmitted as EAN13 as per 2007 ISBN-13 protocol.\n\n###CHECK_DIGIT\nThe number of check digits to be verified. With MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default check digit configured on device.\n\n* **ONE** - Verify one check digit.\n\n* **TWO** - Verify two check digits.\n\n###CHECK_DIGIT_SCHEME\nTwo algorithms are possible for the verification of the second MSI check digit. Select the algorithm used to encode the check digit.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT_SCHEME.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default check digit scheme configured on device.\n\n* **MOD_11_10** - First check digit is MOD 11 and second check digit is MOD 10.\n\n* **MOD_10_10** - Both check digits are MOD 10.\n\n###CHECK_DIGIT_TYPE\nVerify data integrity.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default check digit type configured on device.\n\n* **NO** - A check digit is not used.\n\n* **USS** - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Uniform Symbology Specification (USS) check digit algorithm.\n\n* **OPCC** - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Optical Product Code Council (OPCC) check digit algorithm.\n\n###CODE_ID_TYPE\nA Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol.\n\n**Example Usage:**\n\n\t:::java\n\tCODE_ID_TYPE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default prefix configured on device.\n\n* **NONE** - No prefix.\n\n* **AIM** - A standards based three character prefix.\n\n* **SYMBOL** - A Symbol defined single character prefix.\n\n###COUPON_REPORT\nSupported Coupon modes\n\n**Example Usage:**\n\n\t:::java\n\tCOUPON_REPORT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default coupon reports mode configured on device.\n\n* **OLD** - Scanner will read only the old coupon format.\n\n* **NEW** - Scanner will read only the new GS1 DataBar coupon format.\n\n* **BOTH** - Scanner will read both old coupon format as well as the new GS1 DataBar coupon format.\n\n###DEVICETYPES\nList of supported scanner device types.\n\n**Example Usage:**\n\n\t:::java\n\tDEVICETYPES.INTERNAL_LASER1;\n\n\n**Values:**\n\n* **AUTO** - Default scanner device configured on device.\n\n* **INTERNAL_LASER1** - Internal laser.\n\n* **INTERNAL_CAMERA1** - Internal camera.\n\n* **INTERNAL_IMAGER1** - Internal imager.\n\n###ENABLED_STATE\nEnable states.\n\n**Example Usage:**\n\n\t:::java\n\tENABLED_STATE.FALSE;\n\n\n**Values:**\n\n* **DEFAULT** - Default enable state configured on device.\n\n* **FALSE** - Disabled.\n\n* **TRUE** - Enabled.\n\n###ILLUMINATION_MODE\nTurns camera illumination on and off. This option is only available when camera is selected in the Barcode input Scanner selection option.\n\n**Example Usage:**\n\n\t:::java\n\tILLUMINATION_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default illumination configured on device.\n\n* **OFF** - External illumination is always is off.\n\n* **ON** - External illumination is always on.\n\n###INTENT_DELIVERY\nAllows configuration of the Intent Output Plug-in for the profile. The Intent Output Plug-in allows the captured data to be sent to an application in the form of an implicit Intent.\n\n**Example Usage:**\n\n\t:::java\n\tINTENT_DELIVERY.SEND_VIA_STARTACTIVITY;\n\n\n**Values:**\n\n* **DEFAULT** - Default intent delivery type configured on the device.\n\n* **SEND_VIA_STARTACTIVITY** - Send output via StartActivity.\n\n* **SEND_VIA_STARTSERVICE** - Send output via startService.\n\n* **BROADCAST_INTENT** - Send output via Broadcast intent.\n\n###INVERSE_1D_MODE\nThis parameter allows the user to select decoding on inverse 1D bar codes.\n\n**Example Usage:**\n\n\t:::java\n\tINVERSE_1D_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default inverse 1D mode configured on device.\n\n* **DISABLED** - Disables decoding of inverse 1D symbologies.\n\n* **ENABLED** - Enables decoding of only inverse 1D symbologies.\n\n* **AUTO** - Allows decoding of both positive as well as inverse 1D symbologies.\n\n###ISBT128_CONTACT_MODE\nOption for concatenating pairs of ISBT128 code types.\n\n**Example Usage:**\n\n\t:::java\n\tISBT128_CONTACT_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default ISBT128 concatenation configured on device.\n\n* **NEVER** - Will ignore the barcode pair and only output decode data for only one of the barcodes.\n\n* **ALWAYS** - Will not decode if both the barcodes are not present or if one of them cannot be decoded. There must be two ISBT codes in order to decode and perform concatenation.\n\n* **AUTO** - Decodes and concatenates pairs of ISBT codes immediately. If only a single ISBT symbol is present, the device must decode the symbol the number of times set via DataWedge Configuration 4 - 1 1 Redundancy - Code128 before transmitting its data to confirm that there is no additional ISBT symbol.\n\n###LCD_MODE\nEnable or disable LCD mode (for Blockbuster imager devices only). LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones.\n\n**Example Usage:**\n\n\t:::java\n\tLCD_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default LCD mode configured on device.\n\n* **DISABLED** - Disables LCD mode.\n\n* **ENABLED** - Enables LCD mode.\n\n###LINEAR_SECURITY_LEVEL\nSets the number of times a bar code is read to confirm an accurate decode.\n\n**Example Usage:**\n\n\t:::java\n\tLINEAR_SECURITY_LEVEL.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default linear security level configured on device.\n\n* **SHORT_OR_CODABAR** - Two times read redundancy if short bar code or Codabar.\n\n* **ALL_TWICE** - Two times read redundancy for all bar codes (default).\n\n* **LONG_AND_SHORT** - Two times read redundancy for long bar codes, three times for short bar codes.\n\n* **ALL_THRICE** - Three times read redundancy for all bar codes.\n\n###PICK_LIST\nAllows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is tar geted for decode.\n\n**Example Usage:**\n\n\t:::java\n\tPICK_LIST.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default pick list configured on device.\n\n* **DISABLED** - Disables Picklist mode. Any bar code within the field of view can be decoded.\n\n* **ENABLED** - Enables the Picklist mode so that only the bar code that is directly under the cross-hair (reticle) is decoded. This is useful when used in conjunction with the static and dynamic reticle viewfinder modes. (Scan Module Only).\n\n* **CENTERED** - Enables the Picklist mode so that only the bar code in the center of the image is decoded. This is most useful when used in conjunction with the static and dynamic reticle viewfinder modes. Note: This mode is only valid for decoder modules that supports a viewfinder. If one tries to set this for a unsupported decoder then the device would issue an error. (Camera scanner only)\n\n###PREAMBLE\nControls the preamble applied to the bar code Preamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system.\n\n**Example Usage:**\n\n\t:::java\n\tPREAMBLE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default preamble configured on device.\n\n* **NONE** - No preamble.\n\n* **SYS_CHAR** - System character preamble.\n\n* **COUNTRY_AND_SYS_CHAR** - Both country and system code preamble.\n\n###SECURITY_LEVEL\nThe scanner offers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default security level configured on device.\n\n* **LEVEL_0** - This setting allows the scanner to operate fastest, while providing sufficient security in decoding \"in-spec\" UPC/EAN bar codes (default).\n\n* **LEVEL_1** - As bar code quality levels diminish, certain characters become prone to misdecodes before others (i.e., 1, 2, 7, 8). If the scanner is misdecoding poorly printed bar codes, and the misdecodes are limited to these characters, select this security level.\n\n* **LEVEL_2** - If the scanner is misdecoding poorly printed bar codes, and the misdecodes are not limited to characters 1, 2, 7, and 8, select this security level.\n\n* **LEVEL_3** - If the scanner is still misdecoding, select this security level. Be advised, selecting this option is an extreme measure against misdecoding severely out of spec bar codes. Selecting this level of security can significantly impair the decoding ability of the scanner. If this level of security is necessary, try to improve the quality of the bar codes.\n\n###SUPPLEMENTAL_MODE\nSupplemental modes.\n\n**Example Usage:**\n\n\t:::java\n\tSUPPLEMENTAL_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default supplemental mode configured on device.\n\n* **NO** - The scanner is presented with a UPC/EAN plus supplemental symbol, the scanner decodes UPC/EAN and ignores the supplemental characters.\n\n* **ALWAYS** - The scanner only decodes UPC/EAN symbols with supplemental characters, and ignores symbols without supplementals.\n\n* **AUTO** - The scanner decodes UPC/EAN symbols with supplemental characters immediately . If the symbol does not have a supplemental, the scanner must decode the bar code the number of times set via UPC/EAN Supplemental Redundancy before transmitting its data to confirm that there is no supplemental.\n\n* **SMART** - Enables smart supplementals. In this mode the decoder returns the decoded value of the main block right away if it does not belong to one of the following supplemental types: 378, 379, 977, 978, 979, 414, 419, 434 or 439. If the bar code starts with one of the prefixes it searches the image more aggressively for a supplemental. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n* **S_378_379** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 378 or 379. Disables reading of supplementals for any other UPC/EAN bar code not starting with 378 or 379. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n* **S_978_979** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 978 or 979. Disables reading of supplementals for another UPC/EAN bar code not starting with 978 or 979. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n* **S_414_419_434_439** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 414, 419, 434 or 439. Disables reading of supplementals for another UPC/EAN bar code 4 - 16 not starting with 414, 419, 434 or 439. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n* **S_977** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 977. Disables reading of supplementals for another UPC/EAN barcode not starting with 977. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n###UCC_LINK_MODE\nDescribes the UCC link mode state.\n\n**Example Usage:**\n\n\t:::java\n\tUCC_LINK_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default UCC link mode configured on device.\n\n* **LINK_FLAG_IGNORED** - 1D component is transmitted regardless of whether a 2D component is detected.\n\n* **ALWAYS_LINKED** - 1D and the 2D components are transmitted. If 2D is not present, the 1D component is not transmitted.\n\n* **AUTO_DISCRIMINATE** - the digital scanner determines if there is a 2D portion, then transmits the 1D component, as well as the 2D portion if present (default). (default).\n\n###VERIFY_CHECK_DIGIT\nCheck the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code.\n\n**Example Usage:**\n\n\t:::java\n\tVERIFY_CHECK_DIGIT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default verify check digit scheme configured on device.\n\n* **NO** - Do not verify check digit.\n\n* **ONE** - Bar code contains one check digit.\n\n* **TWO** - Bar code contains two check digits.\n\n###VIEWFINDER_MODE\nConfigures the Viewfinder modes supported for camera scanning.\n\n**Example Usage:**\n\n\t:::java\n\tVIEWFINDER_MODE.ENABLED;\n\n\n**Values:**\n\n* **DEFAULT** - Default view finder mode configured on the device.\n\n* **DISABLED** - Viewfinder disabled. Viewfinder is not displayed during aiming or scanning.\n\n* **ENABLED** - Viewfinder enabled. Displays the images captured by the camera on the screen.\n\n* **STATIC_RECTICLE** - Viewfinder enabled with locate reticle. Displays the viewfinder as well as draws a red reticle in the center of the screen which helps with tracking the barcode.\n\n###ProfileConfig.VOLUME_SLIDER_TYPE\nDefines the notification type for a good decode.\n\n**Example Usage:**\n\n\t:::java\n\tVOLUME_SLIDER_TYPE.DEFAULT;\n\n**Values:**\n\n* **DEFAULT** - Default prefix configured on device\n\n* **RINGER_AND_NOTIFICATIONS** - Ringer and Notifications.\n\n* **MUSIC_AND_MEDIA** - Music and Media.\n\n* **ALARM** - Alarms.\n\n\n###ProfileConfig.POWER_MODE\nSets the scanner power mode.\n\n**Example Usage:**\n\n\t:::java\n\tPOWER_MODE.DEFAULT;\n\n**Values:**\n\n* **DEFAULT** - Default linear security level configured on device.\n\n* **LOW** - Lowest power, but slowest performance.\n\n* **OPTIMIZED** - Power level adjusts with scanning usage (Default).\n\n* **HIGH** - High power, and excellent performance.\n\n* **ALWAYS_ON** - Highest power, fastest performance.       \n"},{"key":"api-ProfileManager-DataListener","name":"ProfileManager.DataListener","md":"#ProfileManager.DataListener\nAn interface for notifying client applications to notify processProfileAsync result.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements DataListener {\n\t\t.. .. ..\n\t}\n\n**Version:**\n\n3.1\n\n##Public Methods\n\n###onData(ProfileManager.ResultData resultData)\nThis is the callback method to be called upon the processProfileAsync task completion.\n\n**Parameters:**\n\n**resultData** - [ResultData](#api-ProfileManager-ResultData) object."},{"key":"api-ProfileManager-ResultData","name":"ProfileManager.ResultData","md":"#ProfileManager.ResultData\nThis class provides the Status detail of processProfileAsync method.\n\n\n**Version:**\n\n3.1\n\n##Public Methods\n\n###getResult()\nClass for holding status of processProfileAsync method.\n\n**Returns:**\n\n[EMDKResults](#api-EMDKResults)\n\n\n###getProfileName()\nReturns the profile name sent in processProfileAsync method.\n\n**Returns:**\n\nString - profile name sent in processProfileAsync method.\n\n\n###getProfileFlag()\nReturns the profile flag sent in processProfileAsync method.\n\n**Returns:**\n\n[ProfileManager.PROFILE_FLAG](#api-ProfileManager?ProfileManager.PROFILE_FLAG) - Returns the [Profile Flag](#api-ProfileManager?ProfileManager.PROFILE_FLAG) sent in processProfileAsync method.\n\n\n###getProfileString()\nReturns the profile data as string requested in the processProfileAsync method.\n\n**Returns:**\n\nString - Returns the profile data as string requested in the processProfileAsync method.\n\n\n###getProfileDocument()\nReturns the profile data as DOM document requested in the processProfileAsync method.\n\n**Returns:**\n\norg.w3c.dom.Document - Returns the profile data as DOM document requested in the processProfileAsync method.\n\n\n###getProfileConfig()\nReturns the profile data as [ProfileConfig](#api-ProfileConfig) object.\n\n**Returns:**\n\n[ProfileConfig](#api-ProfileConfig) - Returns the profile data as [ProfileConfig](#api-ProfileConfig) object. "},{"key":"api-ProfileManager","name":"ProfileManager","md":"#ProfileManager\nThis class handles all the profile related functions.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);\n\t}\n\n**Version:**\n\n1.0\n\n##Public Methods\n###isPreviousRequestPending()\nThis method tells whether the previous process profile request is pending or not. If the previous request is pending, you can't submit the next request till the current request completes and calling the process profile method will return error.\n\n**Returns:**\n\nboolean - Returns whether the previous process profile request is pending or not. \n\n###processProfile(String profileName, ProfileManager.PROFILE_FLAG profileFlag, Document extraData)\nProcesses the given profile based on the data provided and the flag and return status of the action.\n\n**Example Usage:**\n\n\t:::java\n\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\tDocumentBuilder db = dbf.newDocumentBuilder();\n\tDocument extraData;\n\textraData = db.newDocument();\n\tprofileManager.processProfile(\"Profile1\", PROFILE_FLAG.GET, extraData);\n\n**Parameters:**\n\n* **profileName** - Name of the profile. ex: 'Profile1'.\n\t* You can also specify just part of the profile when a fully qualified name of the following format is given: `[profileName][featureType][name in profile parameter]` to just edit part of the profile. For example, if my profile is called 'Profile1' and the name in profile parameter is 'myName'. Passing 'profileName' as 'Profile1/ActivitySelection/myName' will just process this part of the profile.\n\t* Valid `[featureType]`: ActivitySelection, Barcode, MSR, Intent, Keystroke, IP.\n\n* **profileFlag** - [ProfileManager.PROFILE_FLAG](#api-ProfileManager?PROFILE_FLAG) If the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device. If profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in extraData.\n\n* **extraData** - This can be used to provide data for processing action. This parameter is only supported for DataCapture profile features.\n\n**Returns:**\n\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n###processProfile(String profileName, ProfileManager.PROFILE_FLAG profileFlag, java.lang.String[] extraData)\nProcesses the given profile based on the data provided and the flag and return status of the action.\n\n**Example Usage:**\n\n\t:::java\n\tprofileManager.processProfile(\"Profile1\", PROFILE_FLAG.GET, new String[]{\"\"});\n\n**Parameters:**\n\n* **profileName** - Name of the profile. ex: 'Profile1'\n\t* You can also specify just part of the profile when a fully qualified name of the following format is given: `[profileName][featureType][name in profile parameter]` to just edit part of the profile. For example, if my profile is called EmdkSampleProfile-1 and the name I gave to the Clock feature is 'clock1'. Passing 'profileName' as ' EmdkSampleProfile-1/Clock/clock1 will just process this part of the profile.\n\t* Valid `[featureType]`:\tActivitySelection, Barcode, MSR, Intent, Keystroke, IP, Clock, PowerMgr, PersistMgr, CertMgr, AppMgr, AccessMgr, Wi-Fi, GprsMgr\n\n* **profileFlag** - [ProfileManager.PROFILE_FLAG](#api-ProfileManager?PROFILE_FLAG) If the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device. If profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in extraData.\n\n* **extraData** - This can be used to provide data for processing action. \n\n**Returns:**\n\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n###processProfile(String profileName, ProfileManager.PROFILE_FLAG profileFlag, ProfileConfig extraData)\nProcesses the given profile based on the data provided and the flag and return status of the action.\n\n**Example Usage:**\n\n\t:::java\n\t//Create the ProfileConfig object\n\tProfileConfig profileConfigObj = new ProfileConfig();\n\t//Get the ProfileConfig from the profile XML\n\tEMDKResults results = mProfileManager.processProfile(profileName, ProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t//Set the code128\n\tprofileConfigObj.dataCapture.barcode.decoders.code128 = ENABLED_STATE.TRUE;\n\t//call processPrfoile with profile name, SET flag and config data to update the profile\n\tEMDKResults results = mProfileManager.processProfile(profileName, ProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\n**Parameters:**\n\n* **profileName** - Name of the profile. ex: 'Profile1'\n\t* You can also specify just part of the profile when a fully qualified name of the following format is given: `[profileName][featureType][name in profile parameter]` to just edit part of the profile. For example, if my profile is called 'Profile1' and the name in profile parameter is 'myName'. Passing 'profileName' as 'Profile1/ActivitySelection/myName' will just process this part of the profile.\n\t* Valid `[featureType]`:\tActivitySelection, Barcode, MSR, Intent, Keystroke, IP\n\n* **profileFlag** - [ProfileManager.PROFILE_FLAG](#api-ProfileManager?PROFILE_FLAG) If the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device. If profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in extraData.\n\n* **extraData** - [ProfileConfig](#api-ProfileConfig) This can be used to provide data for processing action. This parameter is only supported for DataCapture profile features.\n\n**Returns:**\n\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n###CreateNameValuePair(java.lang.String emdkName, java.lang.String paramName, java.lang.String paramValue)\nThis function creates a name value pair string according to the Name-Value pair request. The return string is compatible with com.symbol.emdk.ProfileManager. processProfile(String profileName, PROFILE_FLAG profileFlag, String[] extraData) functions extraData array element. If this function failed it throws InvalidParameterException exception.\n\n**Parameters:**\n\n**emdk_name** - emdk name String\n\n**param_name** - Parameter name String\n\n**param_value** - Parameter value String\n\n**Returns:**\n\nThis function returns the String in the format:\n\n\t:::xml\n\t<emdk_name>.<param_name>=<param_value> \n\n\n###processProfileAsync(java.lang.String profileName, ProfileManager.PROFILE_FLAG profileFlag, org.w3c.dom.Document extraData)\nProcesses the given profile based on the data provided and the flag and return status of the request. This is an asynchronous method and result will be returned through the registered callback.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements EMDKListener, DataListener {\n \n        profileManager.addDataListener(this); \n \n        profileManager.processProfileAsync(\"Profile1\", PROFILE_FLAG.GET, null);\n\n**Parameters:**\n\n**profileName** - Name of the profile.\n\n**profileFlag** - ProfileManager.PROFILE_FLAG\n\nIf the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device. The result will be returned to the application via data listener callback. \n\nIf profileFlag is set to GET and if the profile is present in the internal repository, it will be returned via data listener callback.\n\n**extraData** - This can be used to provide data for processing action.\n\n**Returns:**\n\n[EMDKResults](#api-EMDKResults) object.\n\n\n###processProfileAsync(java.lang.String profileName, ProfileManager.PROFILE_FLAG profileFlag, java.lang.String[] extraData)\nProcesses the given profile based on the data provided and the flag and return status of the request. This is an asynchronous method and result will be returned through the registered callback.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements EMDKListener, DataListener {\n \n        profileManager.addDataListener(this);\n  \n        profileManager.processProfileAsync(\"Profile1\", PROFILE_FLAG.SET, extraData);\n\n**Parameters:**\n\n**profileName** - Name of the profile.\n\n**profileFlag** - ProfileManager.PROFILE_FLAG\n\nIf the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device.\n\nIf profileFlag is set to GET and if the profile is present in the internal repository, it will be returned data listener callback.\n\n**extraData** - This can be used to provide data for processing action.\n\n**Returns:**\n\n[EMDKResults](#api-EMDKResults) object.\n\n\n###processProfileAsync(java.lang.String profileName, ProfileManager.PROFILE_FLAG profileFlag, ProfileConfig extraData)\nProcesses the given profile based on the data provided and the flag and return status of the request. This is an asynchronous method and result will be returned through the registered callback.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements EMDKListener, DataListener {\n \n        profileManager.addDataListener(this);\n  \n        profileManager.processProfileAsync(\"Profile1\", PROFILE_FLAG.SET, null);\n\n**Parameters:**\n\n**profileName** - Name of the profile.\n\n**profileFlag** - ProfileManager.PROFILE_FLAG \n\nIf the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device.\n\nIf profileFlag is set to GET and if the profile is present in the internal repository, it will be returned via data listener callback.\n\n**extraData** - ProfileConfig This can be used to provide data for processing action.\n\n**Returns:**\n\n[EMDKResults](#api-EMDKResults) object.\n\n\n###addDataListener([ProfileManager.DataListener](#api-ProfileManager-DataListener) listener)\nThe client can register to get data notification via callbacks.\n\n**Parameters:**\n\nlistener\n\n**Returns:**\n\nvoid\n\n###removeDataListener([ProfileManager.DataListener](#api-ProfileManager-DataListener) listener)\nThe client can un-register to get data notification via callbacks.\n\n**Parameters:**\n\nlistener\n\n**Returns:**\n\nvoid    \n\n\n\n##Public Enums\n\n###ProfileManager.PROFILE_FLAG\nAll the possible actions for [ProfileManager.processProfile(String, PROFILE_FLAG, Document)](#api-ProfileManager?ProfileManager.processProfile(String, PROFILE_FLAG, Document)) and [ProfileManager.processProfile(String, PROFILE_FLAG, String[])](#api-ProfileManager?ProfileManager.processProfile(String, PROFILE_FLAG, String[]))is enumerated here.\n\n**Example Usage:**\n\n\t:::java\n\tPROFILE_FLAG.SET\n\n**Values:**\n\n* **SET** - Creates a profile with given XML data. If the profile is already created, this activates the profile if it is not bound to any activity.\n\n* **GET** - Retrieves a profile from the EMDK internal repository.\n\n* **RESET** - Resets the modified profile data available on the application cache to default profile created during the application development. This flag will not set/modify any profile to any component on the device without calling the process profile with SET flag. After resetting, calling process profile with GET flag returns the reseted profile.\n\n* **CHECK_COMPATIBILITY** - Validates the characteristic feature version in the existing profile if extraData is null, otherwise extra data profiles characteristic feature version. This validates only the profile version of the each feature (characteristic node version in the profile data), but not the individual fields. Calling process profile with this flag internally gets version of the different DSDs, the time required depends on numbers of characteristic features in a profile.   \n\n"},{"key":"api-PromptPinMessage-Screen1","name":"PromptPinMessage.Screen1 ","md":"#PromptPinMessage.Screen1 \n\n\n**Version:**\n\n1.0\n\n\n##Public Fields\n###message1\nMessage 1 to be displayed on the PINPad.\n\n**Type:**\n\njava.lang.String\n\n###message2\nMessage 2 to be displayed on the PINPad.\n\n**Type:**\n\njava.lang.String "},{"key":"api-ScanAndPairConfig-BluetoothInfo","name":"ScanAndPairConfig.BluetoothInfo","md":"#ScanAndPairConfig.BluetoothInfo\n\nThis class is used by the ScanAndPairTool class. Specifies the Bluetooth related information. The settings provided through this class are used for pairing/unpairing.\n\n\n##Constructor\n\n###BluetoothInfo()\nDefault constructor\n\n\n##Public Fields\n###deviceName\nSpecifies the Bluetooth name of the remote device. If the ScanAndPairTool.AlwaysScan is set to false, then scanning is skipped and the provided Bluetooth name is directly used for pairing. If the **ScanAndPairTool.alwaysScan** property is set to true, then provided Bluetooth name is ignored and scanning is always done. The maximum allowed length of the Bluetooth name barcode that can be scanned or explicitly provided is 123 characters.\n\n> NOTE: Scanning or explicitly providing a Bluetooth name instead of a Bluetooth address, will result in a device discovery to find the address of the device which may take additional time. \n\n**Type:**\n\njava.lang.String\n\n###macAddress\nSpecifies the MAC address of the remote Bluetooth device. If the **ScanAndPair.alwaysScan** is set to false, then scanning is skipped and the provided Bluetooth address is directly used for pairing. The allowed length of the Bluetooth address barcode is 12. If the **ScanAndPair.alwaysScan** is set to true, the provided Bluetooth address is ignored and scanning is always done. The allowed lengths of the Bluetooth address barcode that can be scanned is either 12 or 17 characters.\n\n**Type:**\n\njava.lang.String\n\n###pairingPin\nUser supplied pin for bluetooth pairing. Passed as an argument during scanAndPair and stored in this member variable for later use.\n\n**Type:**\n\njava.lang.String"},{"key":"api-ScanAndPairConfig-ScanInfo","name":"ScanAndPairConfig.ScanInfo","md":"#ScanAndPairConfig.ScanInfo\n\nThis class is used by the ScanAndPairTool class. Specifies the scanning related information. The settings provided through this class are used for scanning the barcode. It also exposes the scanned data. \n\n> NOTE: The maximum allowed length of the barcode that can be scanned is 123 characters.\n\n\n##Constructor\n###ScanInfo()\nDefault Constructor for ScanInfo class to assign the default values to its members.\n\n\n\n##Public Fields\n###scanDataType\nSpecifies the type of barcode data to be scanned. The barcode data can be either the Bluetooth address or name of the remote device. The default value is UNSPECIFIED, meaning the class library will automatically attempt to determine if it is a valid address. If it is not a valid address, it will be considered as a Bluetooth name.\n\n**Type:**\n\ncom.symbol.emdk.scanandpair.[ScanAndPairConfig.ScanDataType](#api-ScanAndPairConfig?ScanAndPairConfig.ScanDataType)\n\n\n###deviceIdentifier\nSpecifies the type of scanner to be used for scanning the barcode. The default value is FIRSTAVAILABLE. \n\n**Type:**\n\ncom.symbol.emdk.scanandpair.[ScanAndPairConfig.DeviceIdentifier](#api-ScanAndPairConfig?ScanAndPairConfig.DeviceIdentifier)\n\n###scanTimeout\nScan timeout in milliseconds. Specifies the time duration within which the barcode should be scanned.\n \n> NOTE: The default timeout value is provided by the scanner driver and it varies depending on the device. If a value of 0 is set, then it means infinite timeout.\n\n**Type:**\n\nint\n\n###triggerType\nSpecifies the type of trigger to be used. The default value is AUTO. If manual, then the hardware trigger needs to be manually pressed to turn ON the scanner. If auto, then the scanner is turned ON automatically and no need to press any triggers.\n\n**Type:**\n\ncom.symbol.emdk.scanandpair.[ScanAndPairConfig.TriggerType](#api-ScanAndPairConfig?ScanAndPairConfig.TriggerType)\n\n\n##Public Methods\n###getScannedData()\nProvides the scanned data. The maximum allowed length of the barcode that can be scanned is 123 characters.\n\n**Returns:**\n\njava.lang.String"},{"key":"api-ScanAndPairConfig","name":"ScanAndPairConfig","md":"#ScanAndPairConfig\n\nThe ScanAndPairConfig class provides a way to configure the settings to use it in scanAndPair() or scanAndUnpair() methods. These settings must be done before calling the scanAndPair() or scanAndUnpair() methods and do not modify the this while the method is processing its job.\n\n\n\n##Public Fields\n###alwaysScan\nIt Specifies if a scan should always be performed to get the Bluetooth address or name of the remote device. If set to true, the provided mBluetoothInfo.mDeviceName or mBluetoothInfo.mDeviceAddress properties are ignored and scanning is always done. If set to false, then scanning is skipped and the provided mBluetoothInfo.Address or mBluetoothInfo.Name properties are directly used for pairing.\n\n**Type:**\n\njava.lang.Boolean\n\n###bluetoothInfo\nSpecifies the Bluetooth related information. The settings provided through this object are used for pairing/unpairing.\n\n**Type:**\n\ncom.symbol.emdk.scanandpair.[ScanAndPairConfig.bluetoothInfo](#api-ScanAndPairConfig-BluetoothInfo)\n\n###notificationType\nSpecifies the notification related information. When using the ScanAndPair() and ScanAndUnPair() methods, notifications can be provided to the user to indicate the progress of the operation. This object provides access to the settings for the notifications. The default value for NotificationType is BEEPER. For more information on notifications refer to the [ScanAndPairConfig.NotificationType](#api-ScanAndPairConfig?ScanAndPairConfig.NotificationType) class.\n\n**Type:**\n\ncom.symbol.emdk.scanandpair.[ScanAndPairConfig.notificationType](#api-ScanAndPairConfig?ScanAndPairConfig.NotificationType)\n\n###scanInfo\nSpecifies the scanning related information. The settings provided through this object are used for scanning the barcode. It also exposes the scanned data. NOTE: The maximum allowed length of the barcode that can be scanned is 123 characters.\n\n**Type:**\n\ncom.symbol.emdk.scanandpair.[ScanAndPairConfig.scanInfo](#api-ScanAndPairConfig-ScanInfo)\n\n\n##Public Methods\n###resetToDefaults()\nResets all config to default values.\n\n**Returns:**\n\nvoid\n\n##Public Enums\n###ScanAndPairConfig.DeviceIdentifier\nThis enum Provides the list of DeviceIdentifier types.\n\n**Values:**\n\n**INTERNAL_CAMERA1** - Use first available camera.\n\n**INTERNAL_IMAGER1** - Use first available imager.\n\n**INTERNAL_LASER1** - Use first available laser scanner.\n\n**BLUETOOTH_IMAGER1** - Use first available Bluetooth imager. Note: This requires pairing the Bluetooth Imager before calling the ScanAndPair or ScanAndUnPair methods.\n\n**DEFAULT** - Use default scanner. Depending on the mobile device, the first available scanner can be laser, imager or camera.\n \n###ScanAndPairConfig.NotificationType\nThis enum is used by the ScanAndPairTool class. When using PowerTools, notifications can be provided to the user to indicate the progress of the different PowerTool methods. This enum provides notification related information during scanning process.\n\n**Values:**\n\n**BEEPER** - Beeper notification. Raises pre-defined beep sequences. This will give the user an audible alert when specific operations are performed.\n\n**NONE** - Disable notification. Do not raise notification for any type of operations.\n\n###ScanAndPairConfig.ScanDataType\nProvides the different types of barcode data to be scanned.\n\n**Values:**\n\n**MAC_ADDRESS** - Scan data is a Bluetooth MAC address\n\n**DEVICE_NAME** - Scan data is a Bluetooth device name.\n\n**UNSPECIFIED** - Scan data type is unknown. The ScanAndPair library will automatically attempt to determine if it is a valid address. If not, it will be considered as a Bluetooth name.\n\n###ScanAndPairConfig.TriggerType\nProvides the list of supported trigger types.\n\n**Values:**\n\n**HARD** - Hardware trigger needs to be manually pressed to turn ON the scanner\n\n**SOFT** - Scanner is turned ON automatically and no need to press any triggers"},{"key":"api-ScanAndPairException","name":"ScanAndPairException","md":"#ScanAndPairException\n\nThe methods of ScanAndPair object throws ScanAndPairException when an error occurs. The error could be due to:\n\n1. Client using the API incorrectly OR\n2. Because an unexpected error occurred\n\n##Public Methods\n###getResult()\nReturns the ScanAndPairResults enum value.\n\n**Returns:**\n\ncom.symbol.emdk.scanandpairmanager.[ScanAndPairManager.ScanAndPairResults](#api-ScanAndPairManager?ScanAndPairResults)"},{"key":"api-ScanAndPairManager-StatusListener","name":"ScanAndPairManager.StatusListener","md":"#ScanAndPairManager.StatusListener\n\nAn interface for notifying client applications to notify scan and pair or unpair events.\n\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements StatusListener\n    {\n       .. .. .. \n    }\n\n\n\n##Public Methods\n###onStatus(StatusData statusData)\nThis is the callback method upon scan and pair or unpair status event occurs.\n\n**Parameters:**\n\n**statusData** - [StatusData](#api-ScanAndPairStatusData) object.\n\n**Returns:**\n\nvoid"},{"key":"api-ScanAndPairManager","name":"ScanAndPairManager","md":"#ScanAndPairManager\n\nThe ScanAndPairManager provides interfaces, classes and methods to scan a Bluetooth barcode (name or address) of a remote Bluetooth device and pair/unpair with the remote Bluetooth device.\n\n\n##Public Fields\n###config\nThe [ScanAndPairConfig](#api-ScanAndPairConfig) provides a way to configure the settings to use it in scanAndPair() or scanAndUnpair() methods. These settings must be done before calling the scanAndPair() or scanAndUnpair() methods and do not modify the this while the method is processing its job.\n\n**Type:**\n\ncom.symbol.emdk.scanandpair.[ScanAndPairConfig](#api-ScanAndPairConfig)\n\n\n##Public Methods\n###isPreviousCommandPending()\nThis method provides information if any of the previous request is pending. If this method returns true, the client application must wait for the current complete before calling the issuing the next request.\n\n**Returns:**\n\nBoolean value\n\n###scanAndPair(java.lang.String pin)\nThis is an asynchronous method. The status of the scanAndPair() method will be returned if the callback is registered. If the always scan is enabled in the configuration, this method scans a barcode to get the Bluetooth address or name of a remote device, and pairs with that remote device. If a Bluetooth address is scanned, the remote device is paired without performing a discovery. If a Bluetooth name is scanned, then a discovery is done to find the address of the device and then the pairing is done. The provided authentication PIN is used for pairing. The maximum allowed length for the authentication PIN is 15 characters.\n\n**Parameters:**\n\n**pin** - Pin required to pair with the Bluetooth device.\n\n**Returns:**\n\n[ScanAndPairResults](#api-ScanAndPairManager?ScanAndPairResults) - Returns success if the scan and pair request is successfully initiated.\n\n###scanAndUnpair()\nThis is an asynchronous method. The status of the scanAndUnpair() method will be returned if the callback is registered. If the always scan is enabled in the configuration, this method scans a barcode to get the Bluetooth address or name of a remote device, and pairs with that remote device. If a Bluetooth address was scanned for pairing during scanAndPair() calls, then the same address can be scanned for unpairing during the ScanAndUnPair call.\n\n**Returns:**\n\n[ScanAndPairResults](#api-ScanAndPairManager?ScanAndPairResults) - Returns success if the scan and unpair request is successfully initiated.\n\n###getStatus()\nThis method provides an option to get the current or recent status of scanAndPair or scanAndUnpair calls.\n\n**Returns:**\n[StatusData](#api-StatusData) object.\n\n###addStatusListener(ScanAndPairManager.StatusListener listener) throws com.symbol.emdk.scanandpair.ScanAndPairException\nThe client can register to get status notification via callbacks.\n\n**Parameters:**\n\nlistener\n\n**Returns:**\n\nvoid\n\n**Throws:**\ncom.symbol.emdk.scanandpair.ScanAndPairException\n\n###removeStatusListener(ScanAndPairManager.StatusListener listener) throws com.symbol.emdk.scanandpair.ScanAndPairException\nThe client can un-register to get status notification via callbacks.\n\n**Parameters:**\n\nlistener\n\n**Returns:**\n\nvoid\n\n**Throws:**\ncom.symbol.emdk.scanandpair.ScanAndPairException\n\n\n\n##Public Enums\n###ScanAndPairResults\nProvides list of result codes for ScanAndPair class.\n\n**Values:**\n\n**SUCCESS** - Success\n\n**FAILURE** - Operation is failed.\n\n**INVALID_OBJECT** - The object is not valid.\n\n**INVALID_CONFIG** - Invalid configuration\n\n**INVALID_BLUETOOTH_DEVICE_INFO** - Invalid Bluetooth address or name provided\n\n**INVALID_PAIRING_PIN** - Invalid Pin entered for Bluetooth pairing\n\n**BLUETOOTH_NOT_ENABLED** - Failure in Bluetooth initialization\n\n**BLUETOOTH_DEVICE_DISCOVERY_FAILED** - Unable to discover Bluetooth device\n\n**BLUETOOTH_SERVICE_DISCOVERY_FAILED** - Unable to perform Bluetooth service discovery\n\n**DEVICE_NOT_PAIRED** - Trying to unpair a Bluetooth device which is not yet paired.\n\n**DEVICE_ALREADY_PAIRED** - Trying to pair a Bluetooth device which is already paired.\n\n**DEVICE_PAIRING_FAILED** - Failure in Bluetooth pairing\n\n**DEVICE_UNPAIRING_FAILED** - Failure in Bluetooth unpairing\n\n**PAIRING_TIMEDOUT** - Bluetooth pairing timed out\n\n**SCANNER_INIT_FAILURE** - Error in opening scanner\n\n**SCANNER_UNINT_FAILED** - Error in closing scanner\n\n**SCANNER_NOT_SUPPORTED** - Scanner not supported or not available\n\n**SCANNER_IN_USE** - Scanner is busy in performing some other operation\n\n**INVALID_SCANNED_DATA** - Invalid scanned data.\n\n**SCANNER_READ_FAILED** - Error in scanning barcode\n\n**PREVIOUS_COMMAND_PENDING** - Previously requested command is in progress, wait for it to complete.\n\n**INPROGRESS** - The operation requested is in progress."},{"key":"api-ScanAndPairStatusData","name":"ScanAndPair.StatusData","md":"#ScanAndPair.StatusData\n\nThis class provides the Status detail of ScanAndPair.\n\n\n##Constructor\n###StatusData()\n\n\n##Public Methods\n###getState()\nState of the scanAndPair or scanAndUnpair method.\n\n**Returns:**\n\ncom.symbol.emdk.scanandpair.[StatusData.ScanAndPairStates](#api-ScanAndPairStatusData?StatusData.ScanAndPairStates)\n\n###getResult()\nWhen the state is ERROR, this method can be used to find out the exact error information.\n\n**Returns:**\n\n[ScanAndPairResults](#api-ScanAndPairManager?ScanAndPairResults)\n\n\n##Public Enums\n###StatusData.ScanAndPairStates\nDefines the different states of the scan and pair/unpair.\n\n**Values:**\n\n**WAITING** - Scanner is waiting for hard trigger press\n\n**SCANNING** - Scanner beam is on and it is acquiring data\n\n**DISCOVERING** - Discovering the Bluetooth device to be paired\n\n**PAIRED** - The Bluetooth device is paired.\n\n**UNPAIRED** - The Bluetooth device is unpaired\n\n**ERROR** - Error occurred during the scan and pair or unpair. Call StatusData.getResult() for error information\n\n**UNDEFINED** - Undefined. This is the initial state"},{"key":"api-ScanDataCollection","name":"ScanDataCollection","md":"#ScanDataCollection\n\nThe ScanDataCollection object gives scanning result and the collection of [ScanData](#api-Collection-ScanData).\n\n**Example Usage:**\n\n\t:::java\n\tOverride:\n    public void onData(ScanDataCollection scanDataCollection)\n    { \n      if(scanDataCollection != null && scanDataCollection.getResult() == SCANNER_RESULTS.SUCCESS) { \n       ArrayList<ScanData> scanData = scanDataCollection.getScanData(); \n       for(ScanData data : scanData ) { \n        String barcodeDate = data.getData(); \n        LABEL_TYPE labelType = data.getLabelType(); \n        String timeStamp = scanData.getTimeStamp(); \n       } \n      }  \n    }\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getFriendlyName()\nReturns the friendly name of scanner for which the data is returned.\n\n**Returns:**\n\njava.lang.String - Returns scanner index to the supported devices list.\n\n###getResult()\nThis method used to obtain the scanned result.\n\n**Example Usage:**\n\n\t:::java\n\tScannerResults results = scanDataCollection.getResult();\n\n**Returns:**\n\n[ScannerResults](#api-BarcodeManager?BarcodeManager.ScannerResults) object\n\n###getScanData()\nThis method is used to obtain the scanned data list.\n\n**Example Usage:**\n\n\t:::java\n\tArrayList<ScanData> scanDataList = scanDataCollection.getScanData();\n\n**Returns:**\n\njava.util.ArrayList&lt;com.symbol.emdk.barcode.[ScanDataCollection.ScanData](#api-Collection-ScanData)&gt; - Returns the collection of scan data.\n\n##Public Enums\n###ScanDataCollection.LabelType\nList of label types of the scanner data.\n\n**Example Usage:**\n\n\t:::java\n\tLABEL_TYPE.CODE39\n\n**Values:**\n\n**AUSPOSTAL** - The AUSTRALIAN POSTAL symbology.\n\n**AZTEC** - The AZTEC symbology\n\n**BOOKLAND** - The BOOKLAND EAN symbology.\n\n**CANPOSTAL** - The CANADIAN POSTAL symbology.\n\n**CHINESE_2OF5** - The CHINESE_2OF5 symbology.\n\n**CODABAR** - The CODABAR symbology.\n\n**CODE11** - The CODE-11 symbology.\n\n**CODE128** - The CODE-128 symbology.\n\n**CODE32** - The CODE-32 symbology.\n\n**CODE39** - The CODE-39 symbology.\n\n**CODE93** - The CODE-93 symbology.\n\n**COMPOSITE_AB** - The COMPOSITE AB symbology.\n\n**COMPOSITE_C** - The COMPOSITE C symbology.\n\n**COUPON** - The COUPON CODE symbology.\n\n**D2OF5** - The Discrete 2 of 5 symbology.\n\n**DATAMATRIX** - The DATAMATRIX symbology.\n\n**DUTCHPOSTAL** - The DUTCH POSTAL symbology.\n\n**DATABAR_COUPON** - The databar coupon symbology.\n\n**EAN128** - The EAN-128 symbology.\n\n**EAN13** - The EAN-13 symbology.\n\n**EAN8** - The EAN-8 symbology.\n\n**GS1_DATABAR** - The GS1_DATABAR symbology.\n\n**GS1_DATABAR_EXP** - The GS1_DATABAR_EXP symbology.\n\n**GS1_DATABAR_LIM** - The GS1_DATABAR_LIM symbology.\n\n**HANXIN*** - The HANXIN symbology.\n\n**I2OF5** - The Interleaved 2 of 5 symbology.\n\n**IATA2OF5** - The IATA 2 of 5 symbology.\n\n**ISBT128** - The ISBT 128 symbology.\n\n**JAPPOSTAL** - The JAPANESE POSTAL symbology.\n\n**KOREAN_3OF5** - The KOREAN 3OF5 symbology.\n\n**MAILMARK** - The MAILMARK symbology.\n\n**MATRIX_2OF5** - The MATRIX 2OF5 symbology.\n\n**MAXICODE** - The MAXICODE symbology.\n\n**MICROPDF** - The MICRO PDF symbology.\n\n**MICROQR** - The MICRO QR symbology.\n\n**MSI** - The MSI symbology.\n\n**OCR** - The OCR symbology.\n\n**PDF417** - The PDF 417 symbology.\n\n**QRCODE** - The QRCODE symbology.\n\n**SIGNATURE** - The Signature symbology.\n\n**TLC39** - The TCIF Linked CODE 39 symbology.\n\n**TRIOPTIC39** - The TRIOPTIC 3 of 9 symbology.\n\n**UKPOSTAL** - The UK POSTAL symbology.\n\n**UPCA** - The UPC-A symbology.\n\n**UPCE0** - The UPC-E0 symbology.\n\n**UPCE1** - The UPC-E1 symbology.\n\n**US4STATE** - The US4STATE symbology.\n\n**US4STATE_FICS** - The US4STATE_FICS symbology\n\n**USPLANET** - The US PLANET symbology.\n\n**USPOSTNET** - The US POSTNET symbology.\n\n**WEBCODE** - The Scanlet WEBCODE symbology.\n\n**UNDEFINED** - The Symbology is unknown or not defined.\n\n\n"},{"key":"api-Scanner-DataListener","name":"Scanner.DataListener","md":"#Scanner.DataListener\n\nAn interface for notifying client applications when the scan data is available.  \n\n**Example Usage:**\n\n    :::java\n    public class MainActivity extends Activity implements DataListener\n     .. \n     .. \n     ..\n\n##Public Methods\n###onData(ScanDataCollection scanDataCollection)\nThis is the callback method upon data availability.\n\n**Parameters:**\n\n**scanDataCollection** - Collection of scan data.\n\n**Returns:**\n\nvoid\n"},{"key":"api-Scanner-StatusListener","name":"Scanner.StatusListener","md":"#Scanner.StatusListener\n\nAn interface for notifying client applications to notify scan events.  \n\n**Example Usage:**\n\n    :::java\n    public class MainActivity extends Activity implements StatusListener\n     .. \n     .. \n     ..\n\n##Public Methods\n###onStatus(StatusData statusData)\nThis is the callback method upon scan status event occurs.\n\n**Parameters:**\n\n**statusData** - StatusData object.\n\n**Returns:**\n\nvoid\n"},{"key":"api-Scanner","name":"Scanner","md":"#Scanner\n\nScanner class will represent and provides access to the physical scanner device.  \n\n**Example Usage:**\n\n\t:::java\n\tScanner scanner = barcodeManager.getDevice(DeviceIdentifer.DEFAULT); \n    scanner.enable(); \n    scanner.addDataListener(this); \n    scanner.read(); \n    scanner.cancelRead(); \n    scanner.disable();\n\n**Version:**\n\n1.0\n\n##Public Methods\n###addDataListener(Scanner.DataListener listener)\nThe client can register to get data notification via callbacks.\n\n**Parameters:**\n\n**listener** - The DataListener callabck object.\n\n**Returns:**\n\nvoid\n\n###addStatusListener(Scanner.StatusListener listener)\nThe client can register to get status notification via callbacks.\n\n**Parameters:**\n\n**listener**\n\n**Returns:**\n\nvoid\n\n###cancelRead()\nThis Cancels any pending asynchronous read() calls.\n\n**Example Usage:**\n\n\t:::java\n\tscanner.cancelRead();\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[ScannerException](#api-ScannerException) - The exception will thrown if error occurs during the cancelRead request.\n\n###disable()\nDisables the scanner hardware. Any pending scanned data will be lost. This method releases the scanner hardware resources for other application to use. You must call this as soon as you're done with the scanning.\n\n**Example Usage:**\n\n    :::java\n    scanner.disable();\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[ScannerException](#api-ScannerException) - The exception will thrown if the scanner disable fails.\n\n###enable()\nEnables the scanner hardware. This method does not make the scanner to scan or turn on the laser. If the same of scanner is enabled by other applications, this will throw ScannerExceptions. You must call disable() when you are done the scanning, otherwise it will remain locked and be unavailable to other applications. \n\n**Example Usage:**\n\n    :::java\n    scanner.enable();\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[ScannerException](#api-ScannerException) -  The exception will thrown if the scanner enable fails.\n\n###getConfig()\nGets the current configuration settings for this scanner device. If modifications are made to the returned ScannerConfig object, the Scanner.setConfig(ScannerConfig) must be called to take effect. Scanner must be enabled before calling getConfig(). \n\n**Example Usage:**\n\n    :::java\n    scanner.enable(); \n    ScannerConfig config = scanner.getConfig();\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[ScannerConfig](#api-ScannerConfig) - scannerConfig The valid scanner configuration object will be returned on successful get.\n\n**Throws:**\n\n[ScannerException](#api-ScannerException)\n\n###getInterfaceConfig() throws ScannerException\n\n**Returns:**\n\n[InterfaceConfig](#api-BarcodeInterfaceConfig) object.\n\n**Throws:**\n\n[ScannerException](#api-ScannerException)\n\n###getScannerInfo()\nReturns information about the scanner device. \n\n**Returns:**\n\ncom.symbol.emdk.barcode.[ScannerInfo](#api-ScannerInfo) - Returns the ScannerInfo object.\n\n###isEnabled() \n\n**Returns:**\n\nboolean\n\n###isReleased()\nReturns scanner object state.\n\n**Returns:**\n\nboolean - boolean Object state.\n\n###isReadPending()\nAnother read() cannot be submitted while a read is pending.\n\n**Returns:**\n\nboolean - Returns true if a read is pending.\n\n###read()\nStarts an asynchronous Scan. The method will not turn on the scanner. It will, however, put the scanner in a state in which the scanner can be turned ON either by pressing a hardware trigger or can be turned ON automatically. This is determined by the Scanner.triggerType. The data notification must be registered in order to scan and get the Scan Data. The read request can be cancelled by issuing a cancelRead.\n\nIf a read() is submitted while another read is pending, the method call will fail. It is recommended to  check whether a read is pending by calling isReadPending() before submitting a read(). A read() can also be submitted from within onData and onStatus events. If called within onStatus, it should be called only when IDLE status is received.  If called within onData, then checking for isReadPending() is recommended.\n\n**Example Usage:**\n\n    :::java\n    scanner.read();\n\n**Throws:**\n\n[ScannerException](#api-ScannerException) - The exception will thrown if error occurs during the read request.\n\n**Returns:**\n\nvoid\n\n###removeDataListener(Scanner.DataListener listener)\nThe client can un-register to get data notification via callbacks.\n\n**Parameters:**\n\n**listener**\n\n**Returns:**\n\nvoid\n\n###removeStatusListener(Scanner.StatusListener listener)\nThe client can un-register to get status notification via callbacks.\n\n**Parameters:**\n\n**listener**\n\n**Returns:**\n\nvoid\n\n###setConfig(ScannerConfig scannerConfig)\nChanges the settings for this scanner device. The unsupported parameters will be ignored. This method skips the unsupported parameters and continues with setting the supported values.\n\n**Example Usage:**\n\n    :::java\n    ScannerConfig scannerConfig = scanner.getConfig();\n    scannerConfig.scanParams.decodeLEDTime = 10; \n    scanner.setConfig(scannerConfig);\n\n**Parameters:**\n\n**scannerConfig** - The Parameters to use for this scanner device.\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[ScannerException](#api-ScannerException) - Exception will be throw if any error occurs while setting the parameters.\n\n###setInterfaceConfig(InterfaceConfig interfaceConfig) throws ScannerException\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[ScannerException](#api-ScannerException)\n  \n##Public Fields\n###triggerType\nSpecifies the trigger type for the scanner. It is set to HARD by default.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[Scanner.TriggerType](#api-Scanner?Scanner.TriggerType)\n\n##Public Enums\n###Scanner.TriggerType\nList of supported trigger type\n\n**Values:**\n\n**HARD** - Hard trigger. When this mode is set, the user has to manually press the trigger on the device after issuing the read call.\n\n**SOFT_ONCE** - Soft trigger is used only once for a pending read or for the next issued read. When this mode is set, the scan beam will come up automatically without having to press the trigger on the device after issuing the read call.\n\n**SOFT_ALWAYS** - Soft trigger is used for all pending scans and for future reads issued. When this mode is set, the scan beam will come up automatically without having to press the trigger on the device.\n"},{"key":"api-ScannerConfig-DecoderParams-AustralianPostal","name":"ScannerConfig.DecoderParams.AustralianPostal","md":"#ScannerConfig.DecoderParams.AustralianPostal\n\nThe AustralianPostal class provides access to parameters that are available for the AustralianPostal decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = australianPostal.enabled;\n\n**Type:**\n\nboolean\n"},{"key":"api-ScannerConfig-DecoderParams-Aztec","name":"ScannerConfig.DecoderParams.Aztec","md":"#ScannerConfig.DecoderParams.Aztec\n\nThe Aztec class provides access to parameters that are available for the Aztec decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = aztec.enabled;\n\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-BaseDecoder","name":"ScannerConfig.DecoderParams.BaseDecoder","md":"#ScannerConfig.DecoderParams.BaseDecoder\n\nThe BaseDecoder class is the parent decoder to all decoders and is inherited by all decoders.\n\n##Constructors\n###BaseDecoder()\n\n##Public Fields\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Type:**\n\nboolean\n"},{"key":"api-ScannerConfig-DecoderParams-CanadianPostal","name":"ScannerConfig.DecoderParams.CanadianPostal","md":"#ScannerConfig.DecoderParams.CanadianPostal\n\nThe CanadianPostal class provides access to parameters that are available for the CanadianPostal decoder.\n\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = canadianPostal.enabled;\n\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-Chinese2of5","name":"ScannerConfig.DecoderParams.Chinese2of5","md":"#ScannerConfig.DecoderParams.Chinese2of5\n\nThe Chinese2of5 class provides access to parameters that are available for the Chinese2of5 decoder.\n\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = chinese2of5.enabled;\n\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-CodaBar","name":"ScannerConfig.DecoderParams.CodaBar","md":"#ScannerConfig.DecoderParams.CodaBar\n\nThe CodaBar class provides access to parameters that are available for the CodaBar decoder.\n\n##Public Fields\n\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = codaBar.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###clsiEditing\nEnable this parameter to strip the start and stop characters and insert a space after the first, fifth, and tenth characters of a 14-character Codabar symbol. Enable this feature if the host system requires this data format. \n\n**Example Usage:**\n\n    :::java\n    codabar.clsi_editing = true;\n\n**Type:**\n\nboolean\n\n###length1\nUse to set decode lengths. The supported range is 0 to 55. \n\n**Example Usage:**\n\n    :::java\n    codabar.length1 = 6;\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths. The supported range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    codabar.length2 = 55;\n\n**Type:**\n\nint\n\n###notisEditing\nEnable this parameter to strip the start and stop characters from a decoded Codabar symbol. Enable this feature if the host system requires this data format.\n\n**Example Usage:**\n\n    :::java\n    codabar.notis_editing = true; \n\n**Type:**\n\nboolean\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    codabar.redundancy = true;\n\n**Type:**\n\nboolean\n"},{"key":"api-ScannerConfig-DecoderParams-Code11","name":"ScannerConfig.DecoderParams.Code11","md":"#ScannerConfig.DecoderParams.Code11\n\nThe Code11 class provides access to parameters that are available for the Code11 decoder.\n\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = code11.enabled;\n\n\n**Type:**\n\nboolean\n\n###length1\nUse to set decode length. The supported range is 0 to 55. \n\n**Example Usage:**\n\n    :::java\n    code11.length1 = 4;\n\n**Type:**\n\nint\n\n###length2\nUse to set decode length. The supported range is 0 to 55. \n\n**Example Usage:**\n\n    :::java\n    code11.length2 = 55;\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    code11.redundancy = true;\n\n**Type:**\n\nboolean\n\n###reportCheckDigit\nTransmit Code 11 data with or without the check digit.\n\n**Example Usage:**\n\n    :::java\n    code11.reportCheckDigit = false; \n\n**Type:**\n\nboolean\n\n###verifyCheckDigit\nCheck the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code. Use enum [ScannerConfig.VerifyCheckDigit](#api-ScannerConfig?ScannerConfig.VerifyCheckDigit).\n\n**Example Usage:**\n\n    :::java\n    code11.verifyCheckDigit = VerifyCheckDigit.NO;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.VerifyCheckDigit](#api-ScannerConfig?ScannerConfig.VerifyCheckDigit)\n"},{"key":"api-ScannerConfig-DecoderParams-Code128","name":"ScannerConfig.DecoderParams.Code128","md":"#ScannerConfig.DecoderParams.Code128\n\nThe Code128 class provides access to parameters that are available for the Code128 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = code128.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###checkIsbtTable\nThe ISBT specification includes a table that lists several types of ISBT bar codes that are commonly used in pairs. If ISBT128 Concat Mode is set, enable Check ISBT T able to concatenate only those pairs found in this table. Other types of ISBT codes are not concatenated. \n\n**Example Usage:**\n\n    :::java\n    code128.checkIsbtTable = true;\n\n**Type:**\n\nboolean\n\n###enableEan128\nFlag to enable EAN128 subtype. \n\n**Example Usage:**\n\n    :::java\n    code128.enableEan128 = true;\n\n**Type:**\n\nboolean\n\n###enableIsbt128\nFlag to enable ISBT128.\n\n**Example Usage:**\n\n    :::java\n    code128.enableIsbt128 = true;\n\n**Type:**\n\nboolean\n\n###enablePlain\nFlag to enable other sub types besides GS1-128 and ISBT-128. \n\n**Example Usage:**\n\n    :::java\n    code128.enablePlain = false; \n\n**Type:**\n\nboolean\n\n###isbt128ConcatMode\nSelect an option for concatenating pairs of ISBT code types. Use enum [ScannerConfig.Isbt128ContactMode](#api-ScannerConfig?ScannerConfig.Isbt128ContactMode).\n\n**Example Usage:**\n\n    :::java\n    code128.isbt128ConcatMode = Isbt128ContactMode.NONE;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.Isbt128ContactMode](#api-ScannerConfig?ScannerConfig.Isbt128ContactMode)\n\n###length1\nUse to set decode lengths. The supported range is 0 to 55. \n\n**Example Usage:**\n\n    :::java\n    int length1 = code128.length1;\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths. The supported range is 0 to 55.  \n\n**Example Usage:**\n\n    :::java\n    int length2 = code128.length2;\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.  \n\n**Example Usage:**\n\n    :::java\n    code128.redundancy = true;\n\n**Type:**\n\nboolean\n\n###securityLevel\nThe scanner of fers four levels of decode security for Code 128 bar codes. Select increasing levels of security for decreasing levels of bar code quality. There is an inverse relationship between security and scanner aggressiveness, so choose only that level of security necessary for any given application. Use enum [ScannerConfig.SecurityLevel](#api-ScannerConfig?ScannerConfig.SecurityLevel).  \n\n**Example Usage:**\n\n    :::java\n    code128.securityLevel = SecurityLevel.LEVEL_0;\n\n**Type:**\n\ncom.symbol.emdk.barcode.ScannerConfig.SecurityLevel"},{"key":"api-ScannerConfig-DecoderParams-Code39","name":"ScannerConfig.DecoderParams.Code39","md":"#ScannerConfig.DecoderParams.Code39\n\nThe Code39 class provides access to parameters that are available for the Code39 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = code39.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###convertToCode32\nCode 32 is a variant of Code 39 used by the Italian pharmaceutical industry. \n\n**Example Usage:**\n\n    :::java\n    code39.convertToCode32 = true;\n\n**Type:**\n\nboolean\n\n###fullAscii\nCode 39 Full ASCII is a variant of Code 39 that pairs characters to encode the full ASCII character set. \n\n**Example Usage:**\n\n    :::java\n    code39.fullAscii = true;\n\n**Type:**\n\nboolean\n\n###length1\nUse to set decode lengths. The valid range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    code39.length1 = 0;\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths. The valid range is 0 to 55. \n\n**Example Usage:**\n\n    :::java\n    code39.length2 = 55; \n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    code39.redundancy = true;\n\n**Type:**\n\nboolean\n\n###reportCheckDigit\nTransmit Code 39 data with or without the check digit. \n\n**Example Usage:**\n\n    :::java\n    code39.reportCheckDigit = true;\n\n**Type:**\n\nboolean\n\n###reportCode32Prefix\nScan the appropriate bar code to enable or disable adding the prefix character \"A\" to all Code 32 bar codes.  \n\n**Example Usage:**\n\n    :::java\n    code39.reportCode32Prefix = true;\n\n**Type:**\n\nboolean\n\n###securityLevel\nOptions: Security level 0 , Security Level 1 , Security Level 2 and Security Level 3. Use enum [ScannerConfig.SecurityLevel](#api-ScannerConfig?ScannerConfig.SecurityLevel).  \n\n**Example Usage:**\n\n    :::java\n    code39.securityLevel = SecurityLevel.LEVEL_1;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.SecurityLevel](#api-ScannerConfig?ScannerConfig.SecurityLevel)\n\n###verifyCheckDigit\nEnable this feature to check the integrity of all Code 39 symbols to verify that the data complies with a specified check digit algorithm. The digital scanner decodes only those Code 39 symbols that include a modulo 43 check digit. Enable this feature only if the Code 39 symbols contain a modulo 43 check digit.  \n\n**Example Usage:**\n\n    :::java\n    code39.verifyCheckDigit = false;\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-Code93","name":"ScannerConfig.DecoderParams.Code93","md":"#ScannerConfig.DecoderParams.Code93\n\nThe Code93 class provides access to parameters that are available for the Code93 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = code93.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###length1\nUse to set decode lengths. The valid range is 0 to 55. \n\n**Example Usage:**\n\n    :::java\n    int length1 = 0;\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths. The valid range is 0 to 55. \n\n**Example Usage:**\n\n    :::java\n    code93.length2 = 55;\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    code93.redundancy = true;\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-CompositeAB","name":"ScannerConfig.DecoderParams.CompositeAB","md":"#ScannerConfig.DecoderParams.CompositeAB\n\nThe CompositeAB class provides access to parameters that are available for the CompositeAB decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = compositeAB.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###uccLinkMode\nGets and Sets UCC Link Mode using [ScannerConfig.UccLinkMode](#api-ScannerConfig?ScannerConfig.UccLinkMode) enum; \n\n**Example Usage:**\n\n    :::java\n    compositeAB.uccLinkMode = UccLinkMode.ALWAYS_LINKED;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.UccLinkMode](#api-ScannerConfig?ScannerConfig.UccLinkMode)"},{"key":"api-ScannerConfig-DecoderParams-CompositeC","name":"ScannerConfig.DecoderParams.CompositeC","md":"#ScannerConfig.DecoderParams.CompositeC\n\nThe CompositeC class provides access to parameters that are available for the CompositeC decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = compositeC.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-D2of5","name":"ScannerConfig.DecoderParams.D2of5","md":"#ScannerConfig.DecoderParams.D2of5\n\nThe D2OF5 class provides access to parameters that are available for the D2OF5 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = d2of5.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###length1\nUsed to set decode lengths. The valid range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    d2of5.length1 = 0;\n\n**Type:**\n\nint\n\n###length2\nUsed to set decode lengths. The valid range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    d2of5.length2 = 14;\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    d2of5.redundancy = true;\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-DataMatrix","name":"ScannerConfig.DecoderParams.DataMatrix","md":"#ScannerConfig.DecoderParams.DataMatrix\n\nThe DataMatrix class provides access to parameters that are available for the DataMatrix decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = dataMatrix.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-DutchPostal","name":"ScannerConfig.DecoderParams.DutchPostal","md":"#ScannerConfig.DecoderParams.DutchPostal\n\nThe DutchPostal class provides access to parameters that are available for the DutchPostal decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = dutchPostal.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Ean13","name":"ScannerConfig.DecoderParams.Ean13","md":"#ScannerConfig.DecoderParams.Ean13\n\nThe Ean13 class provides access to parameters that are available for the Ean13 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = ean13.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Ean8","name":"ScannerConfig.DecoderParams.Ean8","md":"#ScannerConfig.DecoderParams.Ean8\n\nThe Ean8 class provides access to parameters that are available for the Ean8 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = ean8.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Gs1Databar","name":"ScannerConfig.DecoderParams.Gs1Databar","md":"#ScannerConfig.DecoderParams.Gs1Databar\n\nThe Gs1Databar class provides access to parameters that are available for the GS1 Databar decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = gs1DataBar.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Gs1DatabarExp","name":"ScannerConfig.DecoderParams.Gs1DatabarExp","md":"#ScannerConfig.DecoderParams.Gs1DatabarExp\n\nThe Gs1DatabarExp class provides access to parameters that are available for the GS1 Databar Exp decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = gs1DataBarExp.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Gs1DatabarLim","name":"ScannerConfig.DecoderParams.Gs1DatabarLim","md":"#ScannerConfig.DecoderParams.Gs1DatabarLim\n\nThe Gs1DatabarLim class provides access to parameters that are available for the GS1 Databar Lim decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = gs1DataBarLim.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-HanXin","name":"ScannerConfig.DecoderParams.HanXin","md":"#ScannerConfig.DecoderParams.HanXin\n\nThe HanXin class provides access to parameters that are available for the HanXin decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = haxXin.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###hanXinInverse\nCheck the inverse of the HanXin decoder code. Use enum [ScannerConfig.HanXinInverse](#api-ScannerConfig?ScannerConfig.HanXinInverse).\n\n**Example Usage:**\n\n    :::java\n    hanXin.hanXinInverse = HanXinInverse.DISABLED;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.HanXinInverse](#api-ScannerConfig?ScannerConfig.HanXinInverse)\n\n\n"},{"key":"api-ScannerConfig-DecoderParams-I2of5","name":"ScannerConfig.DecoderParams.I2of5","md":"#ScannerConfig.DecoderParams.I2of5\n\nThe I2of5 class provides access to parameters that are available for the I2of5 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = i2of5.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###convertToEan13\nConvert 14-character Interleaved 2 of 5 bar codes to EAN-13, and transmit as EAN-13. The Interleaved 2 of 5 bar code must be enabled and must have a leading zero and a valid EAN-13 check digit.\n\n**Example Usage:**\n\n    :::java\n    i2of5.convertToEan13 = true;\n\n**Type:**\n\nboolean\n\n###length1\nUse to set decode lengths. The valid range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    i2of5.length1 = 14;\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths. The valid range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    i2of5.length2 = 10;\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    i2of5.redundancy = true;\n\n**Type:**\n\nboolean\n\n###reportCheckDigit\nTransmit Interleaved 2 of 5 data with or without the check digit.\n\n**Example Usage:**\n\n    :::java\n    i2of5.reportCheckDigit = true;\n\n**Type:**\n\nboolean\n\n###securityLevel\nSpecifies security level Use enum [ScannerConfig.SecurityLevel](#api-ScannerConfig?ScannerConfig.SecurityLevel).\n\n**Example Usage:**\n\n    :::java\n    i2of5.securityLevel = SecurityLevel.LEVEL_1;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.SecurityLevel](#api-ScannerConfig?ScannerConfig.SecurityLevel)\n\n###verifyCheckDigit\nThe check digit type to verify. Use enum [ScannerConfig.CheckDigitType](#api-ScannerConfig?ScannerConfig.CheckDigitType).\n\n**Example Usage:**\n\n    :::java\n    i2of5.verifyCheckDigit = CHECK_DIGIT_TYPE.NO;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.CheckDigitType](#api-ScannerConfig?ScannerConfig.CheckDigitType)"},{"key":"api-ScannerConfig-DecoderParams-JapanesePostal","name":"ScannerConfig.DecoderParams.JapanesePostal","md":"#ScannerConfig.DecoderParams.JapanesePostal\n\nThe JapanesePostal class provides access to parameters that are available for the JapanesePostal decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = japanesePostal.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Korean3of5","name":"ScannerConfig.DecoderParams.Korean3of5","md":"#ScannerConfig.DecoderParams.Korean3of5\n\nThe Korean3of5 class provides access to parameters that are available for the Korean3of5 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = korean3of5.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-MailMark","name":"ScannerConfig.DecoderParams.MailMark","md":"#ScannerConfig.DecoderParams.MailMark\n\nThe MailMark class provides access to parameters that are available for the MailMark decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = mailMark.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Matrix2of5","name":"ScannerConfig.DecoderParams.Matrix2of5","md":"#ScannerConfig.DecoderParams.Matrix2of5\n\nThe Matrix2of5 class provides access to parameters that are available for the Matrix2of5 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = matirx2of5.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###length1\nUsed to set decode lengths. The valid range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    matrix2of5.length1 = 10;\n\n**Type:**\n\nint\n\n###length2\nUsed to set decode lengths. The valid range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    matrix2of5.length2 = 0;\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    matrix2of5.redundancy = false;\n\n**Type:**\n\nboolean\n\n###reportCheckDigit\nTransmit Matrix 2 of 5 data with or without the check digit.\n\n**Example Usage:**\n\n    :::java\n    matrix2of5.reportCheckDigit = true;\n\n**Type:**\n\nboolean\n\n###verifyCheckDigit\nEnable this feature to check the integrity of all Matrix 2 of 5 symbols to verify that the data complies with a specified check digit algorithm.\n\n**Example Usage:**\n\n    :::java\n    matrix2of5.verifyCheckDigit = true;\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-MaxiCode","name":"ScannerConfig.DecoderParams.MaxiCode","md":"#ScannerConfig.DecoderParams.MaxiCode\n\nThe MaxiCode class provides access to parameters that are available for the MaxiCode decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = maxiCode.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-MicroPdf","name":"ScannerConfig.DecoderParams.MicroPdf","md":"#ScannerConfig.DecoderParams.MicroPdf\n\nThe MicroPdf class provides access to parameters that are available for the MicroPdf decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = microPdf.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-MicroQr","name":"ScannerConfig.DecoderParams.MicroQr","md":"#ScannerConfig.DecoderParams.MicroQr\n\nThe MicroQr class provides access to parameters that are available for the MicroQr decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = microQr.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Msi","name":"ScannerConfig.DecoderParams.Msi","md":"#ScannerConfig.DecoderParams.Msi\n\nThe Msi class provides access to parameters that are available for the Msi decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = msi.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###checkDigitScheme\nTwo algorithms are possible for the verification of the second MSI check digit. Select the algorithm used to encode the check digit. Use enum [ScannerConfig.CheckDigitScheme](#api-ScannerConfig?ScannerConfig.CheckDigitScheme).\n\n**Example Usage:**\n\n    :::java\n    msi.check_digit_scheme = CheckDigitScheme.MOD_10_10;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.CheckDigitScheme](#api-ScannerConfig?ScannerConfig.CheckDigitScheme)\n\n###checkDigits\nWith MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional. Use enum [ScannerConfig.CheckDigit](#api-ScannerConfig?ScannerConfig.CheckDigit).\n\n**Example Usage:**\n\n    :::java\n    msi.checkDigits = CheckDigit.ONE;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.CheckDigit](#api-ScannerConfig?ScannerConfig.CheckDigit)\n\n###length1\nUse to set decode lengths. The range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    msi.length1 = 4;\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths. The range is 0 to 55.\n\n**Example Usage:**\n\n    :::java\n    msi.length2 = 55;\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    msi.redundancy = true;\n\n**Type:**\n\nboolean\n\n###reportCheckDigit\nTransmit MSI data with or without the check digit.\n\n**Example Usage:**\n\n    :::java\n    msi.reportCheckDigit = false;\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-Pdf417","name":"ScannerConfig.DecoderParams.Pdf417","md":"#ScannerConfig.DecoderParams.Pdf417\n\nThe Pdf417 class provides access to parameters that are available for the Pdf417 decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = pdf417.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-QrCode","name":"ScannerConfig.DecoderParams.QrCode","md":"#ScannerConfig.DecoderParams.QrCode\n\nThe QRCode class provides access to parameters that are available for the QRCode decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = qrCode.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Signature","name":"ScannerConfig.DecoderParams.Signature","md":"#ScannerConfig.DecoderParams.Signature\n\nThe Signature class provides access to parameters that are available for the Signature decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = signature.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Tlc39","name":"ScannerConfig.DecoderParams.Tlc39","md":"#ScannerConfig.DecoderParams.Tlc39\n\nThe Tlc39 class provides access to parameters that are available for the Tlc39 decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = tlc39.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-TriOptic39","name":"ScannerConfig.DecoderParams.TriOptic39","md":"#ScannerConfig.DecoderParams.TriOptic39\n\nThe TriOptic39 class provides access to parameters that are available for the TriOptic39 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = triOptic39.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###redundancy\nSets the reader to read the bar code twice before accepting data.\n\n**Example Usage:**\n\n    :::java\n    triOptic39.redundancy = true;\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-UkPostal","name":"ScannerConfig.DecoderParams.UkPostal","md":"#ScannerConfig.DecoderParams.UkPostal\n\nThe UkPostal class provides access to parameters that are available for the UkPostal decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = ukPostal.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###reportCheckDigit\nTransmit UK Postal data with or without the check digit.\n\n**Example Usage:**\n\n    :::java\n    ukPostal.reportCheckDigit = true;\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-Upca","name":"ScannerConfig.DecoderParams.Upca","md":"#ScannerConfig.DecoderParams.Upca\n\nThe Upca class provides access to parameters that are available for the Upca decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = upca.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###preamble\nControls the preamble applied to the bar code.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.Preamble](#api-ScannerConfig?ScannerConfig.Preamble)\n\n###reportCheckDigit\nFlag to enable reporting the bar code check digit.\n\n**Type:**\n\nboolean\n"},{"key":"api-ScannerConfig-DecoderParams-Upce0","name":"ScannerConfig.DecoderParams.Upce0","md":"#ScannerConfig.DecoderParams.Upce0\n\nThe Upce0 class provides access to parameters that are available for the Upce0 decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = upce0.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###convertToUpca\nFlag to enable conversion from UPCE0 to UPCA bar code. If this flag is set, the bar code is converted to UPCA and UPCA parameters are used.\n\n**Type:**\n\nboolean\n\n###preamble\nControls the preamble applied to the bar code.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.Preamble](#api-ScannerConfig?ScannerConfig.Preamble)\n\n###reportCheckDigit\nFlag to enable reporting the bar code check digit.\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-Upce1","name":"ScannerConfig.DecoderParams.Upce1","md":"#ScannerConfig.DecoderParams.Upce1\n\nThe Upce1 class provides access to parameters that are available for the Upce1 decoder.\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = upce1.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###convertToUpca\nFlag to enable conversion from UPCE1 to UPCA bar code. If this flag is set, the bar code is converted to UPCA and UPCA parameters are used.\n\n**Type:**\n\nboolean\n\n###preamble\nControls the preamble applied to the bar code.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.Preamble](#api-ScannerConfig?ScannerConfig.Preamble)\n\n###reportCheckDigit\nFlag to enable reporting the bar code check digit.\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-UpcEanParams","name":"ScannerConfig.DecoderParams.UpcEanParams","md":"#ScannerConfig.DecoderParams.UpcEanParams\n\nThe UPCEAN class provides access to parameters that are available for the UPC/EAN decoder.\n\n**Example Usage:**\n\n    :::java\n    config.upcEanParams.booklandCode = true;\n\n**Version:**\n\n3.0\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = upcEanParams.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###booklandCode\nFlag to enable Bookland code decoding.\n\n**Example Usage:**\n\n    :::java\n    upcEan.booklandCode = true;\n\n**Type:**\n\nboolean\n\n###booklandFormat\nSpecifies the bookland format to use. Use enum [ScannerConfig.BooklandFormat](#api-ScannerConfig?ScannerConfig.BooklandFormat).\n\n**Example Usage:**\n\n    :::java\n    upcEan.booklandFormat = BooklandFormat.ISBN_10;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.BooklandFormat](#api-ScannerConfig?ScannerConfig.BooklandFormat)\n\n###convertDataBarToUpcEan\nIf this is set it converts DataBar bar codes to UPC/EAN format. For this setting to work UPC/EAN symbologies must be enabled. A check in the checkbox indicates that the option is enabled.\n\n**Example Usage:**\n\n    :::java\n    upcEan.convertDataBarToUPCEAN = true;\n\n**Type:**\n\nboolean\n\n###couponCode\nEnables Coupon code decoding. Note that in order to successfully decode Coupon codes, all of the correct decoders must be enabled.\n\n**Example Usage:**\n\n    :::java\n    upcEan.couponCode = true;\n\n**Type:**\n\nboolean\n\n###couponReport\nUsed to differentiate between old coupon (UPC/EAN and Code128) and new GS1 DataBar Coupons. NOTE: There is an Interim GS1 DataBar Coupon (UPC A and the GS1 DataBar), which is meant for smooth transition of adaption from old coupon format to new coupon format. If an interim coupon is presented to the scanner, it will read old or new portion of it, depending on the report mode setting. Use enum [ScannerConfig.CouponReport](#api-ScannerConfig?ScannerConfig.CouponReport).\n\n**Example Usage:**\n\n    :::java\n    upcEan.couponReport = CouponReport.OLD;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.CouponReport](#api-ScannerConfig?ScannerConfig.CouponReport)\n\n###eanZeroExtend\nEan zero extend\n\n**Type:**\n\nboolean\n\n###linearDecode\nFlag to enable linear decode.\n\n**Example Usage:**\n\n    :::java\n    upcEan.linearDecode = true;\n\n**Type:**\n\nboolean\n\n###randomWeightCheckDigit\nFlag to enable random weight check digit verification.\n\n**Example Usage:**\n\n    :::java\n    upcEan.randomWeightCheckDigit = true;\n\n**Type:**\n\nboolean\n\n###securityLevel\nThe scanner of fers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application. Use enum [ScannerConfig.SecurityLevel](#api-ScannerConfig?ScannerConfig.SecurityLevel).\n\n**Example Usage:**\n\n    :::java\n    upcEan.securityLevel = SecurityLevel.LEVEL_0;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.SecurityLevel](#api-ScannerConfig?ScannerConfig.SecurityLevel)\n\n###supplemental2\nFlag to enable length 2 supplementals.\n\n**Example Usage:**\n\n    :::java\n    upcEan.supplemental2 = false;\n\n**Type:**\n\nboolean\n\n###supplemental5\nFlag to enable length 5 supplementals.\n\n**Example Usage:**\n\n    :::java\n    upcEan.supplemental5 = false;\n\n**Type:**\n\nboolean\n\n###supplementalMode\nThe supplemental mode. Use enum [ScannerConfig.SupplementalMode](#api-ScannerConfig?ScannerConfig.SupplementalMode).\n\n**Example Usage:**\n\n    :::java\n    upcEan.supplementalMode = SupplementalMode.S_378_379;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.SupplementalMode](#api-ScannerConfig?ScannerConfig.SupplementalMode)\n\n###supplementalRetries\nRetry count for auto-discriminating for supplementals. Possible values are 2 to 20 inclusive. Note that this flag is only considered if Supplemental Mode - UPC EAN is set to one of the following values: Supplementals Auto, Supplementals Smart, Supplementals 378-379 , Supplementals 978-979, Supplementals 977 or Supplementals 414-419-434-439 (2 to 20, default 10).\n\n**Example Usage:**\n\n    :::java\n    upcEan.supplementalRetries = 10;\n\n**Type:**\n\nint"},{"key":"api-ScannerConfig-DecoderParams-Us4State","name":"ScannerConfig.DecoderParams.Us4State","md":"#ScannerConfig.DecoderParams.Us4State\n\nThe US4State class provides access to parameters that are available for the US4State decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = us4State.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-Us4StateFics","name":"ScannerConfig.DecoderParams.Us4StateFics","md":"#ScannerConfig.DecoderParams.Us4StateFics\n\nThe Us4StateFics class provides access to parameters that are available for the Us4StateFics decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = us4StateFics.enabled;\n\n\n**Type:**\n\nboolean\n\n"},{"key":"api-ScannerConfig-DecoderParams-UsPlanet","name":"ScannerConfig.DecoderParams.UsPlanet","md":"#ScannerConfig.DecoderParams.UsPlanet\n\nThe UsPlanet class provides access to parameters that are available for the UsPlanet decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = usPlanet.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###reportCheckDigit\nFlag to enable reporting the bar code check digit.\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-UsPostNet","name":"ScannerConfig.DecoderParams.UsPostNet","md":"#ScannerConfig.DecoderParams.UsPostNet\n\nThe UsPostNet class provides access to parameters that are available for the UsPostNet decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = usPostNet.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###reportCheckDigit\nFlag to enable reporting the bar code check digit.\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams-WebCode","name":"ScannerConfig.DecoderParams.WebCode","md":"#ScannerConfig.DecoderParams.WebCode\n\nThe WebCode class provides access to parameters that are available for the WebCode decoder.\n\n##Public Fields\n\n###enabled\nReturns whether or not the Decoder is currently enabled.\n\n**Example Usage:**\n\n    :::java\n    boolean isEnabled = webCode.enabled;\n\n\n**Type:**\n\nboolean\n\n\n###subType\nWebcode sub type enabled\n\n**Type:**\n\nboolean"},{"key":"api-ScannerConfig-DecoderParams","name":"ScannerConfig.DecoderParams","md":"#ScannerConfig.DecoderParams\n\nThe DecoderParams class contains decoder parameters that are used by multiple decoder symbologies. The property provides access to such decoder parameters as Enabled and IsSupported, among others. \n\n> NOTE: When calling enable() after disable(), all the latest configuration parameter values (Config.DecoderParams, Config.ScannerParams, Config.ReaderParams and Config.InterfaceParams) will be set automatically. \n\n##Public Fields\n###australianPostal\nThe AustralianPostal class provides access to parameters that are available for the AustralianPostal decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.AustralianPostal](#api-ScannerConfig-DecoderParams-AustralianPostal)\n\n###aztec\nThe AZTEC class provides access to parameters that are available for the AZTEC decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Aztec](#api-ScannerConfig-DecoderParams-Aztec)\n\n###canadianPostal\nThe CanadianPostal class provides access to parameters that are available for the CanadianPostal decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.CanadianPostal](#api-ScannerConfig-DecoderParams-CanadianPostal)\n\n###chinese2of5\n\nThe Chinese_2of5 class provides access to parameters that are available for the Chinese2of5 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Chinese2of5](#api-ScannerConfig-DecoderParams-Chinese2of5)\n\n###codaBar\nThe CodaBar class provides access to parameters that are available for the CodaBar decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.CodaBar](#api-ScannerConfig-DecoderParams-CodaBar)\n\n###code11\nThe Code11 class provides access to parameters that are available for the Code11 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Code11](#api-ScannerConfig-DecoderParams-Code11)\n\n###code128\nThe Code128 class provides access to parameters that are available for the Code128 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Code128](#api-ScannerConfig-DecoderParams-Code128)\n\n###code39\nThe Code39 class provides access to parameters that are available for the Code39 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Code39](#api-ScannerConfig-DecoderParams-Code39)\n\n###code93\nThe Code93 class provides access to parameters that are available for the Code93 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Code93](#api-ScannerConfig-DecoderParams-Code93)\n\n###compositeAB\nThe Composite_AB class provides access to parameters that are available for the CompositeAB decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.CompositeAB](#api-ScannerConfig-DecoderParams-CompositeAB)\n\n###compositeC\nThe Composite_C class provides access to parameters that are available for the CompositeC decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.CompositeC](#api-ScannerConfig-DecoderParams-CompositeC)\n\n###d2of5\nThe D2OF5 class provides access to parameters that are available for the D2OF5 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.D2of5](#api-ScannerConfig-DecoderParams-D2of5)\n\n###dataMatrix\nThe DataMatrix class provides access to parameters that are available for the DataMatrix decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.DataMatrix](#api-ScannerConfig-DecoderParams-DataMatrix)\n\n\n###dutchPostal\nThe DutchPostal class provides access to parameters that are available for the DutchPostal decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.DutchPostal](#api-ScannerConfig-DecoderParams-DutchPostal)\n\n###ean13\nThe EAN13 class provides access to parameters that are available for the EAN13 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Ean13](#api-ScannerConfig-DecoderParams-Ean13)\n\n###ean8\nThe EAN8 class provides access to parameters that are available for the EAN8 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Ean8](#api-ScannerConfig-DecoderParams-Ean8)\n\n###gs1Databar\nThe GS1Databar class provides access to parameters that are available for the GS1 Databar decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Gs1Databar](#api-ScannerConfig-DecoderParams-Gs1Databar)\n###gs1DatabarExp\nThe GS1DatabarExp class provides access to parameters that are available for the GS1 Databar Exp decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Gs1DatabarExp](#api-ScannerConfig-DecoderParams-Gs1DatabarExp)\n\n###gs1DatabarLim\nThe GS1DatabarLim class provides access to parameters that are available for the GS1 Databar Lim decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Gs1DatabarLim](#api-ScannerConfig-DecoderParams-Gs1DatabarLim)\n\n###hanXin\nThe HanXin class provides access to parameters that are available for the HanXin decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.HanXin](#api-ScannerConfig-DecoderParams-HanXin)\n\n###i2of5\nThe I2OF5 class provides access to parameters that are available for the I2OF5 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.I2of5](#api-ScannerConfig-DecoderParams-I2of5)\n\n###japanesePostal\nThe JapanesePostal class provides access to parameters that are available for the JapanesePostal decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.JapanesePostal](#api-ScannerConfig-DecoderParams-JapanesePostal)\n\n###korean3of5\nThe Korean_3of5 class provides access to parameters that are available for the Korean3of5 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Korean3of5](#api-ScannerConfig-DecoderParams-Korean3of5)\n\n###mailMark\nThe MailMark class provides access to parameters that are available for the MailMark decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.MailMark](#api-ScannerConfig-DecoderParams-MailMark)\n\n###matrix2of5\nThe Matrix_2of5 class provides access to parameters that are available for the Matrix2of5 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Matrix2of5](#api-ScannerConfig-DecoderParams-Matrix2of5)\n\n###maxiCode\nThe MaxiCode class provides access to parameters that are available for the MaxiCode decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.MaxiCode](#api-ScannerConfig-DecoderParams-MaxiCode)\n\n###microPDF\nThe MicroPDF class provides access to parameters that are available for the MicroPDF decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.MicroPdf](#api-ScannerConfig-DecoderParams-MicroPdf)\n\n###microQR\nThe MicroQR class provides access to parameters that are available for the MicroQR decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.MicroQr](#api-ScannerConfig-DecoderParams-MicroQr)\n\n###msi\nThe MSI class provides access to parameters that are available for the MSI decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Msi](#api-ScannerConfig-DecoderParams-Msi)\n\n###pdf417\nThe PDF417 class provides access to parameters that are available for the PDF417 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Pdf417](#api-ScannerConfig-DecoderParams-Pdf417)\n\n###qrCode\nThe QRCode class provides access to parameters that are available for the QRCode decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.QrCode](#api-ScannerConfig-DecoderParams-QrCode)\n\n###signature\nThe Signature class provides access to parameters that are available for the Signature decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Signature](#api-ScannerConfig-DecoderParams-Signature)\n\n###tlc39\nThe TLC39 class provides access to parameters that are available for the TLC39 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Tlc39](#api-ScannerConfig-DecoderParams-Tlc39)\n\n###triOptic39\nThe TriOptic39 class provides access to parameters that are available for the TriOptic39 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.TriOptic39](#api-ScannerConfig-DecoderParams-TriOptic39)\n\n###ukPostal\nThe UKPostal class provides access to parameters that are available for the UKPostal decoder.\n\n**Type:**\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.UkPostal](#api-ScannerConfig-DecoderParams-UkPostal)\n\n###upcEanParams\nThe UPCEAN class provides access to parameters that are available for the UPC/EAN decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.UpcEanParams](#api-ScannerConfig-DecoderParams-UpcEanParams)\n\n###upca\nThe UPCA class provides access to parameters that are available for the UPCA decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Upca](#api-ScannerConfig-DecoderParams-Upca)\n\n###upce0\nThe UPCE0 class provides access to parameters that are available for the UPCE0 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Upce0](#api-ScannerConfig-DecoderParams-Upce0)\n\n###upce1\nThe UPCE1 class provides access to parameters that are available for the UPCE1 decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Upce1](#api-ScannerConfig-DecoderParams-Upce1)\n\n###us4State\nThe US4State class provides access to parameters that are available for the US4State decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Us4State](#api-ScannerConfig-DecoderParams-Us4State)\n\n###us4StateFics\nThe US4State_FICS class provides access to parameters that are available for the US4StateFics decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.Us4StateFics](#api-ScannerConfig-DecoderParams-Us4StateFics)\n\n###usPlanet\nThe USPlanet class provides access to parameters that are available for the USPlanet decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.UsPlanet](#api-ScannerConfig-DecoderParams-UsPlanet)\n\n###usPostNet\nThe USPostNet class provides access to parameters that are available for the USPostNet decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.UsPostNet](#api-ScannerConfig-DecoderParams-UsPostNet)\n\n###webCode\nThe webCode class provides access to parameters that are available for the webCode decoder.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams.WebCode](#api-ScannerConfig-DecoderParams-WebCode)\n\n"},{"key":"api-ScannerConfig-ReaderParams-ReaderSpecific-CameraSpecific","name":"ScannerConfig.ReaderParams.ReaderSpecific.CameraSpecific","md":"#ScannerConfig.ReaderParams.ReaderSpecific.CameraSpecific\n\nCameraSpecific class provides access to the camera scanner specific parameters.\n\n##Public Fields\n###beamTimer\nSets the maximum amount of time that the reader remains on (0 - 60,000 ms in increments of 100 ms). A value of 0 sets the reader to stay on indefinitely.\n\n**Type:**\n\nint\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.beamTimer = 1500;\n\n###continuousRead\nContinuousRead class provides access to continuous scanning related parameters.\n\n**Type:**\n\n[ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead](#api-ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead)\n\n###linearSecurityLevel\nSets the number of times a bar code is read to confirm an accurate decode. Use enum ScannerConfig.LinearSecurityLevel.\n\n**Type:**\n\n[ScannerConfig.LinearSecurityLevel](#api-ScannerConfig?ScannerConfig.LinearSecurityLevel)\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.linearSecurityLevel = LinearSecurityLevel.ALL_THRICE;\n\n###illuminationMode\nTurns camera illumination on and off. This option is only available when camera is selected in the Barcode input Scanner selection option. Use enum [ScannerConfig.IlluminationMode](#api-ScannerConfig?ScannerConfig.IlluminationMode).\n\n**Example Usage:**\n\n    :::java\n    readerParams.cameraSpecific.illuminationMode = IlluminationMode.ON;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.IlluminationMode](#api-ScannerConfig?ScannerConfig.IlluminationMode)\n\n###inverse1DMode\nThis parameter allows the user to select decoding on inverse 1D bar codes. Use enum [ScannerConfig.Inverse1DMode](#api-ScannerConfig?ScannerConfig.Inverse1DMode).\n\n**Example Usage:**\n\n    :::java\n    readerParams.cameraSpecific.inverse_1d_mode = Inverse1DMode.AUTO;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.Inverse1DMode](#api-ScannerConfig?ScannerConfig.Inverse1DMode)\n\n###viewfinderMode\nConfigures the Viewfinder modes supported for camera scanning. Use enum [ScannerConfig.ViewFinderMode](#api-ScannerConfig?ScannerConfig.ViewFinderMode).\n\n**Example Usage:**\n\n    :::java\n    readerParams.cameraSpecific.viewfinder_mode = ViewFinderMode.DISABLED;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ViewFinderMode](#api-ScannerConfig?ScannerConfig.ViewFinderMode)"},{"key":"api-ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead","name":"ScannerConfig.ReaderParams.ReaderSpecific.ContinuousRead","md":"#ScannerConfig.ReaderParams.ReaderSpecific.ContinuousRead\n\nContinuousRead class provides access to continuous scanning related parameters.\n\n##Public Fields\n###isContinuousScan\nScan continuously; In this mode once the trigger is pulled the user can continue scanning barcodes without releasing the trigger as long as new reads are submitted as soon as the earlier read is satisfied. This mode is useful when the user wants to perform rapid scanning. To provide better control over this feature we have added the two new reader parameters (SameSymbolTimeout, DifferentSymbolTimeout) that are associated with continuous reads. These reader parameters are available in both ImagerSpecific and LaserSpecific classes. \n\n> NOTE: The following must be considered when using this AIM_TYPE_CONTINUOUS_READ mode.\n> \n> 1. After each successful read, the application will have to submit a new read for rapid triggering.\n> 2. It is recommended that the Picklist mode be enabled for the imager-class scanners.\n> 3. When using this mode, the IMAGER_SPECIFIC.VFFeedback parameter will be ignored and no viewfinder feedback will be provided. It is similar to setting IMAGER_SPECIFIC.VFFeedback to VIEWFINDER_FEEDBACK.VIEWFINDER_MODE_DISABLED\n> 4. If the IMAGER_SPECIFIC.VFMode parameter is set to VIEWFINDER_MODE.VIEWFINDER_MODE_DYNAMIC_RETICLE, then this continuous read mode will be ignored\n\n**Type:**\n\nboolean\n\n###sameSymbolTimeout\nThis setting is used to prevent the scanner driver from decoding the same symbol within this time interval (applicable only when isContinuous = true). Basically in the continuous mode the user can perform rapid scan and to prevent the user from decoding the same barcode twice user can set this value to an appropriate interval (in milliseconds). A value of 0 means no interval is required between two successive reads.\n\n**Type:**\n\nint\n\n###differentSymbolTimeout\nThis setting is used to prevent the scanner from decoding another symbol within this time interval (applicable only when isContinuous = true). The user may want to prevent decoding too quickly and set an interval that the user can aim before decoding the next barcode. A value of 0 means no interval is required between two successive reads.\n\n**Type:**\n\nint"},{"key":"api-ScannerConfig-ReaderParams-ReaderSpecific-ImagerSpecific","name":"ScannerConfig.ReaderParams.ReaderSpecific.ImagerSpecific","md":"#ScannerConfig.ReaderParams.ReaderSpecific.ImagerSpecific\n\nImagerSpecific provides access to the imager specific parameters.\n\n##Public Fields\n###beamTimer\nSets the maximum amount of time that the reader remains on (0 - 60,000 ms in increments of 100 ms). A value of 0 sets the reader to stay on indefinitely.\n\n**Type:**\n\nint\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.beamTimer = 1500;\n\n###connectionIdleTime\nThis is the time (in seconds) when an external scanner is idle in a particular state (ScannerStates.IDLE to ScannerStates.WAITING) after which the connection between the terminal and the scanner is severed to conserve power. This is currently applicable to Bluetooth scanners only.\n\n**Type:**\n\nint\n\n**Example Usage:**\n\n    :::java\n    readerParams.connectionIdleTime = 600;\n\n###continuousRead\nContinuousRead class provides access to continuous scanning related parameters.\n\n**Type:**\n\n[ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead](#api-ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead)\n\n\n###disconnectOnExit\nThis parameter indicates to the scan driver to disconnect any existing connection between an external Bluetooth scanner and the terminal. When a BT scanner establishes connection to the terminal it will not automatically disconnect when the scanner is disabled by calling Scanner.disable(). If this parameter is set the scanning driver will force the scanner to disconnect.\n                 \n> Note: If this parameter is set to true, it will not fire the DISCONNECTED state.\n\n**Type:**\n\nboolean\n\n**Example Usage:**\n\n    :::java\n    readerParams.disconnectOnExit = true;\n\n###linearSecurityLevel\nSets the number of times a bar code is read to confirm an accurate decode. Use enum ScannerConfig.LinearSecurityLevel.\n\n**Type:**\n\n[ScannerConfig.LinearSecurityLevel](#api-ScannerConfig?ScannerConfig.LinearSecurityLevel)\n\n**Example Usage:**\nreaderParams.linearSecurityLevel = LinearSecurityLevel.ALL_THRICE;\n\n\n###illuminationBrightness\nIllumination Brightness of the Imager. The valid range is 1 to 10.\n\n**Example Usage:**\n\n    :::java\n    imagerSpecific.illuminationBrightness = 2;\n\n**Type:**\n\nint\n\n###inverse1DMode\nThis parameter allows the user to select decoding on inverse 1D bar codes. Use enum [ScannerConfig.Inverse1DMode](#api-ScannerConfig?ScannerConfig.Inverse1DMode).\n\n**Example Usage:**\n\n    :::java\n    imagerSpecific.inverse1DMode = Inverse1DMode.AUTO;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.Inverse1DMode](#api-ScannerConfig?ScannerConfig.Inverse1DMode)\n\n###lcdMode\nEnables or disables LCD mode. LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones (imager only). Use enum [ScannerConfig.LcdMode](#api-ScannerConfig?ScannerConfig.LcdMode).\n\n**Example Usage:**\n\n    :::java\n    imagerSpecific.lcdMode = LcdMode.DISABLED;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.LcdMode](#api-ScannerConfig?ScannerConfig.LcdMode)\n\n###pickList\nAllows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is targeted for decode. Use enum [ScannerConfig.PickList](#api-ScannerConfig?ScannerConfig.PickList).\n\n**Example Usage:**\n\n    :::java\n    imagerSpecific.picklist = PickList.DISABLED;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.PickList](#api-ScannerConfig?ScannerConfig.PickList)"},{"key":"api-ScannerConfig-ReaderParams-ReaderSpecific-LaserSpecific","name":"ScannerConfig.ReaderParams.ReaderSpecific.LaserSpecific","md":"#ScannerConfig.ReaderParams.ReaderSpecific.LaserSpecific\n\nLaserSpecific class provides access to the laser scanner specific parameters.\n\n##Public Fields\n###beamTimer\nSets the maximum amount of time that the reader remains on (0 - 60,000 ms in increments of 100 ms). A value of 0 sets the reader to stay on indefinitely. \n\n**Example Usage:**\n\n    :::java\n    readerParams.beamTimer = 1500;\n\n**Type:**\n\nint\n\n###continuousRead\nContinuousRead class provides access to continuous scanning related parameters.\n\n**Type:**\n\n[ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead](#api-ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead)\n\n\n###linearSecurityLevel\nSets the number of times a bar code is read to confirm an accurate decode. Use enum [ScannerConfig.LinearSecurityLevel](#api-ScannerConfig?ScannerConfig.LinearSecurityLevel).\n\n**Example Usage:**\n\n    :::java\n    readerParams.linearSecurityLevel = LinearSecurityLevel.ALL_THRICE;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.LinearSecurityLevel](#api-ScannerConfig?ScannerConfig.LinearSecurityLevel)\n\n###inverse1DMode\nThis parameter allows the user to select decoding on inverse 1D bar codes. Use enum [ScannerConfig.Inverse1DMode](#api-ScannerConfig?ScannerConfig.Inverse1DMode).\n\n**Example Usage:**\n\n    :::java\n    readerParams.cameraSpecific.inverse_1d_mode = Inverse1DMode.AUTO;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.Inverse1DMode](#api-ScannerConfig?ScannerConfig.Inverse1DMode)\n\n###powerMode\nSet scanner power mode. Use enum [ScannerConfig.PowerMode](#api-ScannerConfig?ScannerConfig.PowerMode).\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.PowerMode](#api-ScannerConfig?ScannerConfig.PowerMode)"},{"key":"api-ScannerConfig-ReaderParams-ReaderSpecific","name":"ScannerConfig.ReaderParams.ReaderSpecific","md":"#ScannerConfig.ReaderParams.ReaderSpecific\n\nReaderSpecific class provides access to the reader specific parameters.\n\n##Constructors\n###ReaderSpecific()\n\n##Public Fields\n###cameraSpecific\nProvide access to set the imager specific settings if the scanner device is camera.\n\n**Example Usage:**\n\n    :::java\n    if (scanner.getScannerInfo().getDeviceType() == DeviceType.IMAGER)\n    {\n    readerParams.readerSpecific.cameraSpecific.illuminationMode = IlluminationMode.ON;\n    }\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ReaderParams.ReaderSpecific.CameraSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific-CameraSpecific)\n\n###imagerSpecific\nProvide access to set the imager specific settings if the scanner device is imager.\n\n**Example Usage:**\n\n    :::java\n    if (scanner.getScannerInfo().getDeviceType() == DeviceType.IMAGER) \n    {\n     readerParams.readerSpecific.imagerSpecific.picklist = PickList.DISABLED;\n    }\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ReaderParams.ReaderSpecific.ImagerSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific-ImagerSpecific)\n\n###laserSpecific\nProvide access to set the laser specific settings if the scanner device is laser.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ReaderParams.ReaderSpecific.LaserSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific-LaserSpecific)\n\n\n###ContinuousRead\nContinuousRead class provides access to continuous scanning related parameters.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ReaderParams.ReaderSpecific.ContinuousRead](#api-ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead)"},{"key":"api-ScannerConfig-ReaderParams","name":"ScannerConfig.ReaderParams","md":"#ScannerConfig.ReaderParams\n\nThe ReaderParams class holds the parameters for a scanner. Reader parameters are global to all reads on all open handles on the same scanner. \n\n> NOTE: When calling enable() after disable(), all the latest configuration parameter values. (Config.DecoderParams, Config.ScannerParams, Config.ReaderParams) will be set automatically.\n\n##Public Fields\n###readerSpecific\nReaderSpecificParams provides access to the reader specific parameters.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ReaderParams.ReaderSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific)"},{"key":"api-ScannerConfig-ScanParams","name":"ScannerConfig.ScanParams","md":"#ScannerConfig.ScanParams\n\nThe ScanParams class provides access to scanning parameters that are available for all decoders. \n\n> NOTE: When calling enable() after disable(), all the latest configuration parameter values (Config.DecoderParams, Config.ScannerParams, Config.ReaderParams and Config.InterfaceParams) will be set automatically.\n\n##Public Fields\n###audioStreamType\nThe audio stream type refers to type of streaming on which the scan beep should be played. The decodeAudioFeedbackUri specified must be available for the audio streaming type specified.\n\n**Example Usage:**\n\n    :::java\n    scanParams.audioStreamType = AudioStreamType.RINGER;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.AudioStreamType](#api-ScannerConfig?ScannerConfig.AudioStreamType)\n\n###codeIdType\nA Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol. Use enum [ScannerConfig.CodeIdType](#api-ScannerConfig?ScannerConfig.CodeIdType).\n\n**Example Usage:**\n\n    :::java\n    scanParams.codeIdType = CODE_ID_TYPE.NONE;\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.CodeIdType](#api-ScannerConfig?ScannerConfig.CodeIdType)\n\n###decodeAudioFeedbackUri\nSelect an audio tone to sound upon a good decode. The valid audio files from the RingTone manager can be used for audio feedback.\n\n**Example Usage:**\n\n    :::java\n    scanParams.decodeAudioFeedbackURI = \"system/media/audio/notifications/decode-short.wav\";\n    scanParams.decodeAudioFeedbackUri = \"sdcard/sample-audio.wav\";\n    scanParams.decodeAudioFeedbackUri = \"sdcard/sample-audio.ogg\";\n\tscanParams.decodeAudioFeedbackUri = \"/sdcard/sample-audio.wav\";\n\n> Note: To achieve no feedback (silent) upon a good decode, specify an empty string as below:\n\n\tscanParams.decodeAudioFeedbackURI = \"\";\n\n**Type:**\n\njava.lang.String\n\n###decodeHapticFeedback\nEnable the device to vibrate upon a good decode.\n\n**Example Usage:**\n\n    :::java\n    scanParams.decodeHapticFeedback = true;\n\n**Type:**\n\nboolean\n\n###decodeLEDFeedback\nDecoding LED Notification.\n\n**Example Usage:**\n\n    :::java\n    scanParams.decodeLEDFeedback = true;\n\n**Type:**\n\nboolean\n\n###decodeLEDTime\nDecode LED ON duration upon successful decode in milliseconds. This value can be from 0ms to 1000ms with a step of 25ms.\n\n**Example Usage:**\n\n    :::java\n    scanParams.decodeLEDTime = 75;\n\n**Type:**\n\nint"},{"key":"api-ScannerConfig","name":"ScannerConfig","md":"#ScannerConfig\n\nThe ScannerConfig class provides access to scanner configuration settings.  \n\n**Example Usage:**\n\n    :::java\n    ScannerConfig scannerConfig = scanner.getConfig(scannerConfig);\n    scannerConfig.scanParams.decodeHapticFeedback = true;\n    scannerConfig.decoderParams.codabar.length1 = 6;\n    scanner.setConfig(scannerConfig);\n\n**Version:**\n\n1.0\n\n##Public Methods\n###isParamSupported(String param)\nThis method helps to check scanner config parameters supported Returns true if specified parameter is supported. The field name should be specify complete access path till the field in the string format. The scanner config object name can be any name, but following field names should exactly match the fields defined by scanner config class.\n\n**Example Usage:**\n\n    :::java\n    ScannerConfig config1 = scanner.getConfig(scannerConfig);\n    if ( config1.isParamSupported(\"config1.scanParams.decodeHapticFeedback\") ) \n    { \n      config1.scanParams.decodeHapticFeedback = true; \n    } \n    if ( config1.isParamSupported(\"config1.decoderParams.codabar.enabled\") ) \n    { \n    config1.decoderParams.codabar.enabled = true; \n    } \n    scanner.setConfig(config1);\n\n**Parameters:**\n\n**param**\n\n**Returns:**\n\nboolean\n\n###resetToDefault(Scanner scanner)\nResets the scanner parameters to defaults values for the specified scanner. The unsupported parameters left as it is.\n\n**Parameters:**\n\n**scanner**\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[ScannerException](#api-ScannerException)\n\n##Public Fields\n###decoderParams\nThe DecoderParams class contains decoder parameters that are used by multiple decoder symbologies. The property provides access to such decoder parameters as Enabled and isSupported, among others. \n\n> NOTE: When calling enable() after disable(), all the latest configuration parameter values (Config.DecoderParams, Config.ScannerParams, Config.ReaderParams) will be set automatically.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.DecoderParams](#api-ScannerConfig-DecoderParams)\n\n###readerParams\nThe ReaderParams class holds the parameters for a scanner. Reader parameters are global to all reads on all open handles on the same scanner. \n\n> NOTE: When calling enable() after disable(), all the latest configuration parameter values (Config.DecoderParams, Config.ScannerParams, Config.ReaderParams) will be set automatically.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ReaderParams](#api-ScannerConfig-ReaderParams)\n\n###scanParams\nThe ScanParams property provides access to scanning parameters that are available for all decoders. \n\n> NOTE: When calling enable() after disable(), all the latest configuration parameter values (Config.DecoderParams, Config.ScannerParams, Config.ReaderParamss) will be set automatically.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.ScanParams](#api-ScannerConfig-ScanParams)\n\n###skipOnUnsupported\nThis flag to tells whether to skip the unsupported parameter/values and continue or stop setting the configuration. Its set to UNSUPPORTED_PARAM by default which skips the unsupported params and continues.\n\n**Type:**\n\ncom.symbol.emdk.barcode.[ScannerConfig.SkipOnUnSupported](#api-ScannerConfig?ScannerConfig.SkipOnUnSupported)\n\n\n\n##Public Enums\n\n###ScannerConfig.AudioStreamType\nVolume slider type for decode audio feedback.\n\n**Values:**\n\n**RINGER** - Ringer and Notifications.\n\n**MEDIA** - Music and Media.\n\n**ALARAMS** - Alarms.\n\n###ScannerConfig.BooklandFormat\nLists the Bookland formats\n\n**Example Usage:**\n\n    :::java\n    BooklandFormat.ISBN_10;\n\n**Values:**\n\n**ISBN_10** - 978 reported in 10 digit mode\n\n**ISBN_13** - 978/979 transmitted as EAN13 as per 2007 ISBN-13 protocol\n\n###ScannerConfig.CheckDigit\nThe number of check digits to be verified. With MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional.\n\n**Example Usage:** \n\n    :::java\n    CheckDigit.ONE;\n\n**Values:**\n\n**ONE** - Verify one check digit.\n\n**TWO** - Verify two check digits.\n\n###ScannerConfig.CheckDigitScheme\nTwo algorithms are possible for the verification of the second MSI check digit. Select the algorithm used to encode the check digit.\n\n**Example Usage:** \n\n    :::java\n    CheckDigitScheme.MOD_11_10;\n\n**Values:**\n\n**MOD_11_10** - First check digit is MOD 11 and second check digit is MOD 10.\n\n**MOD_10_10** - Both check digits are MOD 10.\n\n###ScannerConfig.CheckDigitType\nVerify data integrity.\n\n**Example Usage:** \n\n    :::java\n    CheckDigitType.NO;\n\n**Values:**\n\n**NO** - A check digit is not used.\n\n**USS** - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Uniform Symbology Specification (USS) check digit algorithm.\n\n**OPCC** - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Optical Product Code Council (OPCC) check digit algorithm.\n\n###ScannerConfig.CodeIdType\nA Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol.\n\n**Example Usage:**\n\n    :::java\n    CodeIdType.NONE;\n\n**Values:**\n\n**NONE** - No prefix.\n\n**AIM** - A standards based three character prefix.\n\n**SYMBOL** - A Symbol defined single character prefix.\n\n###ScannerConfig.CouponReport\nSupported Coupon modes\n\n**Example Usage:**\n\n    :::java\n    CouponReport.OLD; \n\n**Values:**\n\n**OLD** - Scanner will read only the old coupon format\n\n**NEW** - Scanner will read only the new GS1 DataBar coupon format\n\n**BOTH** - Scanner will read both old coupon format as well as the new GS1 DataBar coupon format.\n\n###ScannerConfig.HanXinInverse\nThis parameter allows the user to select decoding on inverse HanXin bar codes.\n\n**Example Usage:**\n\n    :::java\n    HanXinInverse.DISABLED;\n\n**Values:**\n\n**AUTO** - Allows decoding of both positive as well as inverse HanXin symbologies.\n\n**DISABLED** - Disables decoding of inverse HanXin symbologies.\n\n**ENABLED** - Enables decoding of only inverse HanXin symbologies.\n\n###ScannerConfig.IlluminationMode\nEnable/disable illumination depending on ambient light conditions. This option is only available when camera is selected in the Barcode input Scanner selection option.\n\n**Example Usage:**\n\n    :::java\n    IlluminationMode.OFF; \n\n**Values:**\n\n**OFF (\"off\")** - Illumination turned off during scanning.\n\n**ON (\"torch\")** - Illumination turned on during scanning.\n\n###ScannerConfig.Inverse1DMode\nThis parameter allows the user to select decoding on inverse 1D bar codes.\n\n**Example Usage:**\n\n    :::java\n    Inverse1DMode.DISABLED; \n\n**Values:**\n\n**DISABLED** - Disables decoding of inverse 1D symbologies.\n\n**ENABLED** - Enables decoding of only inverse 1D symbologies.\n\n**AUTO** - Allows decoding of both positive as well as inverse 1D symbologies.\n\n###ScannerConfig.Isbt128ContactMode\nOption for concatenating pairs of ISBT128 code types.\n\n**Example Usage:**\n\n    :::java\n    Isbt128ContactMode.NEVER;\n\n**Values:**\n\n**NEVER** - Will ignore the barcode pair and only output decode data for only one of the barcodes.\n\n**ALWAYS** - Will not decode if both the barcodes are not present or if one of them cannot be decoded. There must be two ISBT codes in order to decode and perform concatenation.\n\n**AUTO** - Decodes and concatenates pairs of ISBT codes immediately. If only a single ISBT symbol is present, the device must decode the symbol the number of times set via DataWedge Configuration 4 - 1 1 Redundancy - Code128 before transmitting its data to confirm that there is no additional ISBT symbol.\n\n###ScannerConfig.LcdMode\nEnable or disable LCD mode (for Blockbuster imager devices only). LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones.\n\n**Example Usage:**\n\n    :::java\n    LCDMode.DISABLED;\n\n**Values:**\n\n**DISABLED** - Disables LCD mode\n\n**ENABLED** - Enables LCD mode.\n\n###ScannerConfig.LinearSecurityLevel\nSets the number of times a bar code is read to confirm an accurate decode.\n\n**Example Usage:**\n\n    :::java\n    LinearSecurityLevel.SHORT_OR_CODABAR;\n\n**Values:**\n\n**SHORT_OR_CODABAR** - Two times read redundancy if short bar code or Codabar.\n\n**ALL_TWICE** - Two times read redundancy for all bar codes (default).\n\n**LONG_AND_SHORT** - Two times read redundancy for long bar codes, three times for short bar codes.\n\n**ALL_THRICE** - Three times read redundancy for all bar codes.\n\n###ScannerConfig.PickList\nAllows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is tar geted for decode.\n\n**Example Usage:**\n\n    :::java\n    PickList.DISABLED;\n\n**Values:**\n\n**DISABLED** - Disables Picklist mode. Any bar code within the field of view can be decoded.\n\n**ENABLED** - Enables the Picklist mode so that only the bar code that is directly under the cross-hair (reticle) is decoded. This is useful when used in conjunction with the static and dynamic reticle viewfinder modes. (Scan Module Only)\n\n###ScannerConfig.Preamble\nControls the preamble applied to the bar code Preamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system.\n\n**Example Usage:**\n\n    :::java\n    Preamble.NONE;\n\n**Values:**\n\n**NONE** - No preamble\n\n**SYS_CHAR** - System character preamble\n\n**COUNTRY_AND_SYS_CHAR** - Both country and system code preamble\n\n###ScannerConfig.SecurityLevel\nThe scanner offers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application.\n\n**Example Usage:**\n\n    :::java\n    SecurityLevel.LEVEL_0;\n\n**Values:**\n\n**LEVEL_0** - This setting allows the scanner to operate fastest, while providing.\n\n**LEVEL_1** - As bar code quality levels diminish, certain characters become prone to misdecodes before others (i.e., 1, 2, 7, 8). If the scanner is misdecoding poorly printed bar codes, and the misdecodes are limited to these characters, select this security level.\n\n**LEVEL_2** - If the scanner is misdecoding poorly printed bar codes, and the misdecodes are not limited to characters 1, 2, 7, and 8, select this security level.\n\n**LEVEL_3** - If the scanner is still misdecoding, select this security level. Be advised, selecting this option is an extreme measure against misdecoding severely out of spec bar codes. Selecting this level of security can significantly impair the decoding ability of the scanner. If this level of security is necessary, try to improve the quality of the bar codes\n\n###ScannerConfig.SkipOnUnSupported\n\n**Values:**\n\n**NONE** - Throws exception on any unsupported parameters or values.\n\n**UNSUPPORTED_PARAM** - Skips the only unsupported paramter and continues with next.\n\n**UNSUPPORTED_VALUE** - Skips the only unsupported values and continues with next.\n\n**ALL** - Skips both unsupported paramters and values and continues with next.\n\n###ScannerConfig.SupplementalMode\nSupplemental modes\n\n**Example Usage:**\n\n    :::java\n    SupplementalMode.NO;\n\n**Values:**\n\n**NO** - The scanner is presented with a UPC/EAN plus supplemental symbol, the scanner decodes UPC/EAN and ignores the supplemental characters.\n\n**ALWAYS** - The scanner only decodes UPC/EAN symbols with supplemental characters, and ignores symbols without supplementals.\n\n**AUTO** - The scanner decodes UPC/EAN symbols with supplemental characters immediately . If the symbol does not have a supplemental, the scanner must decode the bar code the number of times set via UPC/EAN Supplemental Redundancy before transmitting its data to confirm that there is no supplemental.\n\n**SMART** - Enables smart supplementals. In this mode the decoder returns the decoded value of the main block right away if it does not belong to one of the following supplemental types: 378, 379, 977, 978, 979, 414, 419, 434 or 439. If the bar code starts with one of the prefixes it searches the image more aggressively for a supplemental. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n**S_378_379** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 378 or 379. Disables reading of supplementals for any other UPC/EAN bar code not starting with 378 or 379. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n**S_978_979** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 978 or 979. Disables reading of supplementals for another UPC/EAN bar code not starting with 978 or 979. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n**S_414_419_434_439** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 414, 419, 434 or 439. Disables reading of supplementals for another UPC/EAN bar code 4 - 16 not starting with 414, 419, 434 or 439. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n**S_977** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 977. Disables reading of supplementals for another UPC/EAN barcode not starting with 977. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n###ScannerConfig.UccLinkMode\nDescribes the UCC link mode state.\n\n**Example Usage:**\n\n    :::java\n    UCCLinkMode.LINK_FLAG_IGNORED;\n\n**Values:**\n\n**LINK_FLAG_IGNORED** - 1D component is transmitted regardless of whether a 2D component is detected.\n\n**ALWAYS_LINKED** - 1D and the 2D components are transmitted. If 2D is not present, the 1D component is not transmitted.\n\n**AUTO_DISCRIMINATE** - the digital scanner determines if there is a 2D portion, then transmits the 1D component, as well as the 2D portion if present (default). (default).\n\n###ScannerConfig.VerifyCheckDigit\nCheck the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code.\n\n**Example Usage:**\n\n    :::java\n    VerifyCheckDigit.NO;\n\n**Values:**\n\n**NO** - Do not verify check digit.\n\n**ONE** - Bar code contains one check digit.\n\n**TWO** - Bar code contains two check digits.\n\n###ScannerConfig.ViewFinderMode\nConfigures the Viewfinder modes supported for camera scanning. \n\n**Example Usage:**\n\n    :::java\n    ViewFinderMode.ENABLED;\n\n**Values:**\n\n**ENABLED** - Viewfinder enabled. Displays the images captured by the camera on the screen.\n\n**STATIC_RECTICLE** - Viewfinder enabled with locate reticle. Displays the viewfinder as well as draws a red reticle in the center of the screen which helps with tracking the barcode.\n\n###ScannerConfig.PowerMode\nSet laser scanner power mode. \n\n**Values:**\n\n**LOW** - Lowest power, but slowest performance.\n\n**OPTIMIZED** - Power level adjusts with scanning usage.\n\n**HIGH** - High power, and excellent performance.\n\n**ALWAYS_ON** - Highest power, fastest performance.\n\n"},{"key":"api-ScannerException","name":"ScannerException","md":"#ScannerException\n\nThe methods of barcode scanning object throws ScannerException when an error occurs. The error could be due to:\n\n1. Client using the API incorrectly OR\n2. because an unexpected error occurred\n\n##Public Methods\n###getResult()\nReturns the ScannerResults enum value.\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[BarcodeManager.ScannerResults](#api-BarcodeManager?BarcodeManager.ScannerResults)"},{"key":"api-ScannerInfo","name":"ScannerInfo","md":"#ScannerInfo\nScannerInfo provides information of the scanner device.\n\n**Example Usage:**\n\n    :::java\n    scannerInfo.getFriendlyName();\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getConnectionType()\nReturns the scanner connection type to mobile computer Note: The connection type information is not available on Scanner Framework 1.18.P03 on TC55 REV A device.\n\n**Example Usage:**\n\n    :::java\n    ConnectionType deviceType = scannerInfo.getConnectionType();\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[ScannerInfo.ConnectionType](#api-ScannerInfo?ScannerInfo.ConnectionType) - Returns the ConnectionType\n\n###getDecoderType()\nReturns the barcode scanning type supported by scanner. Note: The decoder type information is not available on Scanner Framework 1.18.P03 on TC55 REV A device.\n\n**Example Usage:**\n\n    :::java\n    DecoderType decoderType = scannerInfo.getScannerInfo().getDecoderType();\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[ScannerInfo.DecoderType](#api-ScannerInfo?ScannerInfo.DecoderType) - Returns the DECODER_TYPE\n\n###getDeviceType()\nReturns the scanner device type.\n\n**Example Usage:**\n\n    :::java\n    DeviceType deviceType = scannerInfo.getDeviceType();\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[ScannerInfo.DeviceType](#api-ScannerInfo?ScannerInfo.DeviceType) - Returns the DeviceType\n\n###getFriendlyName()\nReturns the friendly name of the Device.\n\n**Example Usage:**\n\n    :::java\n    String name = scannerInfo.getFriendlyName();\n\n**Returns:**\n\njava.lang.String - Returns the friendly name\n\n###getModelNumber()\nReturns the scanner device model number. This information will be available only after the scanner is enabled. Note: The model number is supported on the Scanner Framework version 3.0.11 or later.\n\n**Example Usage:**\n\n    :::java\n    String model = scannerInfo.getModelNumber();\n\n**Returns:**\n\njava.lang.String - Returns the model string\n\n###isConnected()\n\n**Returns:**\n\nboolean\n\n###isDefaultScanner()\nReturns true if it is a default scanner else false.\n\n**Returns:**\n\nboolean\n\n##Public Enums\n###ScannerInfo.ConnectionType\nList of supported scanner connection types.\n\n**Example Usage:**\n\n    :::java\n    ConnectionType.INTERNAL;\n\n**Values:**\n\n**INTERNAL** - The scanner device connected internally within the mobile device.\n\n**BLUETOOTH_SSI** - The scanner device connected via Bluetooth to the mobile device.\n\n**SERIAL_SSI** - The scanner device connected via serial SSI to the mobile device.\n\n**USB** - The scanner device connected via USB to the mobile device.\n\n**UNDEFINED** - Connection type is not defined.\n\n###ScannerInfo.DecoderType\nThis lists all the barcode types supported by scanners.\n\n**Example Usage:**\n\n    :::java\n    DecoderType.ONE_DIMENSIONAL\n\n**Values:**\n\n**ONE_DIMENSIONAL** - Barcode scanning is 1-D only.\n\n**TWO_DIMENSIONAL** - Barcode scanning is 2-D. This supports both 1-D and 2-D barcode scanning.\n\n**UNDEFINED** - Decoder type not defined.\n\n###ScannerInfo.DeviceType\nList of supported scanner device types.\n\n**Example Usage:**\n\n    :::java\n    DeviceType.LASER;\n\n**Values:**\n\n**CAMERA** - The Scanner device class is camera.\n\n**IMAGER** - The scanner device class is imager.\n\n**LASER** - The scanner device class is laser.\n\n**UNDEFINED** - The scanner device class is not defined."},{"key":"api-SimulScanConfig","name":"SimulScanConfig","md":"#SimulScanConfig\n\nThe SimulScanConfig class provides access to reader configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tSimulScanMultiTemplate template1 = new SimulScanMultiTemplate(simulScanManager,fileUri);//fileUri points to the template\n\tSimulScanReader reader = simulscanManager.getDevice(template1.deviceIdentifier);\n\treader.enable(); \n\tSimulScanConfig config = reader.getConfig(); // Reader object must be enabled before calling getConfig\n\tconfig.audioFeedback = false;\n\treader.setConfig(config); // Reader object must be enabled and not scanning when calling setConfig\n\n\n**Version:**\n\n1.0\n\n##Public Fields\n###multiTemplate\nThe [SimulScanMultiTemplate](#api-SimulScanMultiTemplate) to scan.\n\n**Returns:**\n\n[SimulScanMultiTemplate](#api-SimulScanMultiTemplate)\n\n\n###autoCapture\nIf true, form will be captured automatically when detected. If false, user must manually tap screen or press trigger to capture form.\n\n**Returns:**\n\njava.lang.Boolean\n\n\n###debugMode\nIf enabled, allows a session to write form capture, region images, region values, and other data to storage. After successful session, a prompt will come up allowing the user to turn Debug Mode off.\n\n**Returns:**\n\njava.lang.Boolean\n\n\n###audioFeedback\nTurn on/off audio feedback.\n\n**Returns:**\n\njava.lang.Boolean\n\n\n###hapticFeedback\nTurn on/off haptic feedback.\n\n**Returns:**\n\njava.lang.Boolean\n\n\n###ledFeedback\nTurn on/off LED feedback.\n\n**Returns:**\n\njava.lang.Boolean\n\n\n###userConfirmationOnScan\nIf userConfirmationOnScan is true, shows UI for user to confirm the scanned data before sending results to application.\n\n**Returns:**\n\njava.lang.Boolean\n\n\n###identificationTimeout\nAmount of time in milliseconds to wait before timing out identification.\n\n**Returns:**\n\nint\n\n\n###processingTimeout\nAmount of time in milliseconds to wait before timing out processing.\n\n**Returns:**\n\nint"},{"key":"api-SimulScanData","name":"SimulScanData","md":"#SimulScanData\n\nThe SimulScanData object gives scanning result.\n\n**Example Usage:**\n\n\t:::java\n\tpublic void onSimulScanData(SimulScanData simulscanData) {\n\n\t\tDate timestamp = new Date(simulscanData.getTimestamp());\n\t\tList<SimulScanElement> simulscanDataElements = simulscanData.getElements();\n\t\tList<SimulScanRegion> simulscanDataRegions = new ArrayList<SimulScanRegion>(); \n\t\tfor (SimulScanElement curElement : simulscanDataElements)\n\t\t{\n\t\t\tif (curElement instanceof SimulScanRegion) {\n\t\t\t\tLog.d(TAG, ((SimulScanRegion) curElement).getName());\n\t\t\t} else if (curElement instanceof SimulScanGroup) {\t\n\t\t\t\tList<SimulScanRegion> regionsInGroup = ((SimulScanGroup)curElement).getRegions();\n\t\t\t\tfor (SimulScanRegion curRegion : regionsInGroup){\n\t\t\t\t\tLog.d(TAG, Group:+ ((SimulScanGroup)curElement).getName() + Region:+ ((SimulScanRegion) curRegion).getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \t}\n\n\n**Version:**\n\n1.0\n\n##Constructors\n###SimulScanData()\n\n\n##Public Methods\n###getTimestamp()\nReturns the time at which the data was scanned.\n\n**Returns:**\n\nReturns time stamp as Date object\n\n\n###getTemplate()\nReturns the scanned template.\n\n**Returns:**\n\nReturns [SimulScanTemplate](#api-SimulScanTemplate) template object\n\n\n###getElements()\nReturns a list of scanned elements.\n\n**Returns:**\n\nReturns a List object of [SimulScanElement](#api-SimulScanElement) objects"},{"key":"api-SimulScanElement","name":"SimulScanElement","md":"#SimulScanElement\n\nThe SimulScanElement abstract class represents a processed SimulScanTemplateElement.\n\n\n##Public Methods\n###getData()\nReturns additional processed data as an object of type Object.\n\n**Returns:**\n\njava.lang.Object\n\n\n###getElementNumber()\nReturns unique identifier of this element\n\n**Returns:**\n\nint\n\n\n###getName()\nReturns the friendly name of this element.\n\n**Returns:**\n\njava.lang.String"},{"key":"api-SimulScanException","name":"SimulScanException","md":"#SimulScanException\n\nThe SimulScan APIs throws SimulScanException when an error occurs. The error could be due to:\n\n1. Incorrect use of APIs.\n2. Or in case of an unexpected error.\n\n\n##Public Methods\n###getResult()\nReturns the SimulScanResults object that provides additional information on the exception.\n\n**Returns:**\n\n[SimulScanResults](#api-SimulScanManager?SimulScanManager.SimulScanResults)"},{"key":"api-SimulScanGroup","name":"SimulScanGroup","md":"#SimulScanGroup\n\nThe SimulScanGroup class represents a processed SimulScanTemplateGroup.\n\n\n##Public Methods\n###getRegions()\nReturns a list of SimulScanRegion objects that represents a collection of processed regions that are contained within the group\n\n**Returns:**\n\nList of [SimulScanRegion](#api-SimulScanRegion) objects.\n\n\n###getData()\nReturns additional processed data as an object of type Object\n\n**Specified by:**\n\ngetData in class SimulScanElement\n\n**Returns:**\n\njava.lang.Object"},{"key":"api-SimulScanManager","name":"SimulScanManager","md":"#SimulScanManager\n\nThis is the primary object to access the SimulScan feature.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements EMDKListener,\n\t\tSimulScanDataEventListerner, SimulScanStatusEventListerner {\n\n\t  \tprotected void onCreate(Bundle savedInstanceState) {\n \t\t\t//..\n   \t\t EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);\n\t\t}\n\n\t\tpublic void onOpened(EMDKManager emdkManager) {\n\t\t\tthis.emdkManager = emdkManager;\n\t \t}\n\n\t\t//...\n\t\tsimulscanManager = (SimulScanManager)this.emdkManager.getInstance(FEATURE_TYPE.SimulScan);\n\t  //...\n\t  List<SimulScanReaderInfo> readerInfoList = simulscanManager.getSupportedDevicesInfo();\n\t  SimulScanReader reader = simulscanManager.getDevice(readerInfoList.get(0));\n\t  reader.addDataListener(callbackObj);\n\t  reader.addStatusListener(callbackObj);\n\t  reader.enable();\n\t  // set template before calling read\n\t  reader.read();\n\t  \n\t  //...\n\t  reader.cancelRead();\n\t  \n\t  //...\n\t  reader.disable();\n\t  \n\t  //..\n\t  \n\t  EMDKManager.release(FEATURE_TYPE.SimulScan);\n\t  \n\t}\n\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getSupportedDevicesInfo()\nReturns list of supported reader devices information.\n\n**Returns:**\n\nReturns list of supported reader devices information ([SimulScanReaderInfo](#api-SimulScanReaderInfo)).\n\n###getDevice([SimulScanReaderInfo](#api-SimulScanReaderInfo) simulscanReaderInfo) throws [SimulScanException](#api-SimulScanException)\nThis method returns the reader object based on the input SimulScanReaderInfo object.\n\n**Parameters:**\n\n[simulscanReaderInfo](#api-SimulScanReaderInfo) - The [SimulScanReadInfo](#api-SimulScanReaderInfo) specifies which reader the application wants.\n\n**Returns:**\n\n[SimulScanReader](#api-SimulScanReader) - SimulScanReader if the input is valid. Otherwise null is returned.\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs.\n\n\n###getDevice(SimulScanManager.DeviceIdentifier deviceIdentifier) throws [SimulScanException](#api-SimulScanException)\nThis method returns the reader object based on device identifier specified.\n\n**Parameters:**\n\n[deviceIdentifier](#api-SimulScanManager?SimulScanManager.DeviceIdentifier) - The device identifier specifies which reader the application wants.\n\n**Returns:**\n\n[SimulScanReader](#api-SimulScanReader) - SimulScanReader if the device identifier specified is valid on the device. Otherwise null is returned.\n\n**Throws:**\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs.\n\n##Public Enums\n###SimulScanManager.DeviceIdentifier\n\n**Values:**\n\n**DEFAULT** - The scanner device is selected based on the template.\n\n**INTERNAL_CAMERA1** - Use the internal camera.\n\n**INTERNAL_IMAGER1** - Use the internal imager.\n\n\n###SimulScanManager.SimulScanResults\nDefines all the error codes the SimulScan API returns.\n\n**Values:**\n\n**SUCCESS** - Success.\n\n**ALREADY_SCANNING** - A scan operation is already in progress.\n\n**ALREADY_STOPPED_SCANNING** - The reader has already stopped scanning.\n\n**READER_ALREADY_ENABLED** - Reader is already enabled.\n\n**READER_IN_USE** - Another reader is already enabled and in use. Only one reader can be enabled at a time.\n\n**READER_ALREADY_DISABLED** - The reader is already disabled.\n\n**FEATURE_NOT_SUPPORTED** - The feature is not supported completely or for specified input.\n\n**READER_NOT_ENABLED** - The selected reader is not enabled.\n\n**INVALID_OBJECT** - The reader has been released and is not valid.\n\n**FAILED_TO_LOAD_TEMPLATE** - Failed to load template.\n\n**FAILED_TO_SET_TEMPLATE** - Failed to set template.\n\n**TEMPLATE_NOT_SET** - Failed to set template.\n\n**INVALID_VALUE** - The value passed is not valid.\n\n**NO_DATA_LISTENER** - Data listener is not set\n\n**EMDK_NOT_OPENED** - EMDK is not opened\n\n**READER_INIT_FAILED** - Reader initialization failed.\n\n**READER_DEINIT_FAILED** - Reader initialization failed.\n\n**UNDEFINED** - Undefined\n\n**FAILURE** - Failure"},{"key":"api-SimulScanManagerHelper","name":"SimulScanManagerHelper","md":"#SimulScanManagerHelper\n\n\n##Constructors\n###SimulScanManagerHelper()\n\n\n##Public Methods\n###getInstance(android.content.Context context, com.symbol.emdk.EMDKServiceConnection emdkServiceConnection)\n\n\n**Returns:**\n\n[SimulScanManager](#api-SimulScanManager)\n\n\n###release([SimulScanManager](#api-SimulScanManager) simulscanmanager)\n\n**Returns:**\n\nvoid"},{"key":"api-SimulScanMultiTemplate","name":"SimulScanMultiTemplate","md":"#SimulScanMultiTemplate\n\nThe SimulScanMultiTemplate class contains an entire parsed XML template file. It may consist of many individual Template.\n\n\n##Constructors\n###SimulScanMultiTemplate(SimulScanManager simulScanManager, java.lang.String xmlString) throws [SimulScanException](#api-SimulScanException)\nCreate SimulScanMultiTemplate object from XML string.\n\n**Parameters:**\n\nxmlString - XML string\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs while creating SimulScanMultiTemplate.\n\n\n###SimulScanMultiTemplate(SimulScanManager simulScanManager, android.net.Uri fileUri) throws [SimulScanException](#api-SimulScanException)\nCreate SimulScanMultiTemplate object from URI to template XML.\n\n**Parameters:**\n\nfileUri - URI to the template to be loaded\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs while creating SimulScanMultiTemplate\n\n\n##Public Methods\n###getTemplateName()\nReturns the friendly name of the MultiTemplate object.\n\n**Returns:**\n\njava.lang.String"},{"key":"api-SimulScanReader-DataListerner","name":"SimulScanReader.DataListerner","md":"#SimulScanReader.DataListerner\n\nAn interface for notifying client applications when the scan data is available.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements DataListerner\n  \t  .. .. ..\n\n\n##Public Methods\n###onSimulScanData(SimulScanData form)\nThis is the callback method upon data availability.\n\n**Parameters:**\n\nform - [SimulScanData](#api-SimulScanData) object.\n\n**Returns:**\n\nvoid\n\n"},{"key":"api-SimulScanReader-StatusListerner","name":"SimulScanReader.StatusListerner","md":"#SimulScanReader.StatusListerner\n\nAn interface for notifying client applications to notify scan events.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements StatusListerner\n  \t  .. .. ..\n\n\n##Public Methods\n###onSimulScanStatus([SimulScanStatusData](#api-SimulScanStatusData) status)\nThis is the callback method upon scan status event occurs.\n\n**Parameters:**\n\nstatus - [SimulScanStatusData](#api-SimulScanStatusData) object.\n\n**Returns:**\n\nvoid\n\n"},{"key":"api-SimulScanReader","name":"SimulScanReader","md":"#SimulScanReader\n\nSimulScanReader class will represent and provides access to the physical Reader device.\n\n**Example Usage:**\n\n\t:::java\n\tList<SimulScanReaderInfo> readerInfoList = simulscanManager.getSupportedDevicesInfo();\n    SimulScanReader reader = simulscanManager.getDevice(readerInfoList.get(0));\n    reader.addDataListener(callbackObj);\n    reader.addStatusListener(callbackObj);\n    reader.enable();\n    // Set template before calling read\n    reader.read();\n    reader.cancelRead();\n    reader.disable();\n\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getReaderInfo()\nReturns information about the reader device.\n\n**Returns:**\n\nReturns the [SimulScanReaderInfo](#api-SimulScanReaderInfo) object.\n\n\n###isReadPending()\nAnother read() cannot be submitted while a read is pending.\n\n**Returns:**\n\nboolean Returns true if a read is pending.\n\n\n###enable() throws [SimulScanException](#api-SimulScanException)\nEnables the reader hardware. This method does not make the reader to scan. If another reader is already enabled, this will throw a SimulScanException. You must call disable() when you are done, otherwise all readers will remain locked and will be unavailable for this and any other application that uses SimulScan.\n\n**Example Usage:**\n\n\t:::java\n\treader.enable();\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - The exception will thrown if the reader enable fails.\n\n\n###disable() throws [SimulScanException](#api-SimulScanException)\nDisables the reader hardware. Any pending scanned data will be lost. This method releases the reader hardware resources so that other readers can be enabled. You must call this as soon as you're done with the scanning. Other applications will not be able to access SimulScan related functions till this function is called.\n\n**Example Usage:**\n\n\t:::java\n\treader.disable();\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - The exception will thrown if the reader disable fails.\n\n\n###isEnabled() throws SimulScanException\nReturns reader enabled state\n\n**Returns:**\n\nboolean Returns true if reader is enabled.\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs.\n\n\n###getConfig() throws [SimulScanException](#api-SimulScanException)\nGets the current configuration settings for this reader device. The reader must be enabled before the calling this function. If modifications are made to the returned SimulScanConfig object, the Reader.setConfig(SimulScanConfig) must be called to take effect.\n\n**Example Usage:**\n\n\t:::java\n\treader.enable();\n \tSimulScanConfig config = reader.getConfig();\n\n**Returns:**\n\n[SimulScanConfig](#api-SimulScanConfig) - The valid reader configuration object will be returned on successful get.\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs.\n\n\n###setConfig(SimulScanConfig config) throws [SimulScanException](#api-SimulScanException)\nChanges the settings for this reader device. The reader must be enabled and must not have a read pending to call this method. This method skips the unsupported parameters and continues with setting the supported values.\n\n**Example Usage:**\n\n\t:::java\n\tSimulScanMultiTemplate template1 = new SimulScanMultiTemplate(fileUri);//fileUri points to the template\n \tSimulScanReader reader = simulscanManager.getDevice(template1.deviceIdentifier);\n \treader.enable();\n \tSimulScanConfig config = reader.getConfig();\n \tconfig.multiTemplate = template1;\n \treader.setConfig(config);\n\n**Parameters:**\n\n[SimulScanConfig](#api-SimulScanConfig) config - The Parameters to use for this reader device.\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs while setting the parameters.\n\n\n###read() throws [SimulScanException](#api-SimulScanException)\nThis method starts a SimulScan scan. If a read() is submitted while another read is pending, the method call will fail. The read request can be cancelled by issuing a cancelRead(). It is recommended to check whether a read is pending by calling isReadPending() before submitting a read().\n\n**Example Usage:**\n\n\t:::java\n\treader.read();\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - Exception will be throw if any error occurs during the read request.\n\n\n###cancelRead() throws [SimulScanException](#api-SimulScanException)\nThis cancels any pending read() calls.\n\n**Example Usage:**\n\n\t:::java\n\treader.cancelRead();\n\n**Returns:**\n\nvoid\n\n**Throws:**\n\n[SimulScanException](#api-SimulScanException) - The exception will thrown if error occurs during the cancelRead request.\n\n\n###addDataListener([SimulScanReader.DataListerner](#api-SimulScanReader-DataListerner) dataListener) \nThe client can register to get data notification via callbacks.\n\n**Parameters:**\n\ndataListener - The [DataListerner](#api-SimulScanReader-DataListerner) callabck object.\n\n**Returns:**\n\nvoid\n\n\n###removeDataListener([SimulScanReader.DataListerner](#api-SimulScanReader-DataListerner) dataListener)\nThe client can unregister to not get data notification via callbacks.\n\n**Parameters:**\n\ndataListener - The [DataListerner](#api-SimulScanReader-DataListerner) callback object to be unregistered.\n\n**Returns:**\n\nvoid\n\n\n###addStatusListener([SimulScanReader.StatusListerner](#api-SimulScanReader-StatusListerner) statusListener)\nThe client can register to get status notification via callbacks.\n\n**Parameters:**\n\nstatusListener - The [StatusListener](#api-SimulScanReader-StatusListerner) callback object.\n\n**Returns:**\n\nvoid \n\n\n###removeStatusListener([SimulScanReader.StatusListerner](#api-SimulScanReader-StatusListerner) statusListener)\nThe client can unregister to not get status notification via callbacks.\n\n**Parameters:**\n\nstatusListener - The [StatusListerner](#api-SimulScanReader-StatusListerner) callback object to be unregistered.\n\n**Returns:**\n\nvoid\n"},{"key":"api-SimulScanReaderInfo","name":"SimulScanReaderInfo","md":"#SimulScanReaderInfo\n\nSimulScanReaderInfo provides information of the reader device.\n\n**Example Usage:**\n\n\t:::java\n\treaderInfo.getFriendlyName();\n\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getFriendlyName()\nReturns the friendly name of the Device.\n\n**Example Usage:**\n\n\t:::java\n\tString name = readerInfo.getFriendlyName();\n\n**Returns:**\n\nString Returns the friendly name.\n\n###getDeviceType()\nReturns the reader device type.\n\n**Example Usage:**\n\n\t:::java\n\tSimulScanDeviceType deviceType = readerInfo.getDeviceType();\n\n**Returns:**\n\n[SimulScanDeviceType](#api-SimulScanReaderInfo?SimulScanReaderInfo.SimulScanDeviceType) Returns the SimulScanDeviceType.\n\n\n##Public Enums\n###SimulScanReaderInfo.SimulScanDeviceType\n\n**Values:**\n\n**CAMERA** - The Scanner device class is camera.\n\n**IMAGER** - The scanner device class is imager.\n\n**UNDEFINED** - The scanner device class is not defined."},{"key":"api-SimulScanRegion","name":"SimulScanRegion","md":"#SimulScanRegion\n\nThe SimulScanRegion class represents a processed SimulScanTemplateRegion.\n\n\n##Public Methods\n###getRegionType()\nReturns the processed data type of this region.\n\n**Returns:**\n\n[RegionType](#api-SimulScanRegion?SimulScanRegion.RegionType)\n\n\n###getImage()\nReturns the captured region image.\n\n**Returns:**\n\nandroid.graphics.YuvImage\n\n\n###getAbsoluteConfidence()\nReturns the absolute confidence of OCR results.\n\n**Returns:**\n\nint\n\n\n###getRelativeConfidence()\nReturns the relative confidence of OCR results\n\n**Returns:**\n\nint\n\n\n###getData()\nReturns the processed data. The type of the returned object will depend on the RegionType as described below,\n\n\n**Data Type**\n\nOCR - String\n\nOMR - Integer\n\nBARCODE - String\n\nPICTURE - byte[]\n\n\n**Specified by:**\n\ngetData in class [SimulScanElement](#api-SimulScanElement)\n\n\n**Returns:**\n\njava.lang.Object\n\n##Public Enums\n###SimulScanRegion.RegionType\n\n**Values:**\n\n**OCR** - Data type is OCR.\n\n**OMR** - Data type is OMR.\n\n**BARCODE** - Data type is BARCODE.\n\n**PICTURE** - Data type is PICTURE.\n\n**UNKNOWN** - Data type is UNKNOWN.\n"},{"key":"api-SimulScanStatusData-ExtendedInfo","name":"SimulScanStatusData.ExtendedInfo","md":"#SimulScanStatusData.ExtendedInfo\n\nThis class allows access to extended status information. It is usually used to pass additional error information.\n\n\n##Constructors\n###ExtendedInfo()\n\n\n##Public Methods\n###getExtendedStatus()\n\n**Returns:**\n\n[SimulScanStatusData.ExtendedStatus](#api-SimulScanStatusData?SimulScanStatusData.ExtendedStatus)\n\n\n###getExtendedStatusDescription()\n\n**Returns:**\n\njava.lang.String\n"},{"key":"api-SimulScanStatusData","name":"SimulScanStatusData","md":"#SimulScanStatusData\n\nSimulScanStatusData class provides access to reader status.\n\n**Example Usage:**\n\n\t:::java\n\tSimulScanStatusData.getState();\n\n\n**Version:**\n\n1.0\n\n##Constructors\n###SimulScanStatusData()\n\n\n##Public Fields\n###extendedInfo\n\n**Type:**\n\n[SimulScanStatusData.ExtendedInfo](#api-SimulScanStatusData-ExtendedInfo)\n\n\n##Public Methods\n###getState()\nReturns the the current status.\n\n**Returns:**\n\n[SimulScanStatus](#api-SimulScanStatusData?SimulScanStatusData.SimulScanStatus)\n\n\n###getFriendlyName()\nReturns the friendly name of the Reader from which the SimulScanStatusData object was from.\n\n**Returns:**\n\njava.lang.String\n\n\n\n##Public Enums\n###SimulScanStatusData.ExtendedStatus\n\n**Values:**\n\n**NONE** - No extended error.\n\n**PROCESS_TIMEOUT** - Timeout occurred during processing.\n\n**IDENTIFICATION_TIMEOUT** - Timeout occurred during identification.\n\n\n###SimulScanStatusData.SimulScanStatus\n\n**Values:**\n\n**DISABLED** - Disabled called successfully on reader.\n\n**ENABLED** - Enabled reader successfully.\n\n**SCANNING** - Successfully started scanning.\n\n**IDLE** - Finished scanning.\n\n**ERROR** - Error occurred.\n\n**UNKNOWN** - Unknown status.\n"},{"key":"api-SimulScanTemplate","name":"SimulScanTemplate","md":"#SimulScanTemplate\n\nThe Template class represents the XML template passed into the SimulScanEngine. All of the recognizable tags and attributes are placed into this class.\n\n\n##Public Methods\n###getElements()\nReturns a list of SimulScanTemplateElements that are contained in this template.\n\n**Returns:**\n\na list of [SimulScanTemplateElement](#api-SimulScanTemplateElement) objects Returns true if reader is enabled.\n\n\n###getHeight()\nReturns the height of the template.\n\n**Returns:**\n\nint The template's height.\n\n\n###getWidth()\nReturns the width of the template.\n\n**Returns:**\n\nint The template's width.\n\n\n###getId()\nReturns the number of the template.\n\n**Returns:**\n\nint The template's number.\n\n\n###getName()\nReturns the friendly name of the template.\n\n**Returns:**\n\nString The template's name."},{"key":"api-SimulScanTemplateElement","name":"SimulScanTemplateElement","md":"#SimulScanTemplateElement\n\nThe TemplateElement class represents elements nested directly under the tag in an XML template file.\n\n\n##Public Methods\n###getName()\nReturns the friendly name of the element.\n\n**Returns:**\n\nString The element's name.\n\n\n###getRegionNumber()\nReturns the region number of the element.\n\n**Returns:**\n\nint The element's region number."},{"key":"api-SimulScanTemplateGroup","name":"SimulScanTemplateGroup","md":"#SimulScanTemplateGroup\n\nThe SimulScanTemplateGroup class is a grouping of multiple SimulScanTemplateRegion items.\n\n\n##Public Methods\n###getTemplateRegions()\nReturns a list of SimulScanTemplateRegion objects that represents a collection of template regions that are contained within this SimulScanTemplateGroup.\n\n**Returns:**\n\nList of [SimulScanTemplateRegion](#api-SimulScanTemplateRegion) objects."},{"key":"api-SimulScanTemplateRegion","name":"SimulScanTemplateRegion","md":"#SimulScanTemplateRegion\n\nThe SimulScanTemplateRegion class represents a particular region in a Template.\n\n\n##Public Methods\n###getHeight()\nReturns the height of this template region.\n\n**Returns:**\n\nint The template region's height.\n\n\n###getWidth()\nReturns the width of this template region\n\n**Returns:**\n\nint The template region's width\n\n\n###getRegionType()\nReturns the type of data contained within this region.\n\n**Returns:**\n\n[RegionType](#api-SimulScanRegion?SimulScanRegion.RegionType) - The RegionType.\n\n\n###getX()\nReturns the X coordinate of this template region.\n\n**Returns:**\n\nint The X coordinate of the template region.\n\n\n###getY()\nReturns the Y coordinate of this template region.\n\n**returns:**\n\nint The Y coordinate of the template region."},{"key":"api-StatusData","name":"StatusData","md":"#StatusData\nStatusData class provides access to scanner status.\n\n**Example Usage:**\n\n    :::java\n    statusData.getState();\n\n**Version:**\n\n1.0\n\n##Public Methods\n###getFriendlyName()\nReturns the friendly name of scanner for which the status data is returned.\n\n**Returns:**\n\njava.lang.String - Returns scanner index to the supported devices list.\n\n###getState()\nReturns the scan event state.\n\n**Returns:**\n\ncom.symbol.emdk.barcode.[StatusData.ScannerStates](#api-StatusData?StatusData.ScannerStates)\n\n##Public Enums\n###StatusData.ScannerStates\nDefines the different states of the barcode scanner.\n\n**Values:**\n\n**IDLE** - Scanner is enabled but no reads are pending.\n\n**WAITING** - Scanner has issued reads request and is waiting for trigger event. \n\n**SCANNING** - Scanner beam is on and it is acquiring data.\n\n**DISABLED** - Scanner is not enabled.\n\n**ERROR** - An error has occurred.\n"},{"key":"api-TagData","name":"TagData","md":"#TagData\n\nTagData class provides to get the TLV raw data as per EMV specification and also its parsed tag, length and value format.\n\n\n**Version:**\n\n1.0\n\n\n##Constructor\nTagData(java.lang.String tlvString) \n\n##Public Methods\n###getTlvString()\nReturns the TLV (Tag-Length-Value) data string as per EMV specification.\n\n**Returns:**\n\njava.lang.String"},{"key":"api-VersionManager","name":"VersionManager","md":"#VersionManager\nVersion information can be captured from this class.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tVersionManager versionManager = (VersionManager)emdkmanager.getInstance(FEATURE_TYPE.VERSION);\n\t}\n\n**Version:**\n\n1.0\n\n##Public Methods\n\n###getVersion(VersionManager.VERSION_TYPE versionKey)\n\nGets the version of the specified [VersionManager.VERSION_TYPE](#api-VersionManager?VERSION_TYPE)\n\n**Example Usage:**\n\n\t:::java\n\tversionManager.getVersion(VERSION_TYPE.EMDK)\n\n**Parameters:**\n\n**versionKey** - [VersionManager.VERSION_TYPE](#api-VersionManager?VERSION_TYPE)\n\n**Returns:**\n\njava.lang.String - Version number\n\n##Public Enums\n\n###VERSION_TYPE\nAll the version keys for [VersionManager.getVersion(VersionManager.VERSION_TYPE)](#api-VersionManager?getVersion(VersionManager.VERSION_TYPE)) are enumerated here.\n\n**Example Usage:**\n\n\t:::java\n\tVERSION_TYPE.EMDK\n\n**Values:**\n\n* **EMDK(\"EMDK\")** - EMDK version\n\n* **MX(\"MX\")** - MX framework version\n\n* **BARCODE(\"BARCODE\")** - Barcode Scanner Framework version.\n"},{"key":"guide-about","name":" About EMDK For Android","md":"# About EMDK For Android\n\n## Overview\nThe EMDK for Android provides developers with a comprehensive set of tools to easily create powerful line of business applications for enterprise mobile computing devices and is designed for use with Google's Android SDK and Android Development Tools (ADT). The EMDK for Android includes class libraries, sample applications with source code, as well as all of the associated documentation to help your applications take full advantage of what our devices have to offer.\n\nIt also includes an exclusive Profile Manager Technology within the your IDE, providing a GUI based development tool. This allows you to write fewer lines of code resulting in reduced development time, effort and errors.\n\n## Requirements\nThe following software must be installed prior to using the EMDK for Android.\n\n* Microsoft Windows 7 (32-bit and 64-bit)  or Microsoft&copy; Windows 8 (32-bit and 64-bit) or Microsoft&copy; Windows 8.1 (32-bit and 64-bit)\n* Java Development Kit (JDK) v7u45 or higher\n* Android Developer Tools (ADT) v22.3.0-887826 or higher\n\n###Android Studio\nSince Google released Android Studio, the ADT bundle is no longer available for download. You can still however use the ADT plugin for Eclipse with full EMDK For Android integration.  Users of Android Studio now have full access to the EMDK features as well. Check the [Setup Guide](#guide-setup) for more details on how to use the EMDK in your preferred IDE.\n\n## Devices Supported\nAlthough EMDK for Android has been designed to work with all Symbol mobile computers running Android, the following devices have been used for validation:\n\n* MC32 - OS Update image v00002 or higher (JellyBean)\n* MC40 - OS Update image v02.08.0520 or higher (JellyBean)\n* MC67 - OS Update image v01.28.14 or higher (JellyBean)\n* TC55 - OS Update image v01.74.00 or higher (JellyBean)\n* TC55 - KitKat\n* TC70 - OS Update image v11.24.14 or higher (KitKat)\n* TC75 - KitKat\n\n## What's New\n\n**EMDK for Android v3.1 Update 1**\n\n* New Profile Manager Features\n\t* [Audio Manager](#guide-profiles-audio)-  allows you to manage enhanced audio volume control configurations\n\t* [Battery Manager](#guide-profiles-audio)- allows the developer to modify that Decommission Threshold from its factory setting\n\t* [Component Manager](#guide-profiles-audio)- allows you to manage the state of Components, such as a devices Ethernet Port\n\t* [DHCP Manager](#guide-profiles-audio)- allows you to control various DHCP configuration options.\n\t* [KeyMap Manager](#guide-profiles-audio)- allows you to remap functionality of keys.\n* Smart Cradle APIs for MC18\n* NFC APIs\n* Payment APIs\n* Dex APIs\n\n**EMDK for Android v3.1**\n\n* TC55 KitKat and TC75 KitKat are now supported\n* [Android Studio](#guide-setupAndroidStudio) - EMDK for Android is now fully supported in Android Studio\n* [SimulScan APIs](#guide-reference-EMDKList?SimulScan%20APIs) - data capture solution to extract critical data from documents\n* [Scan and Pair APIs](#guide-reference-EMDKList?ScanAndPair%20APIs) - easily pair to a bluetooth device through barcode scanning\n* [Continuous Trigger mode](#api-ScannerConfig?ScannerConfig.AimType) - new aim type supported for continuous trigger\n* [Name Value Pair API](#api-ProfileManager?CreateNameValuePair%28java.lang.String%2520emdkName%2C%2520java.lang.String%2520paramName%2C%2520java.lang.String%2520paramValue%29) - new method for ProfileManager\n* [Extended EMDK Results Enum](#api-EMDKResults?EMDKResults.%E2%80%8BEXTENDED_STATUS_CODE) - Further details available when processing profiles\n* New Profile Manager Features\n\t* [Browser Manager](#guide-profiles-browser)- configures web browser behavior\n\t* [Camera Manager](#guide-profiles-camera)- control access to the cameras in the device\n\t* [Cellular Manager](#guide-profiles-cellular)- configure options of the  cellular radio on your device\n\t* [DevAdmin Manager](#guide-profiles-devadmin)-  manage configuration settings on the device\n\t* [Display Manager](#guide-profiles-display)-  control the screen timeout value to conserve power\n\t* [Encrypt Manager](#guide-profiles-encrypt)-  set encryption policies\n\t* [Powerkey Manager](#guide-profiles-powerkey)-  control which options appear on the power menu\n\t* [SD Card Manager](#guide-profiles-sdcard)-  manage the use of the devices SD card\n\t* [Threat Manager](#guide-profiles-threat)-  Control what security threats a device actively monitors\n* Support for Bluetooth scanners (RS507) in [Barcode API's](#api-BarcodeInterfaceConfig) \n\n**EMDK For Android v3.0 Update 1**\n\n* TC70 Support - Our first KitKat supported device\n* EMDK for Android Device Runtime Update v3.0.4\n* [Help Update](#guide-abouthelp) - Instructions for updating your local documentation\n\n**EMDK For Android v3.0**\n\n* Native [Java Barcode Scanning APIs](#guide-reference-EMDKList)\n* New [EMDK Profiles](#guide-profiles-usingwizard) features:\n\t* [Settings Manager](#guide-profiles-settings) - turn on/off ability to invoke Enterprise Reset in settings UI\n\t* [Touch Manager](#guide-profiles-touch) - set the device's touch mode\n\t* [UI Manager](#guide-profiles-ui) - configure clipboard behavior\n\t* [USB Manager](#guide-profiles-usb) - manage USB configurations behavior\n\t* [Wireless Manager](#guide-profiles-wireless) - enable or disable Bluetooth\n* Updated [EMDK Profiles](#guide-profiles-usingwizard) features:\n\t* [Access Manager](#guide-profiles-access) - new Whitelist features\n\t* [App Manager](#guide-profiles-app) - new Dynamic Protected List ability\n\t* [Clock](#guide-profiles-clock) - new NTP server synchronization\n* New Tutorials\n\t* [Barcode Scanning API (Basic)](#guide-tutorial-tutBasicScanningAPI)\n\t* [Barcode Scanning API (Advanced)](#guide-tutorial-tutAdvancedScanningAPI)\n\t* [Invoke Enterprise Reset in Settings UI](#guide-tutorial-tutMxSettingsManager)\n\t* [Specify Touch Mode using Mx Touch Manager](#guide-tutorial-tutMxTouchManager)\n\t* [Configure Clipboard using Mx UI Manager](#guide-tutorial-tutMxUIManager)\n\t* [Manage USB Configurations](#guide-tutorial-tutMxUSBManager)\n\t* [Configure Bluetooth using Mx Wireless Manager](#guide-tutorial-tutMxWirelessManager)\n\n## Components\n\n### Profile Manager\nThe EMDK's exclusive [Profile Manager](#guide-profiles-usingwizard) Technology is an additional advantage for developers giving you a GUI based development tool built on our open framework. This allows you to write fewer lines of code resulting in reduced development time, effort and errors. This innovative feature not only gives you easy access to critical functions such as bar code scanning and transaction processing via a magnetic stripe reader (MSR) but also functionality not available in Google's Android SDK.   \n### EMDK Device Runtime\nIn order for your application to use the EMDK For Android, you will need to install the EMDK Device Runtime on each device. This runtime is included with the EMDK For Android installation. Check the [Programmers Guide](#guide-tutorial-tutdatacaptureprofile) for instructions. In the future the EMDK Services will be included with the default operating system for the device.\n\n### Samples & Programmer's Guide\nThere are sample projects that are included as part of the EMDK For Android installation. You can import the project into Eclipse and run on your device. Look at the [Sample Guide](#guide-sample-sampledatacaptureprofile) for more details on using these samples. You can also reference the [Programmers Guide](#guide-tutorial-tutdatacaptureprofile) for a complete walk-through of building your first EMDK For Android application.\n\n### Java APIs\nThe EMDK for Android offers access to the device's Barcode capabilities through [traditional native Java Barcode APIs](#guide-reference-EMDKList). Be sure to look at the [Barcode Scanning API tutorial.](#guide-tutorial-tutBasicScanningAPI)\n\n### Intent APIs\nThe EMDK for Android will continue to support the [DataCapture](#guide-reference-refdatacaptureintent) and [Battery Intent](#guide-reference-refbatteryintent) APIs that were previously available on individual device types. \n\n<a name=\"faqs\"></a>\n\n## Frequently Asked Questions\n**Q: Where can I download a copy of the EMDK for Android?**\n\nA: The EMDK for Android can be downloaded from Support Portal [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Developer+Kits+and+Software+Tools/Mobile%20Computer%20Software%20and%20Developer%20Tools_US-EN)\n\n**Q: Is there a cost for the EMDK for Android?**\n\nA: No, EMDK for Android is available for free and can be downloaded from Support Portal [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Developer+Kits+and+Software+Tools/Mobile%20Computer%20Software%20and%20Developer%20Tools_US-EN)\n\n**Q: Which device does the EMDK for Android support and which operating systems?**\n\nA: The EMDK for Android supports the following devices only:\n\n* MC32 (Jellybean)\n* MC40 (Jellybean)\n* MC67 (Jellybean)\n* TC55 (Jellybean)\n* TC70 (Kit Kat)\n\n**Q: Which desktop operating systems are supported by the EMDK for Android support?**\n\nA: The EMDK for Android  is supported on Windows 7, Windows 8 and Windows 8.1.\n\n**Q: Can the EMDK for Android be installed on Windows XP?**\n\nA: No, the EMDK for Android does not support Windows XP and there are no current plans to support this operating system.\n\n**Q: Can the EMDK for Android be installed on a MAC?**\n\nA: No, the EMDK for Android does not support MAC OS. MAC support will be considered in a future release of the EMDK for Android. However you can use virtualization solutions such as VMware fusion to run one of the supported Windows operating systems on a MAC.\n\n**Q: Can the EMDK for Android be used with Android Studio?**\n\nA: You may be able to import existing projects and build successfully with Android Studio. However full integration, like Profile Manager, will not work and the EMDK for Android at this time does not support Android Studio. Official support for Android Studio will be made available in a future release of the EMDK for Android.\n\n**Q: What documentation is available for EMDK for Android and where can I obtain it?**\n\nA: Besides this self contained set of documentation, additional and/or updated documentation for the EMDK can be found on the LaunchPad here:\n\n* [EMDK Landing page](https://developer.motorolasolutions.com/community/android/emdk) \n* [Tutorials](https://developer.motorolasolutions.com/community/android/emdk/tutorials) \n* [Samples](https://developer.motorolasolutions.com/community/android/emdk/samples) \n* [API Reference](https://developer.motorolasolutions.com/community/android/emdk/reference) \n* [Profile Manager](https://developer.motorolasolutions.com/community/android/emdk/profiles)\n\n**Q: Will my app run across the entire MSI android portfolio?**\n\nA: EMDK for Android is designed to be compatible with all Symbol devices, Android OS and BSPs. However, the compatibility of your application will depend on not just the EMDK architecture, but also on Google's SDK. See above for what versions were validated.\n\n**Q: Can the EMDK for Android be used as a staging tool?**\n\nA: The EMDK for Android is targeted for developers and the development of applications. Customers may develop an application which configures aspects of a device however the EMDK is not a staging tool.\n\n**Q: I understand the EMDK for Android offers a feature called Profile Manager, what is this?**\n\nA: The Profile Manager is provided as an Eclipse plug-in that offers developers a GUI development tool. The tool creates a \"profile\" which is comprised of \"profile features\" defined by the developer for value-add capabilities such as Barcode Scanning & MSR as well as device configuration features like Clock, Power, Certificates and Application Access. These features can then be invoked and modified within the applications through the Profile Manager API.\n\n**Q: What are the benefits of the Profile Manager GUI and API?**\n\nA: The Profile Manager GUI and APIs allow you to, quickly and easily leverage device value-add features. The user interface makes it easy for developers to pick and choose the features they need, eliminating the need to code these options. With the Profile Manager API, developers can invoke and modify features as needed within their application. This gives you the fine level of control you need while reducing development time, effort and errors.\n\n**Q: Does the EMDK for Android offer APIs for direct control of device value adds?**\n\nA: Yes, the since version 3.0 of EMDK for Android, traditional Java APIs have been made available to provide Barcode scanning abilities. Other device value adds may be provided using this mechanism in the future.\n\n**Q: I understand that the EMDK for Android supports Intents; what is an Intent?**\n\nA: An Intent is a standard Android inter-application messaging mechanism. For more information please see Google's documentation on Android Intent; http://developer.android.com/reference/android/content/Intent.html\n\n**Q: How does Mobility Extensions (MX) relate to the EMDK for Android?**\n\nA: The EMDK for Android provides developers with a programmatic interface to the MX value-add features on our devices. Future releases of the EMDK for Android will offer additional features as we continue to expand MX capabilities.\n\n**Q: I have started developed of my application with the EMDK for Android, what are the features of the EMDK and what are my alternatives?**\n\nA: The EMDK for Android is designed to expose MX value-add features and provides developers with a GUI tool to help reduce the development effort. Many of the device specific features such as Barcode scanning and MSR will be provided as part of the EMDK for Android. However standard Android APIs from Google such as Audio and Keyboard will not.\n \nThe intent of the EMDK is to provide developers with commonly required programmatic features for Line of Business applications. The EMDK for Android is meant to be used alongside the Google Android SDK to provide developers a comprehensive set of features without having to have a signed application. Below is a list of key features and there availability within the EMDK for Android and Google's Android SDK. This is meant to be used as a reference guide to provide clarity on when to use the EMDK versus the Android SDK. \n\n\n<table class=\"table\">\n<tr>\n<th>Feature</th>\n<th>EMDK for Android</th>\n<th>Google Android SDK</th>\n</tr>\n<tr>\n<td>Barcode / Scanning</td>\n<td> Data Capture Intent <br/>Barcode Profile<br/>Barcode API</td>\n<td></td>\n</tr>\n<tr>\n<td>Image Capture</td>\n<td></td>\n<td>android.hardware.camera</td>\n</tr>\n<tr>\n<td>MagStripe Reader</td>\n<td>Data Capture Intent<br/>MSR Profile</td>\n<td></td>\n</tr>\n<tr>\n<td>Wi-Fi Settings</td>\n<td>Wi-Fi Profile</td>\n<td>android.net.wifi.WifiManager <br/>android.net.wifi.p2p.WifiP2pManager</td>\n</tr>\n<tr>\n<td>Fusion Settings</td>\n<td>Wi-Fi Profile</td>\n<td></td>\n</tr>\n<tr>\n<td>Battery Mgt (Symbol.ResCoord)</td>\n<td>Battery Intent</td>\n<td>android.os.BatteryManager</td>\n</tr>\n<tr>\n<td>Keyboard (Symbol.Keyboard)</td>\n<td></td>\n<td>android.inputmethodservice.Keyboard.Key</td>\n</tr>\n<tr>\n<td>Battery Management</td>\n<td>Battery Intent</td>\n<td>android.os.BatteryManager</td>\n</tr>\n<tr>\n<td>GPRS (APN) Settings</td>\n<td>GPRS Profile</td>\n<td></td>\n</tr>\n<tr>\n<td>File management</td>\n<td>Application Mgr Profile</td>\n<td>java.io.File</td>\n</tr>\n<tr>\n<td>Silent APK Install</td>\n<td>Application Mgr Profile</td>\n<td></td>\n</tr>\n<tr>\n<td>Application White Listing</td>\n<td>Access Mgr Profile</td>\n<td></td>\n</tr>\n<tr>\n<td>Display Attributes</td>\n<td>Touch Profile Manager</td>\n<td>android.view.Display</td>\n</tr>\n<tr>\n<td>Audio Settings</td>\n<td></td>\n<td>android.media.AudioManager</td>\n</tr>\n<tr>\n<td>Sensor (Symbol.Sensor)</td>\n<td></td>\n<td>android.hardware.SensorManager</td>\n</tr>\n<tr>\n<td>Bluetooth Settings</td>\n<td>Wireless Profile Manager</td>\n<td>android.BluetoothAdapter</td>\n</tr>\n<tr>\n<td>SQL Database Management</td>\n<td></td>\n<td>android.database.sqlite</td>\n</tr>\n<tr>\n<td>NFC</td>\n<td></td>\n<td>android.nfc</td>\n</tr>\n<tr>\n<td>Notifications</td>\n<td></td>\n<td>android.service.notification</td>\n</tr>\n<tr>\n<td>Printing</td>\n<td></td>\n<td>android.print</td>\n</tr>\n<tr>\n<td>XML Serialization</td>\n<td></td>\n<td>org.xmlpull.v1.XmlSerializer <br/> org.xml.sax</td>\n</tr>\n<tr>\n<td>Interop Services</td>\n<td></td>\n<td>Java Native Interface</td>\n</tr>\n<tr>\n<td>Threading</td>\n<td></td>\n<td>java.lang.Thread</td>\n</tr>\n<tr>\n<td>Encryption</td>\n<td></td>\n<td>javax.crypto</td>\n</tr>\n<tr>\n<td>Message Queue</td>\n<td></td>\n<td>android.os.MessageQueue</td>\n</tr>\n<tr>\n<td>Network Communications</td>\n<td></td>\n<td>java.net.Socket</td>\n</tr>\n</table>\n\n\n\n\n\n\n"},{"key":"guide-abouthelp","name":"About EMDK For Android Help","md":"#About EMDK For Android Help\n\n##Overview\n\nWelcome to the EMDK for Android Technical Documentation. This help system allows you to browse the EMDK For Android documentation on your local computer and features many tools for navigating and searching through the content. \n\n## Updating Local Documentation\nThere may be updates to the documentation that is included with the EMDK For Android installation after it has been released. Although the documentation for the latest version is also published to [Launchpad](https://developer.motorolasolutions.com/community/android/emdk) and may contain additional or updated content. You can also update your local version to contain the latest updates.\n\n### Help Version\nYou can check your current help version by looking at the menu on the left hand side of the page (offline version only). This indicates the version of the help documentation. If the number corresponds with the version of the EMDK For Android (Noted in the page header), then it is the same as what has been released with the software. Updates to the documentation after release will be denoted by an extra version number. For example, say the EMDK For Android release was 3.0.1, a documentation update post release may be indicated with a Help version of 3.0.1.1\n\n![img](images/HelpVersions.jpg)\n\n### Downloading Updated Documentation\nFollow these instructions for updating your local documentation to be the latest.\n\n* [Download the latest documentation](https://s3.amazonaws.com/emdk/EMDK.Docs.Latest.zip)\n* Unzip the contents of the download\n* Copy the contents of the zip folder to the `InstallationPath\\Help` folder. For example `\\Program Files\\Symbol EMDK for Android\\v3.0\\Help`\n\n![img](images/HelpFolder.jpg)\n\n##Help Features\n\n###Table of Contents:\n\nThe menu on the left hand side of the page can be used to navigate through the varies documents contained inside this help application.  \n\n![img](images/about/toc1.png)\n\nThe documents are broken in to categories that can be drilled down to.\n\n![img](images/about/toc3.png)\n\nThe menu icon will allow you to collapse and expand the \"Table of Contents\".\n\n![img](images/about/toc2.png)\n \n###Search:\n\nAt the top of the page you will see a search box. \n\n![img](images/about/s1.png)\n\nThis box will search all documents in the system and highlight selected terms in the current document. You can switch between relevant documents buy selecting the document in \"Search Results\". You can minimize the \"Search Results\" by clicking on the \"-\" icon. You can bring the \"Search Results back by click on the search bar. \n\n![img](images/about/s2.png)\n\nAt the bottom right hand side of the page you will see next and previous buttons that will allow you to move through the selected items. \n\n![img](images/about/s3.png)\n\nAfter searching, if you browse to another page the search terms will automatically be used to bring you to the first found entry. Clearing the search results field will prevent this behavior.\n\n###In This Document:\n\nIn This document is a list of the main sections in the current document. When Selecting a link the document the document will scroll to the selected section, and show any sub sections. \n\n![img](images/about/itd1.png)\n\n###Image Viewer:\n\nWhen click on an image the image will open up at 100% in an in page pop up. If the image is bigger then your screen you will be able to scroll the image inside the pop up. If you click on the image in the pop up it will open in a new tab. Clicking the [X] in the pop up or clicking outside the pop up will close it.\n\n![img](images/about/lb1.png)\n\n### External Links\n\nWhen clicking on a link that is an external website, the url will be opened in a new tab of your browser.\n\n##Supported Web Browsers\n\n* Firefox 29 or newer\n* Google Chrome 35 or newer \n* Internet Explore 9 or newer"},{"key":"guide-eula","name":" EMDK For Android Downloads","md":"# EMDK For Android Downloads\n<!--\nPlease read the terms of this \"End User License Agreement\" (the \"Agreement\") carefully. The Agreement is a legal agreement between you (either an individual or a single entity) and Zebra Technologies International, LLC (\"Zebra\") for the Zebra computer software and/or firmware accompanying this End User License Agreement, and any associated media, printed materials and any \"online\" or electronic documentation (collectively, \"Software\"). By installing or using the Software, you agree to be bound by the terms of this Agreement. If you do not agree to the terms of this Agreement, you may not install or use the Software.\n\n1. Grant of License. The Software is protected by copyright and other intellectual property laws and international treaties. The Software is licensed to you, and not sold, subject to the terms of this Agreement. Subject to the terms of this Agreement, Zebra hereby grants you a limited, personal, non-exclusive license during the term of this Agreement to use the Software solely and exclusively for your internal use for the operation of your associated Zebra printer(s) and for no other purpose. To the extent that any portion of the Software is provided to you in a manner that is designed to be installed by you, you may install one copy of the installable Software on one hard disk or other storage device for one printer, computer, workstation, terminal, or other digital electronic device, as applicable (an \"Electronic Device\"), and you may access and use that Software as installed on that Electronic Device so long as only one copy of such Software is in operation. If you are an organization rather than an individual, you may authorize personnel associated with your business to use the Software, but only one person at a time on one Electronic Device at a time. You agree not to duplicate or copy the Software, except that you may make one back-up copy for archive purposes. The primary user of the Electronic Device on which installable Software is installed may also make a copy for his or her exclusive use on a portable computer, so long as such Software is being used only on one Electronic Device at a time. \n\n2. Storage/Network Use. In the alternative, you may install a copy of the Software on a storage device, such as a network server, used only to access and use the Software on your Electronic Devices over an internal network; however, you must acquire and dedicate a license for each separate Electronic Device on which the Software is accessed and used from the storage device. A license for the Software may not be shared or used concurrently on different Electronic Devices. \n\n3. Documentation. If the Software contains documentation which is provided only in electronic form, you may print one copy of such electronic documentation. You may not copy the printed materials accompanying the Software.\n\n4. Limitations of Reverse Engineering, Decompilation and Disassembly. You may not reverse engineer, decompile, or disassemble the Software, except and only to the extent that such activity is permitted by applicable law notwithstanding this limitation.\n\n5. Transfer/Sublicense. You may not transfer, sublicense, distribute, rent, lease, supply, market or lend the Software to any other party. \n\n6. Confidentiality. You acknowledge that the Software embodies confidential information owned by Zebra and/or its suppliers and licensors. To the extent you have access to any such information, you agree to use such information only for the authorized use of the Software. You further agree not to disclose such confidential information to any other party and to use at least the same degree of care to maintain the confidential nature of such information as you use to maintain the confidentiality of your own confidential information.\n\n7. Intellectual Property. All title, copyrights and other intellectual property rights in and to the Software (including but not limited to copyrights, patents, trade secrets and trademarks) are owned by Zebra or its suppliers and licensors. You must maintain all copyright notices on all copies of the Software. All rights not expressly granted are reserved by Zebra. Without prejudice to any rights or remedies Zebra may have for your violation of this Software License, Zebra shall own all changes or modifications to the Software. \n\n8. Termination. Without prejudice to any other rights or remedies Zebra may have, Zebra may terminate this Agreement if you fail to comply with the terms and conditions of this Agreement. Zebra may terminate this Agreement by offering you a superseding Agreement for the Software or any replacement or modified version of or upgrade to the Software and conditioning your continued use of the Software or such replacement, modified or upgraded version on your acceptance of such superseding Agreement. In addition, either party may terminate this Agreement at any time. Subject to the foregoing, termination shall be effective upon notice to the other party. In the event that this Agreement terminates for any reason, your license to use the Software will terminate, and you must immediately stop using the Software, destroy all copies of the Software and all of its component parts, and, upon request, provide an affidavit certifying your compliance with the foregoing. The provisions of Sections 4, 5, 6, 7, 12, 13, 14, 15, 16, 17, 18, 19 and 20 shall survive termination of this Agreement.\n\n9. U.S. Government Restricted Rights. All Software provided to the U.S. Government pursuant to solicitations issued on or after December 1, 1995 is provided with the commercial rights and restrictions described elsewhere herein. All Software provided to the U.S. Government pursuant to solicitations issued prior to December 1, 1995 is provided with RESTRICTED RIGHTS as provided for in FAR, 48 CFR 52.227-19 (JUNE 1987) or DFARs, 48 CFR 252.227-7013 (OCT 1988), as applicable.\n\n10. Export Restrictions. You agree that you will not export or re-export the Software, any part thereof, or any process or service that is the direct product of the Software (the foregoing collectively referred to as the \"Restricted Components\"), to any country, person or entity subject to U.S. export restrictions. You specifically agree not to export or re-export any of the Restricted Components: (i) to any country to which the U.S. has embargoed or restricted the export of goods or services, which currently include but are not necessarily limited to Cuba, Iran, Iraq, North Korea, Sudan and Syria, or to any national of any such country, wherever located, who intends to transmit or transport the Restricted Components back to such country; (ii) to any person or entity who you know or have reason to know will utilize the Restricted Components in the design, development or production of nuclear, chemical or biological weapons; or (iii) to any person or entity who has been prohibited from participating in U.S. export transactions by any federal agency of the U.S. government. You warrant and represent that neither the U.S. Commerce Department, Bureau of Export Administration nor any other U.S. federal agency has suspended, revoked or denied your export privileges. Contractor/Manufacturer is Zebra Technologies Corporation, 333 Corporate Woods Parkway, Vernon Hills, Illinois 60061. \n\n11. Accessing Services Using the Software. Your use of any service accessible using the Software is not covered by this EULA and may be governed by separate terms of use, conditions or notices. Zebra and its suppliers and licensors hereby disclaim any such liability for any such services accessed.\n\n12. Disclaimer. ZEBRA SUPPLIES THE SOFTWARE AS IS AND WITH ALL FAULTS AND DOES NOT MAKE ANY WARRANTIES WHATSOEVER, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES CONCERNING THE SOFTWARE OR ANY APPLICATION, OPERATION OR USE THEREOF, THE OUTPUT OR THE DATA GENERATED BY THE OPERATION OR USE THEREOF, OR ANY SUPPORT SERVICES RENDERED WITH RESPECT THERETO. ZEBRA HEREBY EXCLUDES ALL IMPLIED WARRANTIES TO THE MAXIMUM EXTENT AUTHORIZED BY LAW, INCLUDING, SPECIFICALLY, ANY IMPLIED WARRANTY ARISING BY STATUTE OR OTHERWISE IN LAW OR FROM A COURSE OF DEALING OR USAGE OF TRADE, ALL IMPLIED WARRANTIES OF MERCHANTABILITY, OR OF MERCHANTABLE QUALITY, OR OF FITNESS FOR ANY PURPOSE, PARTICULAR, SPECIFIC OR OTHERWISE, OR OF TITLE, OR OF NONINFRINGEMENT. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF IMPLIED WARRANTIES, SO THE ABOVE LIMITATION OR EXCLUSION MAY NOT APPLY TO YOU. WHEN THE IMPLIED WARRANTIES ARE NOT ALLOWED TO BE EXCLUDED IN THEIR ENTIRETY, THEY WILL BE LIMITED TO THE DURATION OF NINETY (90) DAYS. WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, ZEBRA DOES NOT WARRANT THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR FREE. TO THE EXTENT THAT THE SOFTWARE COVERED BY THIS EULA INCLUDES EMULATION LIBRARIES, SUCH EMULATION LIBRARIES DO NOT WORK 100% CORRECTLY OR COVER 100% OF THE FUNCTIONALITY OF THE PRINTER LANGUAGE BEING EMULATED, ARE OFFERED \"AS IS\" AND WITH ALL FAULTS, AND ALL THE DISCLAIMERS AND LIMITATIONS CONTAINED IN THIS PARAGRAPH AND THIS AGREEMENT APPLY TO SUCH EMULATION LIBRARIES. \n\n13. Limitation of Liability and Damages. ZEBRA DOES NOT ASSUME RESPONSIBILITY FOR ANY SPECIFIC APPLICATION OF THE SOFTWARE OR FOR COMPATIBILITY WITH OTHER SOFTWARE OR EQUIPMENT. TO THE FULL EXTENT ALLOWED BY LAW, ZEBRA EXCLUDES FOR ITSELF AND ITS LICENSORS AND SUPPLIERS ANY LIABILITY FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION DIRECT, CONSEQUENTIAL, INCIDENTAL, INDIRECT, SPECIAL, EXEMPLARY OR PUNITIVE DAMAGES OF ANY KIND, OR FOR LOSS OF REVENUE OR PROFITS, LOSS OF BUSINESS, DAMAGE TO GOODWILL, LOSS OF INFORMATION OR DATA, OR OTHER FINANCIAL LOSS ARISING OUT OF OR IN CONNECTION WITH THE SALE, INSTALLATION, MAINTENANCE, USE, PERFORMANCE, FAILURE, OR INTERRUPTION OF ANY PRODUCTS, PARTS OR SOFTWARE, WHETHER BASED ON CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR OTHERWISE, EVEN IF ZEBRA OR ANY LICENSOR OR SUPPLIER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. TO THE MAXIMUM EXTENT AUTHORIZED BY LAW, THIS DISCLAIMER OF LIABILITY FOR DAMAGES WILL NOT BE AFFECTED IF ANY REMEDY PROVIDED HEREIN SHALL FAIL OF ITS ESSENTIAL PURPOSE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF DIRECT, INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES, SO THE ABOVE LIMITATION OR EXCLUSION MAY NOT APPLY TO YOU. WHEN LIABILITY FOR DAMAGES IS NOT ALLOWED TO BE LIMITED OR EXCLUDED IN ITS ENTIRETY, ZEBRA LIMITS ITS LIABILITY TO REPAIR, REPLACEMENT, OR, AT ZEBRA'S OPTION, REFUND OF THE PRICE OF THE SOFTWARE.\n\n14. Zebra Suppliers and Licensors. Any release, disclaimer or limitation of Zebra's liability or damages pursuant to this Agreement shall be construed, in addition to Zebra's benefit, also to the benefit of Zebra's suppliers, licensors, employees, and contractors and, without limiting any other defenses that such suppliers, licensors, employees and contractors may have, you agree to release such parties from liability or damages in accordance with such release, disclaimer, or limitation of liability or damages to the same extent that such provisions apply to Zebra. \n\n15. Governing Law. To the maximum extent permitted by law, the laws of the State of Illinois, U.S.A., without reference to its conflict of laws provisions, will apply to this Agreement. You irrevocably agree to submit to the exclusive jurisdiction and venue of the state or federal courts in the State of Illinois in the event of any litigation involving this Agreement or the Software. You agree that you shall not assert any claim that you are not subject to the jurisdiction of such courts, that the venue is improper, that the forum is inconvenient or any similar objection, claim or argument. Zebra may, in its sole discretion, choose to resolve any controversy or dispute between you and Zebra concerning this Agreement, or the existence, validity, breach or termination thereof, whether during or after the term by binding arbitration in accordance with the Commercial Arbitration Rules of the American Arbitration Association (\"AAA\"), as modified or supplemented under this Section 15, by providing notice to you. In the event that Zebra provides such notice, you hereby waive any right to institute a court or other dispute resolution proceeding with respect to such controversy or dispute and acknowledge arbitration in accordance with this Section 15 as the sole and exclusive means of resolving such controversy or dispute. The arbitration proceeding will take place in Chicago, Illinois and be conducted in the English language. The arbitration panel will consist of 3 arbitrators, one arbitrator appointed by each party and a third neutral arbitrator appointed by the two arbitrators designated by the parties. Any communication between a party and any arbitrator will be directed to the AAA for transmittal to the arbitrator. The parties expressly agree that the arbitrators will be empowered to, at either party's request, grant injunctive relief. The arbitral award will be the exclusive remedy of the parties for all claims, counterclaims, issues or accountings presented or pleaded to the arbitrators. Judgment upon the arbitral award may be entered in any court that has jurisdiction thereof. Any additional costs, fees or expenses incurred in enforcing the arbitral award will be charged against the party that resists its enforcement. Nothing in this Section will prevent Zebra from seeking interim injunctive relief against you or filing an action against you to collect unpaid and past due amounts in any court of competent jurisdiction.\n\n16. Injunctive Relief. You acknowledge that, in the event you breach any provision of this Agreement, Zebra will not have an adequate remedy in money or damages. Zebra shall therefore be entitled to obtain an injunction against such breach from any court of competent jurisdiction immediately upon request without posting bond. Zebra's right to obtain injunctive relief shall not limit its right to seek further remedies.\n\n17. Entire Agreement. This Agreement constitutes the entire understanding and agreement of the parties and supersedes any and all prior or contemporaneous representations, understandings and agreements between the parties with respect to the subject matter of this Agreement. If any provision of this Agreement is held invalid, the remainder of this Agreement shall continue in full force and effect.\n\n18. Assignment. You may not assign this Agreement or any of your rights or obligations hereunder (by operation of law or otherwise) without the prior written consent of Zebra. Zebra may assign this Agreement and its rights and obligations without your consent. Subject to the foregoing, this Agreement shall be binding upon and inure to the benefit of the parties to it and their respective legal representatives, successors and permitted assigns.\n\n19. Modification. No modification of this Agreement shall be binding unless it is in writing and is signed by an authorized representative of the party against whom enforcement of the modification is sought.\n\n20. Waiver. The failure by a party to exercise any right hereunder shall not operate as a waiver of such party's right to exercise such right or any other right in the future.\n-->\n\n## Latest Release \n<ul> \n<li><a href='https://atgsupportcentral.motorolasolutions.com/ewa/pub/getFile.do?fileName=ssi/emb/downloads/EMDK-A-030109.exe'>EMDK 3.1 - Windows Installation</a></li>\n<li><a href=\"https://atgsupportcentral.motorolasolutions.com/content/emb/docs/ReleaseNotes/Release_Notes_-_EMDK-A-030109.htm\">Release Notes</a></li>\n<li><a href='https://s3.amazonaws.com/emdk/EMDK.Docs.Latest.zip'>Offline Help Docs</a></li>\n</ul>\n\n## Previous Releases\n<ul>\n<li><a href='https://atgsupportcentral.motorolasolutions.com/ewa/pub/getFile.do?fileName=ssi/emb/downloads/EMDK-A-030004-UP1B.exe'>EMDK 3.0 - Update 1</a></li>\n<li><a href='https://atgsupportcentral.motorolasolutions.com/ewa/pub/getFile.do?fileName=ssi/emb/downloads/EMDK-A-030004.exe'>EMDK 3.0 - Full Installation</a></li>\n<li><a href=\"https://atgsupportcentral.motorolasolutions.com/ewa/pub/getFile.do?fileName=ssi/emb/downloads/EMDK-A-020104.exe\">EMDK 2.1</a></li>\n<li><a href=\"https://atgsupportcentral.motorolasolutions.com/ewa/pub/getFile.do?fileName=ssi/emb/downloads/EMDK-A-020004.exe\">EMDK 2.0</a></li>\n</ul>\n"},{"key":"guide-extended_status","name":"Extended Status Information User Guide","md":"#Extended Status Information User Guide\n\n##Introduction \nThe [EMDKResults](#api-EMDKResults) class exposes an Enum ( EXTENDED_STATUS_CODE ). Inspecting that Enum after a profile has been processed could provide detailed error information that may have occured while being processed. \n\n\n### Section of EMDKConfig.xml\nName of the file EMDKConfig.xml. It is fixed and cannot be changed.\nName of the Profile. One config file can contain one or more Profiles. But only one Profile is activated in one instance.\nFeature Type\nFeature Name.\n\n####Special Test Cases\n\n**Case 01:**\n\n    :::xml\n    //XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk02\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n\n**Parameters**\n\n    :::java\n    extraData[0] \t\t= \"Clk01.Date=2014-10-10\"\n    extraData[1] \t\t= \"Clk02.Time=10:10:10\"\n    profileName\t\t\t= ClockProfile-1\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n**Results**\n\n    :::xml\n    extendedStatusCode\t= NONE\n    statusCode\t        \t= CHECK_XML\n    xmlString           \t= <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc><characteristic type=\"status\"><parm name=\"code\" value=\"6\"/><parm name=\"description\" value=\"Review the XML for details\"/><characteristic type=\"extended_status\"><parm name=\"code\" value=\"0\"/><parm name=\"description\" value=\"\"/></characteristic></characteristic><characteristic type=\"Clock\" version=\"4.3\"><parm name=\"AutoTime\" value=\"false\"/><parm name=\"TimeZone\" value=\"GMT+05:30\"/><parm name=\"Date\" value=\"2014-10-10\"/><parm name=\"Time\" value=\"01:01:01\"/></characteristic><characteristic type=\"Clock\" version=\"4.3\"><parm name=\"AutoTime\" value=\"false\"/><parm name=\"TimeZone\" value=\"GMT+05:30\"/><parm name=\"Date\" value=\"2002-02-02\"/><parm name=\"Time\" value=\"10:10:10\"/></characteristic><characteristic type=\"Clock\" version=\"4.3\"><parm name=\"AutoTime\" value=\"false\"/><parm name=\"TimeZone\" value=\"GMT+05:30\"/><parm name=\"Date\" value=\"2003-03-03\"/><parm name=\"Time\" value=\"03:03:03\"/></characteristic></wap-provisioningdoc>\n\n####Case 02:\n\n    :::xml\n    //XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk02\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n    Parameters\n    extraData[0] \t\t= \"Clk01.Date=2014-10-10\"\n    extraData[1] \t\t= \"Clk02.Time=10:10:10\"\n    profileName\t\t\t= ClockProfile-1/Clock/Clk01\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n    Results\n\n    extendedStatusCode\t= NAMEVALUE_MISMATCH_EXTRADATA\n    statusCode\t        \t= FAILURE\n\n\n####Case 03:\n\n    :::xml\n    XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk02\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n    Parameters\n    extraData[0] \t\t= \n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <characteristic type=\"Profile\" >\n        <parm name=\"ProfileName\" value=\"ClockProfile-1\" />\n        <characteristic type=\"Clock\" >\n            <parm name=\"emdk_name\" value=\"Clk01\" />\n            <parm name=\"Date\" value=\"2014-11-22\" />\n            <parm name=\"Time\" value=\"11:22:33\" />\n        </characteristic>\n        <characteristic type=\"Clock\" >\n            <parm name=\"emdk_name\" value=\"Clk02\" />\n            <parm name=\"Date\" value=\"2014-11-22\" />\n            <parm name=\"Time\" value=\"11:22:33\" />\n        </characteristic>\n    </characteristic>\n\n\n    profileName\t\t\t= ClockProfile-1\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n    Results\n\n    extendedStatusCode\t= NONE\n    statusCode\t        \t= CHECK_XML\n    xmlString           \t= <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc><characteristic type=\"status\"><parm name=\"code\" \n    value=\"6\"/><parm name=\"description\" value=\"Review the XML for details\"/><characteristic type=\"extended_status\"><parm name=\"code\" value=\"0\"/><parm name=\"description\" value=\"\"/></characteristic></characteristic><characteristic type=\"Clock\" version=\"4.3\"><parm name=\"AutoTime\" value=\"false\"/><parm name=\"TimeZone\" value=\"GMT+05:30\"/><parm name=\"Date\" value=\"2014-11-22\"/><parm name=\"Time\" value=\"11:22:33\"/></characteristic><characteristic type=\"Clock\" version=\"4.3\"><parm name=\"AutoTime\" value=\"false\"/><parm name=\"TimeZone\" value=\"GMT+05:30\"/><parm name=\"Date\" value=\"2014-11-22\"/><parm name=\"Time\" value=\"11:22:33\"/></characteristic><characteristic type=\"Clock\" version=\"4.3\"><parm name=\"AutoTime\" value=\"false\"/><parm name=\"TimeZone\" value=\"GMT+05:30\"/><parm name=\"Date\" value=\"2003-03-03\"/><parm name=\"Time\" value=\"03:03:03\"/></characteristic></wap-provisioningdoc>\n\n####Case 04:\n\n    :::xml\n    XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk02\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n    Parameters\n    extraData[0] \t\t= \n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <characteristic type=\"Profile\" >\n        <parm name=\"ProfileName\" value=\"ClockProfile-1\" />\n        <characteristic type=\"Clock\" >\n            <parm name=\"emdk_name\" value=\"Clk01\" />\n            <parm name=\"Date\" value=\"2014-11-22\" />\n            <parm name=\"Time\" value=\"11:22:33\" />\n        </characteristic>\n        <characteristic type=\"Clock\" >\n            <parm name=\"emdk_name\" value=\"Clk02\" />\n            <parm name=\"Date\" value=\"2014-11-22\" />\n            <parm name=\"Time\" value=\"11:22:33\" />\n        </characteristic>\n    </characteristic>\n\n\n    profileName\t\t\t= ClockProfile-1/Clock/Clk01\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n    Results\n\n    extendedStatusCode\t= FEATURE_NOT_UNIQUE_EXTRADATA\n    statusCode\t        \t= FAILURE\n\n\n####Case 05:\n\n    :::xml\n    XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n    Parameters\n    extraData[0] = \"Clk01.Date=2014-10-10\";\n    extraData[1] = \"Clk01.Time=10:10:10\";\n\n    profileName\t\t\t= ClockProfile-1\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n    Results\n\n    extendedStatusCode\t= FEATURE_NOT_UNIQUE_CONFIG\n    statusCode\t        \t= FAILURE\n\n####Case 06:\n\n    :::xml\n    XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n    Parameters\n    extraData[0] = \"Clk01.Date=2014-10-10\";\n    extraData[1] = \"Clk01.Time=10:10:10\";\n\n    profileName\t\t\t= ClockProfile-1/Clock/Clk01\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n    Results\n\n    extendedStatusCode\t= FEATURE_NOT_UNIQUE_CONFIG\n    statusCode\t        \t= FAILURE\n    Case 07:\n    XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n    Parameters\n    extraData[0] = \n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <characteristic type=\"Profile\" >\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\" />\n    <characteristic type=\"Clock\" >\n        <parm name=\"emdk_name\" value=\"Clk01\" />\n        <parm name=\"Date\" value=\"2014-11-22\" />\n        <parm name=\"Time\" value=\"11:22:33\" />\n    </characteristic>\n    </characteristic>\n\n\n\n    profileName\t\t\t= ClockProfile-1\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n    Results\n\n    extendedStatusCode\t= FEATURE_NOT_UNIQUE_CONFIG\n    statusCode\t        \t= FAILURE\n\n####Case 08:\n\n    :::xml\n    XML (EMDKConfig.xml):\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n    <characteristic type=\"ProfileInfo\">\n    <parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n    </characteristic>\n    <characteristic type=\"Profile\">\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n    <parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2001-01-01\"/>\n    <parm name=\"Time\" value=\"01:01:01\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk01\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2002-02-02\"/>\n    <parm name=\"Time\" value=\"02:02:02\"/>\n    </characteristic>\n    <characteristic type=\"Clock\" version=\"4.2\">\n    <parm name=\"emdk_name\" value=\"Clk03\"/>\n    <parm name=\"AutoTime\" value=\"false\"/>\n    <parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n    <parm name=\"Date\" value=\"2003-03-03\"/>\n    <parm name=\"Time\" value=\"03:03:03\"/>\n    </characteristic>\n    </characteristic>\n    </wap-provisioningdoc>\n\n    Parameters\n    extraData[0] = \n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <characteristic type=\"Profile\" >\n    <parm name=\"ProfileName\" value=\"ClockProfile-1\" />\n    <characteristic type=\"Clock\" >\n        <parm name=\"emdk_name\" value=\"Clk01\" />\n        <parm name=\"Date\" value=\"2014-11-22\" />\n        <parm name=\"Time\" value=\"11:22:33\" />\n    </characteristic>\n    </characteristic>\n\n\n\n    profileName\t\t\t= ClockProfile-1/Clock/Clk01\n    profileFlag\t\t\t= PROFILE_FLAG.SET\n\n    Results\n\n    extendedStatusCode\t= FEATURE_NOT_UNIQUE_CONFIG\n    statusCode\t        \t= FAILURE"},{"key":"guide-name_value_pair","name":"Name Value Pair Functionality User Guide","md":"#Name Value Pair Functionality User Guide\n\n##Introduction\n\nThe [ProfileManager](#api-ProfileManager) API exposes a method ( processProfile ) that is used\nto install and activate a static XML profile located in your projects Assets folder. The API also exposes an overload for processProfile that allows one to submit a String Array containing Name=Value Pairs that can be used to replace Name=Value Pairs in a specified Profile before installing and activating that profile. The following guide explains the use of Name=Value Pair replacement and a utility method to help create Name=Value pairs.\n\n##String Array ( extraData )as Name-Value Pair Array\n###Method Signature\n\n\t:::java\n\tprocessProfile(String profileName,\n\t\t\t\t   ProfileManager.PROFILE_FLAG profileFlag,\n\t \t\t\t   String[] extraData);\n\n\n###profileName\nThe profileName argument, can be used to specify the entire profile or a named section of XML Profile.\n\n- To Specify the entire profile, pass the value of the \"ProfileName\" parm as the profileName argument.\n- To Specify a section of a profile, build and pass a String containing the top level \"ProfileName\", the featureType of the section, and the emdk_name of the section all separated by forward slashes.\n **[profileName]/[featureType]/[feature Name]**\n\n>For example, if my profile is called EmdkSampleProfile-1 and the name I gave to the Clock feature is 'clock1'. Passing 'profileName' as ' EmdkSampleProfile-1/Clock/clock1 will just process this part of the profile.\n\n###featureType\n\nValid FeatureTypes:\n\n- ActivitySelection\n- Barcode\n- MSR\n- Intent\n- Keystroke\n- IP\n- Clock\n- PowerMgr\n- PersistMgr\n- CertMgr\n- AppMgr\n- AccessMgr\n- Wi-Fi\n- GprsMgr\n\n\t\n\t\n###profileFlag\nThe profileFlag should be ProfileManager.PROFILE_FLAG.SET.\n\n###extraData\nExtraData should be an array of Strings. Each string element should be `<Feature_Name>.<Param_name>=<param_value>` format. For example \"bc1.decoder_upce0=true\". The Feature_Name can be from multiple features.\n\n##Example Usage\n\n\t:::java\n\t//EMDKConfig.xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?><wap-provisioningdoc>\n\t<characteristic type=\"ProfileInfo\">\n\t<parm name=\"created_wizard_version\" value=\"3.0.2\"/>\n\t</characteristic>\n\t<characteristic type=\"Profile\">\n\t<parm name=\"ProfileName\" value=\"ClockProfile-1\"/>\n\t<parm name=\"ModifiedDate\" value=\"2015-03-16 09:14:43\"/>\n\t<characteristic type=\"Clock\" version=\"4.2\">\n\t<parm name=\"emdk_name\" value=\"Clk01\"/>\n\t<parm name=\"AutoTime\" value=\"false\"/>\n\t<parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n\t<parm name=\"Date\" value=\"2001-01-01\"/>\n\t<parm name=\"Time\" value=\"01:01:01\"/>\n\t</characteristic>\n\t<characteristic type=\"Clock\" version=\"4.2\">\n\t<parm name=\"emdk_name\" value=\"Clk02\"/>\n\t<parm name=\"AutoTime\" value=\"false\"/>\n\t<parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n\t<parm name=\"Date\" value=\"2002-02-02\"/>\n\t<parm name=\"Time\" value=\"02:02:02\"/>\n\t</characteristic>\n\t<characteristic type=\"Clock\" version=\"4.2\">\n\t<parm name=\"emdk_name\" value=\"Clk03\"/>\n\t<parm name=\"AutoTime\" value=\"false\"/>\n\t<parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n\t<parm name=\"Date\" value=\"2003-03-03\"/>\n\t<parm name=\"Time\" value=\"03:03:03\"/>\n\t</characteristic>\n\t</characteristic>\n\t</wap-provisioningdoc>\n\n\n\t//example.java\n\tString[] extraData = new String[2];\n\textraData[0] \t\t= \"Clk01.Date=2014-10-10\"\n\textraData[1] \t\t= \"Clk02.Time=10:10:10\"\n\tprofileName\t\t= ClockProfile-1/Clock/Clk01\n\tEMDKResults result = mProfileManager.processProfile(\n\tprofileName, \n\tProfileManager.PROFILE_FLAG.SET, extraData);\n\nIn above example the profileName is given as ClockProfile-1/Clock/Clk01. The ClockProfile-1 is the profileName in XML. Clock is the feature Type and Clk01 is the feature Name. The feature name also referred as emdk_name.\n\n##Name Value Pair Utility Function\n\n###CreateNameValuePair\nCreateNameValuePair is a static function of the ProfileManager class. This function creates a name value pair string according to the format that is compatible with com.symbol.emdk.ProfileManager.processProfile(String, * PROFILE_FLAG, String[]) function. \n\n\t:::java\n\t/**\n\t * This function creates a name value pair string according to the format \n\t * that is compatible with \n\t * com.symbol.emdk.ProfileManager.processProfile(String, \n\t * PROFILE_FLAG, String[]) function.\n\t * @param emdk_name - emdk name String  \n\t * @param param_name - Parameter name String\n\t * @param param_value - Parameter value String\n\t * @return - Name value pair string.\n\t */\n\tString CreateNameValuePair(String emdk_name, String param_name, String param_value)\n\t\n\t//This function returns the String in <emdk_name>.<param_name>=<param_value> format.\n\t//For instance, \"clock1.date=2014-10-10\";\n"},{"key":"guide-profiles-access","name":" Access Manager Profile Feature Reference","md":"# Access Manager Profile Feature Reference\n## Overview\n\nThe Access Manager feature allows you to configure a set of applications that will be allowed to run and install on the device. When this feature is enabled, the device will only allow user installed applications on the Whitelist to be executed and/or installed (some applications that are part of the default operating system will still be available). To disable the Whitelist, you would select 'Single User Without Whitelist'.  \n\n>Note:  \n>It is important to include the executing EMDK application in the Whitelist otherwise your application will lose control of the Whitelist configuration and you will not be able to change the behavior.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Set Device Operation Mode to Single User without Whitelist\n* Set Device Operation Mode to Single User with Whitelist\n* Set System Settings Access to Full Access \n* Set System Settings Access to Reduced Access \n* Set Application Verification Mode to do not Verify App Signature\n* Set Application Verification Mode to Verify User App Signature\n* Set Application Verification Mode to Verify All App Signature\n* Delete Specified Packages \n* Delete All Packages \n* Delete Specified Signatures\n* Add Specified Package\n* Add Package to to List of Applications Allowed to Submit XML\n* Remove Package from List of Applications Allowed to Submit XML\n* Allow all Applications that can be Executed to Submit XML\n\n## Operation Mode\n>*WARNING* Enabling the `Whitelist` requires adding the EMDK package name `com.symbol.emdk.emdkservice` to the white list. Otherwise none of the EMDK APIs will work.\n\n* Single User Without Whitelist - Setting this feature will disable all Whitelist features.\n* Single User With Whitelist - Setting this feature will enable the Whitelist feature based on the details provided. You can choose to add or delete packages from the current Whitelist\n\n##System Settings Access\n>Note: This setting is available when the operation mode is `Single User With Whitelist`\n\n1. Full Access - The device's System Settings Menu will not be reduced\n2. Reduced Access - The device's System Settings menu will be reduced to a pre-selected group of options (Display, Volume, About)\n\n##Application Verification\nApplication Verification adds another level of security to whitelisting applications beyond just \nverifying a package name. Provide a signature for the package you are adding. The whitelist will then only allow\nthat exact package signature to launch.\n\n## Delete Packages\nOptions for deleting packages from the Whitelist\n\n* Delete No Packages - Does not delete any packages\n* Delete All Packages - Deletes all packages \n* Delete Specified Package - Delete specified package\n\t* Delete Package Name: Name of package(s) separated by a comma ex: com.mycompany.mypackage \n\n## Add Packages\nOptions for adding packages to the Whitelist\n\n> Note: Enabling the white list feature via access manager profile on TC70 KitKat device requires adding the EMDK package name `com.symbol.emdk.emdkservice` to the allowed packages white list to use EMDK APIs\n\n* Add No Packages - Does not add any packages\n* Add Specified Package - Add specified package\n\t* Add Package Name: Name of package(s) separated by a comma ex: com.mycompany.mypackage \n\n>Note: It is important to include the executing EMDK application in the Whitelist otherwise your application will lose control of the Whitelist configuration and you will not be able to change the behavior without an enterprise reset..\n\n## Allow Application To Submit XML\nYou can specify and restrict specific applications the ability to submit changes to the MX Framework. This feature is supported on devices that are running KitKat versions of Android like the TC70 and will only be used when the Whitelist feature is enabled.\n\n* **Allow Package Names** - Provide a comma separated list of package names that are allowed to submit XML to the MX framework.\n\n* **Disallow Package Names** - Provide a comma separated list of package names that are not allowed to submit XML to the MX framework.\n\n> NOTE: Enabling the white list feature via access manager profile on TC70 KitKat device requires adding the EMDK package name `com.symbol.emdk.emdkservice` to the allowed packages white list to use EMDK APIs and in the allow submit XML white list to use EMDK ProfileManager APIs to set profile.\n\n\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=AccessMgr&embed=true\"></iframe> \n"},{"key":"guide-profiles-analytics","name":" Analytics Manager Profile Feature Reference","md":"# Analytics Manager Profile Feature Reference\n\n## Overview\n\nThe Analytics Manager profile feature allows you to configure what data about a device should be collected, and where the collected data should be stored.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable/Disable Analytics \n* Set Transport Method\n* Configure Data sources\n* Configure Data Collection Levels for data sources\n\n##Group Action\nChoosing to configure levels for multiple Groups will allow you choose a collection level for each data group. For instance, you can set the CPU Usages data group to \"High\" \n\nChoosing to configure details for a single group will allow you choose an interval and which metrics should be collected for a group. For instance, you can set the system information group to collect every 5 minutes, and to include the memory load.\n\n##Transport Method\nThis profile feature allows your application to select where collected data logs are stored, Either, to a devices local storage or to a cloud based analytics provider.\n\n##Data sources\n  * **WWAN Performance**\n    * WWAN Signal Quality\n    * Outgoing Call Attempts\n    * WWAN Radio On Time\n    * Incoming Call Duration\n    * Successful Incoming Calls\n    * Incoming Call Attempts\n    * WWAN Error Rate\n    * Custom\n\n\n  * **WLAN Performance**\t\n    * WLAN Receive Packet Delta\n    * WLAN Signal Quality\n    * WLAN Transmit Package Delta\n    * WLAN Receive Byte Delta\n    * WLAN Transmit Byte Delta\n    * WLAN Radio On Time\n    * Custom\n\n\n  * **Battery and CPU Status**\t\n    * Battery Level Delta\n    * Battery Level\n    * AC Charge Count\n    * Display On Time\n    * AC Charge Time\n    * AC Charge Status\n    * Custom\n\n  * **System Information**\t\n    * Available (free) Storage Memory\n    * Available (free) Physical Memory\n    * Memory Load (% used) \n    * Total (installed) Storage Memory\n    * Total (installed) Physical Memory\n    * Custom\n\n\n  * **GPS Information**\n    * Current Altitude (in meters) from Sea Level\n    * GPS Device State\n    * GPS On Time Delta\n    * Current Course Heading (in degrees)\n    * Current Location (lat/Long)\n    * Position Dilution of Precision\n    * Custom\n\n  * **CPU Usage**\n    * Process CPU Time Delta\n    * Device CPU Time Delta\n    * Custom\n\n  \n##Data Collection Levels\n  * None\t\n  * Low\t\n  * Medium\t\n  * High \n\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=AnalyticsMgr&os=All&embed=true\"></iframe> \n"},{"key":"guide-profiles-app","name":" App Manager Profile Feature Reference","md":"# App Manager Profile Feature Reference\n\n## Overview\n\nThe App Manager feature allows you to install, upgrade, remove, enable, disable applications from the device. It also allows you to change the current application launcher, clear recent app list and much more.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Install Applications\n* Uninstall Applications\n* Upgrade Applications\n* Set a Default Launcher\n* Enable Application\n* Disable Application\n* Clear Recent Application List\n* Add Application to Protected List\n* Remove Application from Protected List\n* Clear Protected List\n* Enable Application Info\n* Disable Application Info\n\n## Install Application \nThis will install the specified application. The application must not exists on the device otherwise you will receive an error (Use the Upgrade parameter instead)\n\n* APK Path and Name: Must be the full path to the APK that will reside on the device. ex: '/storage/sdcard1/Herald.apk'\n\n## Uninstall Application \nThis will remove the specified application from the device.\n\n* Package Name: Provide the Android package name of the application ex: 'com.mycompany.mypackage'\n\n## Upgrade Application\nThis will upgrade/downgrade the specified application. The application must already exists on the device or you will receive an error (Use the Install parameter instead.\n\n* APK Path and Name: Must be the full path to the APK that will reside on the device. ex: '/storage/sdcard1/Herald.apk'\n\n## Default Launcher\nYou can provide a different application launcher to enable. The launcher application must reside on the device already.\n\n* Package Name: Provide the Android package name of the application ex: 'com.mycompany.mypackage'\n\n## Enable & Disable Application\nProvide a package name of the applications that you want to enable or disable. Disabling an application will disable the ability to launch the application.\n\n## Clear Recent Apps List\nIt will clear the list of recent apps that you opened. When you long press the menu button on symbol device, you will see a list of recently opened apps. After running your app using this feature, it will clear your device's recent app list including itself.  \n\n## Protected List\nYou can manage which applications are on the protected list. Applications on the protected list will not be force closed when the device is setup to run in multi-user mode and the current user logs off. Applications on the protected list are permitted to run across users.\n\n* Add Application - Specify the application's package name to add to the protected list.\n* Remove Application - Specify the application's package name to remove from the protected list.\n* Remove All - Removes all applications from the protected list\n\n## App Info\nThe application info dialog shows detailed information about the application as well as allow you to perform actions like: Force Stop, Enable/Disable, Clear Data, Clear Cache. You can specify whether you want to enable or disable access to this dialog for all applications.\n\n> Note: This feature is supported on devices that are running KitKat versions of Android like the TC70.\n\n## Feature Compatibility\n<iframe src=\"http://cfh463.github.io/docs.emdk/compare.html#mx=4.3&csp=AppMgr&os=All&embed=true\"></iframe> \n"},{"key":"guide-profiles-audio","name":" Audio Volume UI Manager Profile Feature Reference","md":"# Audio Volume UI Manager Profile Feature Reference\n\n## Overview\n\nThe Audio Manager feature allows you to manage enhanced audio volume control configurations\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Mute/Vibrate State\n* Current Active Profile \n* Audio UI Profile Action\n\n## Mute/Vibrate State\n\nSelect whether to mute the device or set the device to vibrate\n\n* **Mute** - Turn off audible sounds\n* **Vibrate** - Turn off audible sounds and turn on vibrate\n* **UnMute** - Turn on audible sounds and turn off Vibrate\n\n## Current Active Profile Action\n\nSpecify the Current Profile action to perform\n\n* **Set an Audio UI Profile as the current** \n\t* Name of the Current Audio UI Profile - Specify the name of the profile you wish to switch to.\n\t* Adjust current audio volume \n\t\t* Do not adjust the volume level - do not make audio volume setting take effect immediately \n\t\t* Adjust the volume level - make audio volume setting take effect immediately\n\n* **Adjust to the Preset volume level of the current Profile**\n\n* **Set the FactoryPreset Profile as the current Profile**\n\n\n## Audio UI Profile Action\n\n### Add an Audio UI Profile \nModify the following settings to customize your new Audio UI Profile. You do **not** need to provide values for all fields. Only fill in values you wish to modify.\n\n* **Name of the Audio UI Profile** - Provide a name to identify this profile\n* **UI Label of STREAM_MUSIC** - Provide the UI label for the music stream\n* **UI Icon of STREAM_MUSIC** - Provide the URL to the icon image for the music stream\n* **Control Parameters of STREAM_MUSIC** - Specify whether the stream is visible (1) or not (0) to the user\n* **Minimum, Maximum and Preset Volume Level for Speaker Mode** - Specify the volume levels for music stream in speaker mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Receiver Mode** - Specify the volume levels for music stream in receiver mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Wired Headset Mode** - Specify the volume levels for music stream in Wired Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Bluetooth Headset Mode** - Specify the volume levels for music stream in Bluetooth Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **UI Label of STREAM_RING** - Provide the UI label for the ring stream\n* **UI Icon of STREAM_RING** - Provide the URL to the icon image for the ring stream\n* **Control Parameters of STREAM_RING** - Specify whether the stream is visible (1) or not (0) to the user\n* **Minimum, Maximum and Preset Volume Level for Speaker Mode** - Specify the volume levels for ring stream in speaker mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Receiver Mode** - Specify the volume levels for ring stream in receiver mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Wired Headset Mode** - Specify the volume levels for ring stream in Wired Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Bluetooth Headset Mode** - Specify the volume levels for ring stream in Bluetooth Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **UI Label of STREAM_NOTIFICATION** - Provide the UI label for the NOTIFICATION stream\n* **UI Icon of STREAM_NOTIFICATION** - Provide the URL to the icon image for the NOTIFICATION stream\n* **Control Parameters of STREAM_NOTIFICATION** - Specify whether the stream is visible (1) or not (0) to the user\n* **Minimum, Maximum and Preset Volume Level for Speaker Mode** - Specify the volume levels for NOTIFICATION stream in speaker mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Receiver Mode** - Specify the volume levels for NOTIFICATION stream in receiver mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Wired Headset Mode** - Specify the volume levels for NOTIFICATION stream in Wired Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Bluetooth Headset Mode** - Specify the volume levels for NOTIFICATION stream in Bluetooth Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **UI Label of STREAM_SYSTEM** - Provide the UI label for the SYSTEM stream\n* **UI Icon of STREAM_SYSTEM** - Provide the URL to the icon image for the SYSTEM stream\n* **Control Parameters of STREAM_SYSTEM** - Specify whether the stream is visible (1) or not (0) to the user\t\n* **Minimum, Maximum and Preset Volume Level for Speaker Mode** - Specify the volume levels for SYSTEM stream in speaker mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Receiver Mode** - Specify the volume levels for SYSTEM stream in receiver mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Wired Headset Mode** - Specify the volume levels for SYSTEM stream in Wired Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Bluetooth Headset Mode** - Specify the volume levels for SYSTEM stream in Bluetooth Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **UI Label of STREAM_ALARM** - Provide the UI label for the ALARM stream\n* **UI Icon of STREAM_ALARM** - Provide the URL to the icon image for the ALARM stream\n* **Control Parameters of STREAM_ALARM** - Specify whether the stream is visible (1) or not (0) to the user\n* **Minimum, Maximum and Preset Volume Level for Speaker Mode** - Specify the volume levels for ALARM stream in speaker mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Receiver Mode** - Specify the volume levels for ALARM stream in receiver mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Wired Headset Mode** - Specify the volume levels for ALARM stream in Wired Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Bluetooth Headset Mode** - Specify the volume levels for ALARM stream in Bluetooth Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **UI Label of STREAM_VOICECALL** - Provide the UI label for the VOICECALL stream\n* **UI Icon of STREAM_VOICECALL** - Provide the URL to the icon image for the VOICECALL stream\t\n* **Control Parameters of STREAM_VOICECALL** - Specify whether the stream is visible (1) or not (0) to the user\n* **Minimum, Maximum and Preset Volume Level for Speaker Mode** - Specify the volume levels for VOICECALL stream in speaker mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Receiver Mode** - Specify the volume levels for VOICECALL stream in receiver mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Wired Headset Mode** - Specify the volume levels for VOICECALL stream in Wired Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Bluetooth Headset Mode** - Specify the volume levels for VOICECALL stream in Bluetooth Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **UI Label of Decode Beep Virtual Volume Scale** - Provide the UI label for Decode Beep Virtual Volume Scale\n* **UI Icon of Decode Beep Virtual Volume Scale** - Provide the URL to the icon image for Decode Beep Virtual Volume Scale\n* **Control Parameters of STREAM_VVS** - Specify whether the stream is visible (1) or not (0) to the user\n* **Minimum, Maximum and Preset Volume Level for Speaker Mode** - Specify the volume levels for Decode Beep Virtual Volume Scale in speaker mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Receiver Mode** - Specify the volume levels for Decode Beep Virtual Volume Scale in receiver mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Wired Headset Mode** - Specify the volume levels for Decode Beep Virtual Volume Scale in Wired Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n* **Minimum, Maximum and Preset Volume Level for Bluetooth Headset Mode** - Specify the volume levels for Decode Beep Virtual Volume Scale in Bluetooth Headset mode (in the order of &quot;min, max, preset&quot; separated by comma and as positive integers less than 256, e.g. &quot;10, 1, 5&quot;)\n\n### Remove an Audio UI Profile\n* **Name of the Audio UI Profile** - Provide a the name of the profile you wish to remove\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=AudioMgr&os=All&embed=true\"></iframe> \n\n\n\n\n\n\n\n\n"},{"key":"guide-profiles-battery","name":" Battery Manager Profile Feature Reference","md":"# Battery Manager Profile Feature Reference\n\n## Overview\nZebra's Device batteries store information in their internal memory, for instance, the number of charge cycles a battery has accumulated.  Zebra's Android devices expose this through a battery settings menu that displays the accumulated information.  These Android devices are configured with a Decommission Threshold Value that is the maximum number of charge cycles a battery can accumulate before being flagged as a battery that should be replaced. Battery Manager allows the developer to modify that Decommission Threshold from its factory setting.\n\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Set Battery Usage Decommissioned Threshold\n* Set Battery Usage Decommissioned Threshold\n\n## Battery Usage Decommissioned Threshold\nThis setting would be used to modify the Decommissioned Threshold for Zebra Smart Batteries.\n\n* Set the threshold value of the Battery Usage Number as an Integer ranging from 0 to 65535 (value 0 for no change or not applicable)\n\n## Battery Usage Decommissioned Threshold\nThis setting would be used to modify the Decommissioned Threshold for Zebra Gifted Batteries.\n\n* Set the threshold value of the Battery Health Percentage as an Integer ranging from 0 to 100 (value 0 for no change or not applicable)\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=BatteryMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-browser","name":" Browser Manager Profile Feature Reference","md":"# Browser Manager Profile Feature Reference\n\n## Overview\n\nThe Browser Manager feature allows your application to control the web browser on the device. For example you can set the browser homepage. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n* Set Default homepage\n* Turn on/off Remember Password\n* Turn on/off save form data\n\n## Set Default homepage\nWhen entering a url for the homepage, limit the string to 2000 characters.\n\n## Remember Password\nThe Android browser can save and recall values placed in a password field. This profile feature will \nallow you to enable/disable the browsers password save/recall feature.\n\n\n## Save form data\nThe Android browser can save and recall values placed into form fields. This profile feature will \nallow you to enable/disable the browsers form field save/recall feature.\n\n## Feature Compatibility\n\n<iframe src=\"compare.html#mx=4.3&csp=BrowserMgr&os=All&embed=true\"></iframe> \n\n\n\n"},{"key":"guide-profiles-camera","name":" Camera Manager Profile Feature Reference","md":"# Camera Manager Profile Feature Reference\n\n## Overview\n\nThe Camera Manager feature allows your application to control access to the cameras in the device. For example you can disable the user from using all cameras on the device. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable/Disable the use of all Cameras\n* Enable/Disable the use of the Front Camera\n* Enable/Disable the use of the Rear Camera\n\n## All Cameras\nThis option will allow you to enable or disable both front and rear cameras on a device. \n\n## Front Camera\nThis option will allow you to enable/disable the front camera.\n\n## Rear Camera\nThis option will allow you to enable/disable the rear camera.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=CameraMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-cellular","name":" Cellular Manager Profile Feature Reference","md":"# Cellular Manager Profile Feature Reference\n\n## Overview\n\nThe Cellular Manager feature allows you to configure options of the  cellular radio on your device. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Data Roaming State on/off\n* Data Roaming Enabled/Disabled \n* Background Data State on/off\n* Background Data Enabled/Disabled \n\n## Data Roaming\nThis feature will allow you to control a devices ability to use cellular data while roaming. You can independently set the state as well as if it is enabled or disabled.\n\n## Background Data\nThis feature will allow your application to control background data usage on devices equipped with a cellular radio. You can independently set the state as well as if it is enabled or disabled.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=CellularMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-cert","name":" Certificate Manager Profile Feature Reference","md":"# Certificate Manager Profile Feature Reference\n\n## Overview\n\nThe Cert Manager feature allows your application to install or uninstall certificates and initialize the Android key store. You can use digital certificates to identify your device for a variety of purposes, including VPN or Wi-Fi network access as well as authentication to servers by apps such as Email or Chrome. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Install Certificate\n* Uninstall Certificate\n* Initialize Android Keystore\n* Adjust System Clock\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Initialize Android Keystore\nWhen you initialize the Android keystore you create a new keystore replacing any previously existing one.  Before installing or uninstalling certificates, a keystore must exist. You can choose to perform this action as a separate EMDK profile or include the Certificate Manager feature multiple times in one profile.\n\n### Keystore Password\nKeystore Password is a password required to initialize the Android Keystore.\n\n## Install Certificate\n\n### Certificate Alias\n\n* Provide the name(alias) that will uniquely identify the certificate. The old certificate with same alias name will be replaced by the new certificate.\n* Dynamic - The name of the cert is dynamically generated (This is currently not supported)\n\n#### Alias Handling Issues\nDue to current limitations of the Certificate Manager Feature (in an EAP-TLS scenario), it is not possible to \"override\" the Alias that is assigned to a Client Certificate and Private Key when they are installed into the Android KeyStore\n\nThe only way to determine the actual Alias that is assigned to a Client Certificate and Private Key when they are installed into the Android KeyStore is to examine the Android KeyStore after installation to determine which Alias was used:\n\n1. The same Alias will ALWAYS be assigned to a given Client Certificate and Private Key, no matter when, or on which device, it is installed\n\n2. Whenever a different Client Certificate is used, a different Alias will generally be assigned to the Client Certificate and Private Key\n\n#### Manually Determining the Certificate Alias\nA device can be used to capture the alias being used for the certificate being installed. It is recommended that the key store be cleared before performing these steps (Settings/Security/Clear Credentials)\n\n1. Use Certificate Manager to install the certificate onto a device.\n2. Navigate to Settings/Wi-Fi/'+'' to add a network\n3. Scroll to security, tap and select 802.1x EAP\n4. Scroll to EAP method, tap and select TLS\n5. Scroll to client certificate, tap and note a drop down box with \"(unspecified)\" and the alias of the installed certificate. The alias listed can become the value to use as the certificate when using WiFiConfig to configure a profile that uses EAP-TLS.\n\n###Certificate Type  \nType of certificate to be installed:\n\n* CA Certificate (*.PEM)\n* Client Certificate (*.PEM)\n* Client Certificate and Private Key (*.PFX)\n* Client Certificate and Private Key (*.P12)\n* Client Certificate and Private Key (*.PKCS12)\n\n>Note: Be sure to initialize the keystore the first time when installing certificate types with private keys (.PFX,.P12,.PKCS12)\n\n### Certificate method\nReference certificate file - method used to install a certificate. A file must exists on the device that contains the certificate data.\n\n### Certificate File\nSpecify the path and name of the to the certificate file that resides on the device.\n\n### Private Key Password\nPassword required to decrypt the private key (*.PFX, *.P12, *.PKCS12).\n\n## Uninstall Certificate\n\n### Certificate Alias\nProvide the name(alias) that will uniquely identify the certificate. The key store or trusted CA store will be searched for a record with the same alias name. If the record is found, it removes the key store or trusted CA store. \n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=CertMgr&os=All&embed=true\"></iframe> \n"},{"key":"guide-profiles-clock","name":" Clock Manager Profile Feature Reference","md":"# Clock Manager Profile Feature Reference\n\n## Overview\n\nClock allows for a programmatic way to set the date and time. To account for time zone nuances including daylight saving time, Clock expects the values for date and time to be entered as normalized values to UTC (GMT) time. In other words, the date and time set as parameters for Clock must be the UTC (GMT) equivalent of the local time being set. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n### Main Functionality\n\n* Set the Time Zone\n* Set the Date\n* Set the Time\n* Enable Auto Time\n* Disable Auto Time\n* Set NTP Server Address\n* Set Sync Interval\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## AutoTime\nUse an NTP server to automatically set the time, date and timezone. The NTP server will be synced at the specified interval.\n\n* NTP Server - the IP address of the NTP server\n* SyncInterval - time will be automatically synced at this interval\n\n## TimeZone \nProvide the TimeZone that the device should be set to. Note: The supported values for time zone are the same as Android supported values. For example, GMT-5 or Olson name such as America/New_York.\n\n## Date \nProvide the Date the device will be set to when the profile is enabled. It must have a length of 10 and must be in the format 'yyyy-MM-dd' (for example : 2014-12-31). It must be specified in UTC (Universal Time Coordinates) and not in LTC (Local Time Coordinates).\n\n## Time\nProvide the Time the device will be set to when the profile is enabled. It must have a length of 8 and must be in the format HH:mm:ss (for example : 23:59:59). It must be specified in UTC (Universal Time Coordinates) and not in LTC (Local Time Coordinates).\n\n## Usage Notes\n\n###Example #1\nWe want to set the clock with the following settings:\n\n* Set the date to 15-Jan-2010\n* Set the time to 2:15PM local time\n* Set the time zone to New York, New York, USA\n\n15-Jan is eastern standard time in New York and not daylight saving time meaning it is GMT-04:00. So the parameters to use for Clock would be:\n\n* TimeZone = New York, New York, USA\n* Date = 15-Jan-2010 (2010-01-15)\n* Time = 6:15PM (18:15:00)\n\n###Example #2\nWe want to set the clock with the following settings:\n\n* Set the date to 11-Jul-2014\n* Set the time to 2:55AM local time\n* Set the time zone to Bangalore, India\n\nThe time zone for Bangalore is GMT+05:30. So the parameters to use for Clock would be:\n\n* TimeZone Bangalore, India\n* Date = 10-Jul-2010 (2010-07-10)\n* Time = 9:25PM (21:25:00)\n\nNote the change of date as well as time. In this case, as the device converts this to local time, the date and time will both automatically be set properly when the offset is applied.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=Clock&os=All&embed=true\"></iframe> \n"},{"key":"guide-profiles-component","name":" Component Manager Profile Feature Reference","md":"# Component Manager Profile Feature Reference\n\n## Overview\n\nThe Component Manager feature allows you to manage the state of Components, such as a devices Ethernet Port\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* EthernetUsage\n* EthernetState\n\n## EthernetUsage\nThis feature can be used to enable or disable Ethernet Port Usage.\n\n**Options**:\n\n* Enable\n* Disable\n\n## EthernetState\nOnce an Ethernet Port Usage enabled, This feature can be used to turn the Ethernet Port On or Off.\n\n**Options**:\n\n* On\n* Off\n\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=ComponentMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-devadmin","name":" Device Admin Profile Feature Reference","md":"# Device Admin Profile Feature Reference\n\n## Overview\n\nThe Device Admin feature allows your application to manage configuration settings on the device.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n* Set Screen-Lock timeout interval\n* Allow/Disallow Application Installs from Unknown sources\n* Turn on/off Device Administrator\n\n> NOTE: The actual policy effective on the device is the one set by the most restrictive result requested by all active device admin apps.\n\n\n\n## Screen-Lock Timeout\nThis profile feature will allow your application set the amount of time a device can be idle before the Screen is locked.\n\n## App Installs from Unknown sources\nThis profile feature will allow your application to control installation of applications from \"Unknown Sources\".  \n\n**Install methods considered Unknown**\n\n* Install from ADB\n* Download and install from locations other than Google play\n* Receive and install from email\n* Install via APIs\n* Install via File Browser, for packages that are obtained in various ways, e.g. from SD card, from USB (UMS, ADB, or others) or any other wired data connection, etc.\n\n\n\n## Device Administrator\nAn Android application that uses Android Device Admin API's must also be added to an Device Admin list on a device. This profile feature will allow you to add or remove an application from the Device Admin list. You must provide the package name of the application to be added as a Device Admin. You can also specify a specific class name of the application.\n\n> NOTE: The state of being a device admin or not for an application does not restrict an application from being installed or launched. \n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=DevAdmin&os=All&embed=true\"></iframe> \n\n"},{"key":"guide-profiles-dhcp","name":" DHCP Option Manager Profile Feature Reference","md":"# DHCP Option Manager Profile Feature Reference\n\n## Overview\n\nThe DHCP Option Manager feature allows you to control various DHCP configuration options.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Option code 12\n* Option code 77\n* Option code 28\n* Option code 42\n\n##Option code 12\n* **Send Host Name**\n\t* Host Name Option Value - Specify the host name you would like the client to send.\n\n>Note: HostName identifies a client on a network.\n\n##Option code 77\n* **Send User Class**\n\t* User Class Value - Specify the Class name you would like to send\n\n>Note: The class name value would allow a DHCP server to select an appropriate address pool to assign an address to the client and appropriate configuration parameters.\n\n##Option code 28\n* **Request Broadcast Address**\n\n##Option code 42\n* **Request NTP Server**\n* **Request TFTP Server Name**\n* **Request Boot File Name**\n* **Request Domain Search**\n* **Request TFTP Server Address**\n\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=DHCPMgr&os=All&embed=true\"></iframe> \n\n\n\n"},{"key":"guide-profiles-display","name":" Display Manager Profile Feature Reference","md":"# Display Manager Profile Feature Reference\n\n## Overview\n\nThe Display Manager feature allows your application to control the screen timeout value to conserve power.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n* Set the Screen Timeout Interval\n\n\n##Screen Timeout Interval\nThis profile feature will allow your application to set how many seconds a device can be inactive before the screen turns off.\n\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=DisplayMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-encrypt","name":" Encrypt Manager Profile Feature Reference","md":"# Encrypt Manager Profile Feature Reference\n\n## Overview\n\nThe Encrypt Manager allows the developer to set encryption policies on a device through MX XML. For example a developer can create an EFS for storing application data.  \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Install/Revoke Encryption Key\n* Create/Delete EFS (Encrypted File System)\n* Encrypt SD Card\n* Format SD Card\n\n##Install Key\nThis profile feature allows your application to install a new encryption key or revoke a named key that resides in the key store. When installing a key, the value is optional. A provided key value should be a HEX string with a length of 64 bytes. If a value is not provided, a random key will be generated for a given key name. This feature will fail to apply if a key of the same name already resides in the devices key store. After successfully installing a key, all EFS's using that key will be mounted. If multiple unmounted EFS use the same mount point, only the first will be mounted.\n\n\n### Install Key?\n* Install Key Name - Provide a name for the key you wish to install.\n* Install Key Value - Provide the key you wish to install.\n\n### Revoke Key?\n* Revoke Key Name(s) - Provide the key name or names (separated by commas) you wish to revoke.\n\n\n> Note: After successfully revoking a key, all EFS using that key will be unmounted.\n\n##Create EFS\nThis profile feature allows your application to create an Encrypted File System (EFS) on a device.  Provide a name for the new EFS, a mount point where the EFS should be mounted, a storage type (SDcard or Internal), the name of the key that will be used for encryption, and a size for the EFS stated in MB. The provided EFS size must be at least 1MB and cannot exceed 4096MB.\nThe process of creating the EFS takes time. Access to the EFS will be denied during the creation process.\n\n* **Create EFS**\n\t* EFS Name - Provide a name for the EFS you wish to create\n\t* EFS encryption Key Name - Provide the name of the encryption key you would like to use to encyrpt the new EFS\n\t* EFS Location (internal/SDcard) - Select a location where the new EFS should be created\n\t* Mount point for EFS - Provide a mount point for you wish to use for the new EFS\n\t* Size of EFS in MB - Provide a size in MB(1-4095) for the new EFS\n\n\n>Note: EFS creation may fail for any of the following conditions**\n\t* Duplicate EFS name; (EFS's with the same name can coexist on different supporting file systems, but cannot coexist on the same FS.)\n\t* EFS storage type is not available (e.g. no SD card inserted and mounted)\n\t* Not enough space on supporting file system\n\t* Key does not exist\n\t* Creating EFS on encrypted SDCard\n\t* Invalid parm values, e.g. EFS size too big or too small or not an integer number\n\t* Unmatched mount point and EFS storage type\n\n* **Delete EFS**\n\t* Delete EFS Name - Provide the name of the EFS you wish to delete.\n\t* EFS Location - Select a location of where the EFS you wish to delete resides.\n\n\n## SD Card Operation\n###Encrypt SD Card\n* **Encrypt SDcard**\n\t* key to encrypt SDcard - Provide the name of the key to use to encrypt the sdcard.\n\n>Note: This process will format and encrypt the SDcard, therefor all `existing data on the SDCard will be lost`.\n\n>The process of encrypting the SDCard takes time. Access to the encrypted SDCard will be denied during the creation process. When encrypting an SDCard that was previously encrypted, the SDCard will be re-formated and re-encrypted, as a result, all existing data will be lost.\n\n**Creation of an Encrypted SDCard may fail for any of the following conditions**\n\n* SDCard is not inserted;\n* SDCard is not mounted (e.g. UMS is in use)\n* Key name is invalid.\n\n###Format SD Card\nThis profile feature will allow your application format an SDCard. \n\n>Note: When formating an encrypted SDCard, the result would be a formated **un-encrypted** SDCard.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=EncryptMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-gprs","name":" GPRS Manager Profile Feature Reference","md":"# GPRS Manager Profile Feature Reference\n\n## Overview\n\nThe GPRS feature allows you to add or remove APNs to your device. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Add or Update Named APN\n* Remove APN\n* Remove all APNs\n* Set Default APN\n* Set Accesses Point Name, User Name, and Password\n\n## APN Action\nThis setting allows you to manage the APN configuration on the device:\n\n* Add/replace APN\n* Remove existing named APN\n* Remove all existing APNs\n\n## GPRS Carrier \nOptions for GPRS carrier for the APN.\n\n* ATT\n* T-Mobile\n* Custom\n\n>Note: For ATT and T-Mobile option the user and password filed are required.\n\n## APN Name \nProvide the name that the APN should be set to. Used to identify the APN settings for deleting existing APN or adding/replacing. Must be unique on the device. \n\n## Replace if Exists \nThis check box provides the option to replace an existing APN.\n\n* Check Box is marked: Delete the APN for the device and set the new APN.\n* Check Box is not marked: Don't add new APN if already there is an APN with the same name.\n\n## Make Default APN \nThis check box provides the option to set the new APN to be Preferred.\n\n## Access Point \nProvide the access point name that the APN should be set to (ex: internet3.voicestream.com).\n\n## User Name\nProvide the user name that the APN should be set to.\n\n## Password\nProvide the password that the APN should be set to.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=GprsMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-keymap","name":" Key Mapping Manager Profile Feature Reference","md":"# Key Mapping Manager Profile Feature Reference\n\n## Overview\n\nThe Key Mapping Manager feature allows \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* zsdf\n* asdf\n\n## asdf\n\n## asdf\n\n\n## Modifiable Keys\n\n* **0-9**\n* **A-Z**\n\n* **F1**\n* **F2**\n* **F3**\n* **F4**\n* **F5**\n* **F6**\n* **F7**\n* **F8**\n* **F9**\n* **F10**\n* **F11**\n* **F12**\n* **ENTER**\n* **UP**\n* **DOWN**\n* **LEFT**\n* **RIGHT**\n* **ESC**\n* **BACKSPACE**\n* **DOT** (Period)\n* **STAR**\n* **POUND**\n* **SPACE**\n* **RETURN**\n* **CLR** (Clear)\n* **FIELD_EXIT**\n* **ALT**\n* **CTRL** (Control)\n* **SHIFT**\n* **BLUE**\n* **ORANGE**\n* **GREEN** (Green Dot)\n* **RED** (Red Dot)\n* **VOLUMEUP** (Volume Up)\n* **VOLUMEDOWN** (Volume Down)\n* **SCAN**\n* **GRIP_TRIGGER**\n* **LEFT_TRIGGER_1** (Button L1)\n* **LEFT_TRIGGER_2** (Button L2)\n* **RIGHT_TRIGGER_1** (Button R1)\n* **HEADSET_HOOK** (Headset Button)\n* **BACK**\n* **HOME**\n* **MENU**\n* **SEARCH**\n* **KEYLIGHT** (Keyboard Backlight)\n* **LAMP** (Display Backlight)\n\n##KeyCodes\n\n* **0-9**\n* **A-Z**\n* **Enter\" />\n        <item text=\"61\"                 ui=\"Tab\" />\n        <item text=\"62\"                 ui=\"Space\" />\n        <item text=\"111\"                ui=\"Escape\" />\n        <item text=\"67\"                 ui=\"Delete\" />\n        <item text=\"131\"                ui=\"F1\" />\n        <item text=\"132\"                ui=\"F2\" />\n        <item text=\"133\"                ui=\"F3\" />\n        <item text=\"134\"                ui=\"F4\" />\n        <item text=\"135\"                ui=\"F5\" />\n        <item text=\"136\"                ui=\"F6\" />\n        <item text=\"137\"                ui=\"F7\" />\n        <item text=\"138\"                ui=\"F8\" />\n        <item text=\"139\"                ui=\"F9\" />\n        <item text=\"140\"                ui=\"F10\" />\n        <item text=\"141\"                ui=\"F11\" />\n        <item text=\"142\"                ui=\"F12\" />\n        <item text=\"144\"                ui=\"NUMPAD 0\" />\n        <item text=\"145\"                ui=\"NUMPAD 1\" />\n        <item text=\"146\"                ui=\"NUMPAD 2\" />\n        <item text=\"147\"                ui=\"NUMPAD 3\" />\n        <item text=\"148\"                ui=\"NUMPAD 4\" />\n        <item text=\"149\"                ui=\"NUMPAD 5\" />\n        <item text=\"150\"                ui=\"NUMPAD 6\" />\n        <item text=\"151\"                ui=\"NUMPAD 7\" />\n        <item text=\"152\"                ui=\"NUMPAD 8\" />\n        <item text=\"153\"                ui=\"NUMPAD 9\" />\n        <item text=\"154\"                ui=\"NUMPAD Divide\" />\n        <item text=\"155\"                ui=\"NUMPAD Multiply\" />\n        <item text=\"156\"                ui=\"NUMPAD Subtract\" />\n        <item text=\"157\"                ui=\"NUMPAD Add\" />\n        <item text=\"158\"                ui=\"NUMPAD Period\" />\n        <item text=\"159\"                ui=\"NUMPAD Comma\" />\n        <item text=\"160\"                ui=\"NUMPAD Enter\" />\n        <item text=\"161\"                ui=\"NUMPAD Equals\" />\n        <item text=\"162\"                ui=\"NUMPAD Left Parenthesis\" />\n        <item text=\"163\"                ui=\"NUMPAD Right Parenthesis\" />\n        <item text=\"19\"                 ui=\"DPAD Up\" />\n        <item text=\"20\"                 ui=\"DPAD Down\" />\n        <item text=\"21\"                 ui=\"DPAD Left\" />\n        <item text=\"22\"                 ui=\"DPAD Right\" />\n        <item text=\"23\"                 ui=\"DPAD Center\" />\n        <item text=\"122\"                ui=\"Move Home\" />\n        <item text=\"123\"                ui=\"Move End\" />\n        <item text=\"92\"                 ui=\"Page Up\" />\n        <item text=\"93\"                 ui=\"Page Down\" />\n        <item text=\"124\"                ui=\"Insert\" />\n        <item text=\"112\"                ui=\"Forward Delete\" />\n        <item text=\"10027\"              ui=\"Blue\" />\n        <item text=\"10028\"              ui=\"Orange\" />\n        <item text=\"10029\"              ui=\"Grey\" />\n        <item text=\"10030\"              ui=\"Alt\" />\n        <item text=\"10031\"              ui=\"Control\" />\n        <item text=\"10032\"              ui=\"Shift\" />\n        <item text=\"59\"                 ui=\"Left Shift\" />\n        <item text=\"60\"                 ui=\"Right Shift\" />\n        <item text=\"57\"                 ui=\"Left Alt\" />\n        <item text=\"58\"                 ui=\"Right Alt\" />\n        <item text=\"113\"                ui=\"Left Control\" />\n        <item text=\"114\"                ui=\"Right Control\" />\n        <item text=\"117\"                ui=\"Meta Left\" />\n        <item text=\"118\"                ui=\"Meta Right\" />\n        <item text=\"115\"                ui=\"Caps Lock\" />\n        <item text=\"143\"                ui=\"Num Lock\" />\n        <item text=\"116\"                ui=\"Scroll Lock\" />\n        <item text=\"120\"                ui=\"SysRq\" />\n        <item text=\"121\"                ui=\"Break\" />\n        <item text=\"119\"                ui=\"Function\" />\n        <item text=\"81\"                 ui=\"Plus\" />\n        <item text=\"69\"                 ui=\"Minus\" />\n        <item text=\"70\"                 ui=\"Equals\" />\n        <item text=\"71\"                 ui=\"Left Bracket\" />\n        <item text=\"72\"                 ui=\"Right Bracket\" />\n        <item text=\"68\"                 ui=\"Grave\" />\n        <item text=\"76\"                 ui=\"Slash\" />\n        <item text=\"73\"                 ui=\"Backslash\" />\n        <item text=\"74\"                 ui=\"Semicolon\" />\n        <item text=\"75\"                 ui=\"Apostrophe\" />\n        <item text=\"55\"                 ui=\"Comma\" />\n        <item text=\"56\"                 ui=\"Period\" />\n        <item text=\"17\"                 ui=\"Star\" />\n        <item text=\"18\"                 ui=\"Pound\" />\n        <item text=\"77\"                 ui=\"At\" />\n        <item text=\"4\"                  ui=\"Back\" />\n        <item text=\"125\"                ui=\"Forward\" />\n        <item text=\"3\"                  ui=\"Home\" />\n        <item text=\"82\"                 ui=\"Menu\" />\n        <item text=\"210\"                ui=\"Calculator\" />\n        <item text=\"64\"                 ui=\"Explorer\" />\n        <item text=\"65\"                 ui=\"Envelope\" />\n        <item text=\"174\"                ui=\"Bookmark\" />\n        <item text=\"209\"                ui=\"Music\" />\n        <item text=\"5\"                  ui=\"Call\" />\n        <item text=\"27\"                 ui=\"Camera\" />\n        <item text=\"84\"                 ui=\"Search\" />\n        <item text=\"207\"                ui=\"Contacts\" />\n        <item text=\"208\"                ui=\"Calendar\" />\n        <item text=\"24\"                 ui=\"Volume Up\" />\n        <item text=\"25\"                 ui=\"Volume Down\" />\n        <item text=\"164\"                ui=\"Volume Mute\" />\n        <item text=\"221\"                ui=\"Brightness Up\" />\n        <item text=\"220\"                ui=\"Brightness Down\" />\n        <item text=\"26\"                 ui=\"Power\" />\n        <item text=\"223\"                ui=\"Sleep\" />\n        <item text=\"224\"                ui=\"Wakeup\" />\n        <item text=\"79\"                 ui=\"Headset\" />\n        <item text=\"228\"                ui=\"Push-to-talk\" />\n        <item text=\"83\"                 ui=\"Notification\" />\n        <item text=\"80\"                 ui=\"Camera Focus\" />\n        <item text=\"85\"                 ui=\"Media Play/Pause\" />\n        <item text=\"86\"                 ui=\"Media Stop\" />\n        <item text=\"87\"                 ui=\"Media Next\" />\n        <item text=\"88\"                 ui=\"Media Previous\" />\n        <item text=\"89\"                 ui=\"Media Rewind\" />\n        <item text=\"90\"                 ui=\"Media Fast-Forward\" />\n        <item text=\"126\"                ui=\"Media Play\" />\n        <item text=\"127\"                ui=\"Media Pause\" />\n        <item text=\"128\"                ui=\"Media Close\" />\n        <item text=\"129\"                ui=\"Media Eject\" />\n        <item text=\"130\"                ui=\"Media Record\" />\n        <item text=\"102\"                ui=\"Button L1\" />\n        <item text=\"103\"                ui=\"Button R1\" />\n        <item text=\"104\"                ui=\"Button L2\" />\n        <item text=\"105\"                ui=\"Button R2\" />\n        <item text=\"96\"                 ui=\"Button A\" />\n        <item text=\"97\"                 ui=\"Button B\" />\n        <item text=\"98\"                 ui=\"Button C\" />\n        <item text=\"99\"                 ui=\"Button X\" />\n        <item text=\"100\"                ui=\"Button Y\" />\n        <item text=\"101\"                ui=\"Button Z\" />\n        <item text=\"106\"                ui=\"Left Thumb Button\" />\n        <item text=\"107\"                ui=\"Right Thumb Button\" />\n        <item text=\"108\"                ui=\"Start Button\" />\n        <item text=\"109\"                ui=\"Select Button\" />\n        <item text=\"110\"                ui=\"Mode Button\" />\n        <item text=\"188\"                ui=\"Gamepad Button 1\" />\n        <item text=\"189\"                ui=\"Gamepad Button 2\" />\n        <item text=\"190\"                ui=\"Gamepad Button 3\" />\n        <item text=\"191\"                ui=\"Gamepad Button 4\" />\n        <item text=\"192\"                ui=\"Gamepad Button 5\" />\n        <item text=\"193\"                ui=\"Gamepad Button 6\" />\n        <item text=\"194\"                ui=\"Gamepad Button 7\" />\n        <item text=\"195\"                ui=\"Gamepad Button 8\" />\n        <item text=\"196\"                ui=\"Gamepad Button 9\" />\n        <item text=\"197\"                ui=\"Gamepad Button 10\" />\n        <item text=\"198\"                ui=\"Gamepad Button 11\" />\n        <item text=\"199\"                ui=\"Gamepad Button 12\" />\n        <item text=\"200\"                ui=\"Gamepad Button 13\" />\n        <item text=\"201\"                ui=\"Gamepad Button 14\" />\n        <item text=\"202\"                ui=\"Gamepad Button 15\" />\n        <item text=\"203\"                ui=\"Gamepad Button 16\" />\n        <item text=\"211\"                ui=\"Zenkaku/Hankaku\" />\n        <item text=\"212\"                ui=\"Eisu\" />\n        <item text=\"213\"                ui=\"Muhenkan\" />\n        <item text=\"214\"                ui=\"Henkan\" />\n        <item text=\"215\"                ui=\"Katakana/Hiragana\" />\n        <item text=\"216\"                ui=\"Yen\" />\n        <item text=\"217\"                ui=\"Ro\" />\n        <item text=\"218\"                ui=\"Kana\" />\n        <item text=\"95\"                 ui=\"Switch Charset\" />\n        <item text=\"94\"                 ui=\"Picture Symbols\" />\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=KeyMapMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-persistence","name":" Persistence Manager Profile Feature Reference","md":"# Persistence Manager Profile Feature Reference\n\n## Overview\n\nThe Persist Manager is used to create and remove persistent profile features. These features and their parameters will survive and be automatically applied after a 'Enterprise Reset'. \n\n>Note:  \n>Data Capture Manager profile features will not be persisted.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Configure Dealt Device Settings After an Enterprise Reset\n* Add a Persistent Settings Profile\n* Remove a Persistent Settings Profile\n* Enable a Persistent Settings Profile\n* Disable a Persistent Settings Profile\n* Set if XML should Persist if Error\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Make Current XML Persistent\nThis will make the specified Profile features persistent. The combination of Name, Version and Order will be used to 'identify' the profile set to be persisted. The same combination must be used when trying to remove the features from being persisted.\n\n* Persist as Name - This name is used to identify the profile features that will be persisted, so that you can reference it for removal from the persist list.\n\t* Generic/Absolute - can be used to further clarify the name/scenario\n\t* Staging-Specific/Relative - can be used to further clarify the name/scenario\n* Persist as Version - Provide the version of the profile features that will be persisted, so that you can reference it for removal from the persist list.\n* Persist as Order - Provide the optional order in which the profile features with the specified name will be persisted.\n* Persist if Error - Specifies whether the profile features will be persisted if any errors occur.\n\n\n## Remove Persistent XML\nThis will remove the specified profile features from being persistent. The combination of the Name, Version and Order features must match a previously persisted profile with those same features.\n\n* Persist as Name - This name is used to identify the persisted profile setting to remove\n\t* Generic/Absolute \n\t* Staging-Specific/Relative \n* Persist as Version - The version of the persisted profile setting to be removed\n* Persist as Order - The optional order of the persisted profile setting to be removed\n\n## Enable the specified persistent profile\nIt will enable the persistent profile that you specify with the help of supply details about a specific persist action to be performed.\n\n## Disable the specified persistent profile\nIt will disable the specified persistent profile with the help of supply details about a specific persist action to be performed.\n\n## Usage Notes\n###Using PersistsManager on TC55 after performing a FactoryReset\nThe following issue is limited to the TC55 only: \n \nDuring the installation on the TC55, the EMDK Device Runtime package creates the \"enterprise/usr/persist/\" folder required for the PersistManager feature to function.  If a factory reset is done after installing the EMDK Device Runtime, this folder will get deleted and the PersistManager will no longer work. \n \nThis problem can be fixed by reinstalling the EMDK Device Runtime Package on the TC55.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=PersistMgr&os=All&embed=true\"></iframe> \n\n"},{"key":"guide-profiles-power","name":" Power Manager Profile Feature Reference","md":"# Power Manager Profile Feature Reference\n\n\n## Overview\n\nThis feature allows you to put the device into Sleep mode, re-power or perform an OS Update. The action will be performed when the configuration is set.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Put the Device to Sleep\n* Reboot the Device\n* Enterprise Reset a Device\n* Factory Reset a Device\n* Wipe a Device\n* Update the OS\n\n\n## Do Nothing\nWill not perform any action\n\n## Sleep Mode\nWill put the device into Sleep mode.\n\n## Reboot\nWill reboot or re-power the device.\n\n## Enterprise Reset\nWill perform an Enterprise Reset.\n\n> Note: This feature is supported on devices that are running KitKat versions of Android like the TC70.\n\n## Factory Reset\nWill perform a Factory Reset.\n\n> Note: This feature is supported on devices that are running KitKat versions of Android like the TC70.\n\n## Full Device Wipe\nWill perform a full device wipe.\n\n> Note: This feature is supported on devices that are running KitKat versions of Android like the TC70.\n\n## OS Update\nWill initiate an OS Update using the provided OS Update Zip File\n\n* OS Update Zip File - The full path to the OS Update Zip File that resides on the device\n\n> Note: The OS Update file should already exist on the device. When using this feature on the TC55 the update package must be placed on the external SD card. Any attempt to use the internal SD card for this purpose will fail.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=PowerMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-powerkey","name":" PowerKey Manager Profile Feature Reference","md":"# PowerKey Manager Profile Feature Reference\n\n\n## Overview\n\nThe PowerKey Manager feature allows your application to control which options appear on the power menu on the device.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Show/Hide Airplane Mode Power Menu Option\n* Show/Hide Touch Panel Power Menu Option\n* Show/Hide Safe Mode Power Menu Option\n* Enable/Disable Auto Screen Lock when Device is Powered off using the Power Key\n\n> The Power menu is displayed by holding down the power button on a device\n\n##Airplane Mode\nThis profile feature will allow your application to control the visibility of the Airplane Mode option in the Power Key Menu\n\n##Touch Panel\nThis profile feature will allow your application to control the visibility of the Touch Panel option in the Power Key Menu.\n\n##Safe Mode\nThis profile feature will allow your application to control the visibility of the Safe Mode option in the Power Key Menu.\n\n##Auto Screen Lock on Power Key Option\nThis profile feature will allow your application to control the visibility of the Auto Screen Lock option in the settings menu.\n\n##Auto Screen Lock on Power Key State\nThis profile feature will allow your application to control the visibility of the Auto Screen Lock option in the Power Key Menu( Menu that appears when power button is long pressed).\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=PowerKeyMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-profileactivity","name":" Activity Selection Profile Feature Reference","md":"# Activity Selection Profile Feature Reference\n\n## Overview\n\nWhen creating a profile for [Barcode](#guide-profiles-profilebarcode) or [MSR](#guide-profiles-profilemsr) data capture you can configure an Activity Selector to automate the process of activating and deactivating the profile. This allows for automated profile management of complex applications. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n##Activity Selector\n\n* Applications - List of applications this profile may be active during. \n\t* Applications names are the formal package definition of the application. For example \"com.symbol.profiledatacapturesample1\". \n* Activities -  List of activities within the selected application that a profile should be active for. \n\t*  For Example \"MainActivity\"."},{"key":"guide-profiles-profilebarcode","name":" Barcode Profile Feature Reference","md":"# Barcode Profile Feature Reference\n\n## Overview\nIn order to get Barcode data in your application, you must create a profile with two profile features selected:\n\n* Barcode\n* [Keystroke](#guide-profiles-profilekeystroke),[Intent](#guide-profiles-profileintent),[IP](#guide-profiles-profileIP) (Output)\n\nThe `Barcode` feature in the Profile Manager is responsible for reading data from the device's integrated bar code scanner and supports different types of bar code readers including laser, imager and internal camera. It also contains detailed parameters for scanner behavior as well as individual barcode symbology parameters.\n\nThe `Intent`, `Keystroke` or `IP` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n* IP - IP Output allows DataWedge to send captured data to a host computer via a network connection. Captured data can be sent over an IP network to a specified IP address and port using either TCP or UDP transport protocols.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Enabled\nEnables or disables this feature. Default is enabled.\n\n## Scanner Selection\nConfigures which scanning device to use for data capture.\n\n* Auto - Automatically determines the best scanning device. If a Scan Module or Scan/MSR Module is installed on the MC40, then the 2D imager is selected. Otherwise the camera is selected.\n* Camera Scanner - Scanning is performed with the rear-facing camera.\n* 2D Imager - Scanning is performed using the installed Scan or Scan/MSR module.\n\n## Decoders\nConfigures which bar code decoders are enabled or disabled. For best performance disable all unnecessary decoders. By default the most commonly used decoders are enabled (shown below with an asterisk). The supported decoders are:\n\n* Australian Postal \n* Aztec\n* Canadian Postal\n* Chinese 2 of 5 \n* Codabar*\n* Code 11\n* Code 39*\n* Code 93 \n* Code 128* \n* Composite AB\n* Composite C \n* Datamatrix* \n* Discrete 2 of 5 \n* Dutch Postal\n* EAN-8*\n* EAN-13*\n* GS1 DataBar* \n* GS1 DataBar Expanded*\n* GS1 DataBar Limited \n* HAN XIN\n* Japanese Postal \n* Korean 3 of 5\n* Interleaved 2 of 5\n* Matrix 2 of 5 \n* Maxicode*\n* MAIL MARK\n* MicroPDF\n* MicroQR\n* MSI \n* PDF417*\n* QR Code* \n* Signature\n* TLC 39\n* Trioptic 39\n* UK Postal\n* UPC-A*\n* UPC-E0* \n* UPC-E1\n* US4State\n* US4state FICS \n* USPostnet \n* USPlanet\n* Webcode\n\n## UPCA\n* Report Check Digit - The check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option. \n* Preamble - Preamble characters are part of the UPC symbol consisting of Country Code and System Character. There are three options for transmitting a UPCA preamble:\n\t* Preamble None - Transmit no preamble.\n\t* Preamble Sys Char - Transmit System Character only (default).\n\t* Preamble Country and Sys Char - Transmit System Character and Country Code (\"0\" for USA). Select the appropriate option to match the host system.\n\n## UPCE0\n* Report Check Digit - The check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option. \n* Preamble - Preamble characters are part of the UPC symbol consisting of Country Code and System Character. There are three options for transmitting a UPCE0 preamble:\n\t* Preamble Sys Char - Transmit System Character only.\n\t* Preamble Country and Sys Char - Transmit System Character and Country Code (\"0\" for USA).\n\t* Preamble None - Transmit no preamble (default). Select the appropriate option to match the host system.\n* Convert UPCE0 To UPCA - Enable to convert UPCE0 (zero suppressed) decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is affected by UPC-A programming selections. Disable to transmit UPCE0 decoded data as UPCE0 data, without conversion (default - disabled).\n\n## Code128\n* Length1 - Use to set decode lengths (default - 0).\n* Length2 - Use to set decode lengths (default - 55).\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Enable Plain Code 128 - Flag to enable other 128 sub types (besides GS1-128 and ISBT-128).\n* Enable GS1-128 - Set the GS1 128 subtype. \n* Enable ISBT128 - Set the ISBT128 subtype. \n* ISBT128 Concatenation Mode - Select an option for concatenating pairs of ISBT code types:\n\t* Concat Mode Never - Do not concatenate pairs of ISBT codes encountered (default).\n\t* Concat Mode Always - There must be two ISBT codes in order to decode and perform concatenation. Does not decode single ISBT symbols.\n\t* Concat Mode Auto - Decodes and concatenates pairs of ISBT codes immediately. If only a single ISBT symbol is present, the device must decode the symbol the number of times set via Redundancy - Code128 before transmitting its data to confirm that there is no additional ISBT symbol.\n* Check ISBT Table - The ISBT specification includes a table that lists several types of ISBT bar codes that are commonly used in pairs. If ISBT128 Concat Mode is set, enable Check ISBT Table to concatenate only those pairs found in this table. Other types of ISBT codes are not concatenated. \n* Security Level - The scanner offers four levels of decode security for Code 128 bar codes. Select increasing levels of security for decreasing levels of bar code quality. There is an inverse relationship between security and scanner aggressiveness, so choose only that level of security necessary for any given application.\n\t* Security Level 0 - This setting allows the scanner to operate in its most aggressive state, while providing sufficient security in decoding most \"in-spec\" bar codes.\n\t* Security Level 1 - This setting eliminates most misdecodes.\n\t* Security Level 2 - Select this option if Security level 1 fails to eliminate misdecodes.\n\t* Security Level 3 - If Security Level 2 is selected and misdecodes still occur, select this security level. Be advised, selecting this option is an extreme measure against mis-decoding severely out of spec bar codes. Selecting this level of security significantly impairs the decoding ability of the scanner. If this level of security is needed, try to improve the quality of the bar codes.\n* Code128 Reduced Quiet Zone - \tCode128 Reduced Quiet Zone\n* Ignore Code128 FNC4 - Ignore Code128 FNC4\n\n\n## Code39\n* Length1 - Use to set decode lengths. \n* Length2 - Use to set decode lengths 4.\n* Verify Check Digit - Enable this feature to check the integrity of all Code 39 symbols to verify that the data complies with a specified check digit algorithm. The digital scanner decodes only those Code 39 symbols that include a modulo 43 check digit. Enable this feature only if the Code 39 symbols contain a modulo 43 check digit (default - disabled).\n* Report Check Digit - Transmit Code 39 data with or without the check digit. \n* Full ASCII - Code 39 Full ASCII is a variant of Code 39 that pairs characters to encode the full ASCII character set. To enable or disable Code 39 Full ASCII,\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Convert Code39 To Code32 - Code 32 is a variant of Code 39 used by the Italian pharmaceutical industry. Scan the appropriate bar code below to enable or disable converting Code 39 to Code 32.\n* Report Code32 Prefix - Scan the appropriate bar code to enable or disable adding the prefix character \"A\" to all Code 32 bar codes.\n* Security Level - Options: Security level 0, Security Level 1, Security Level 2 and Security Level 3.\n* Code39 Reduced Quite Zone - Code39 Reduced Quiet Zone\n\n## Interleaved 2of5\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Check Digit\n\t* No Check Digit - A check digit is not used. \n\t* USS Check Digit - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Uniform Symbology Specification (USS) check digit algorithm.\n\t* OPCC Check Digit - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Optical Product Code Council (OPCC) check digit algorithm.\n* Report Check Digit - Transmit Interleaved 2 of 5 data with or without the check digit. \n* Convert ITF-14 To EAN13 - Convert 14-character Interleaved 2 of 5 bar codes to EAN-13, and transmit as EAN-13. The Interleaved 2 of 5 bar code must be enabled and must have a leading zero and a valid EAN-13 check digit. \n* Security Level - The scanner offers four levels of decode security. Select increasing levels of security for decreasing levels of barcode quality.\n* I2of5 Reduced Quiet Zone - I2of5 Reduced Quiet Zone\n\n##GS1 Data Bar Limited\n* Security Level - The scanner offers four levels of decode security. Select increasing levels of security for decreasing levels of barcode quality.\n\n\n## Composite AB\n* UCC Link Mode\n\t* Link Flag ignored - 1D component is transmitted regardless of whether a 2D component is detected.\n\t* Always Linked - 1D and the 2D components are transmitted. If 2D is not present, the 1D component is not transmitted.\n\t* Auto Discriminate - the digital scanner determines if there is a 2D portion, then transmits the 1D component, as well as the 2D portion if present. (default).\n\n## US Postnet\n* Report Check Digit - Transmits US Postnet data with or without the check digit\n\n## US Planet\n* Report Check Digit - Transmits US Planet data with or without the check digit\n\n## UK Postal\n* Report Check Digit - Transmit UK Postal data with or without the check digit\n\n## Codabar\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* CLSI Editing - Enable this parameter to strip the start and stop characters and insert a space after the first, fifth, and tenth characters of a 14-character Codabar symbol. Enable this feature if the host system requires this data format.\n* NOTIS Editing - Enable this parameter to strip the start and stop characters from a decoded Codabar symbol. Enable this feature if the host system requires this data format.\n\n## MSI\n* Length 1 - Use to set decode lengths.\n* Length 2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Check Digit - With MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional.\n\t* One Check Digit - Verify one check digit.\n\t* Two Check Digits - Verify two check digits.\n* Check Digit Scheme - Two algorithms are possible for the verification of the second MSI check digit.\nSelect the algorithm used to encode the check digit.\n\t* Mod-11-10 - First check digit is MOD 11 and second check digit is MOD 10.\n\t* Mod-10-10 - Both check digits are MOD 10.\n* Report Check Digit - Transmit MSI data with or without the check digit. \n\n## Code93\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n\n## Discrete 2 of 5\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n\n## Code11\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Verify Check Digit - Check the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code.\n\t* No Check Digit - Do not verify check digit.\n\t* 1 Check Digit - Bar code contains one check digit.\n\t* 2 Check Digits - bar code contains two check digits.\n* Report Check DIgit - Transmit Code 11 data with or without the check digit. \n\n## HAN XIN\n* HAN XIN Inverse - HAN XIN Inverse\n\n##Matrix 2 of 5\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Report Check Digit - Transmit Matrix 2 of 5 data with or without the check digit. \n* Verify Check Digit - Enable this feature to check the integrity of all Matrix 2 of 5 symbols to verify that the data complies with a specified check digit algorithm.\n\n## UPCE1\n* Report Check Digit - The check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option. \n* Preamble - Preamble characters are part of the UPC symbol consisting of Country Code and System Character. There are three options for transmitting a UPCE1 preamble:\n\t* Preamble Sys Char - Transmit System Character only.\n\t* Preamble Country and Sys Char - Transmit System Character and Country Code (\"0\" for USA).\n\t* Preamble None - Transmit no preamble (default). Select the appropriate option to match the host system.\n* Convert UPCE1 To UPCA - Enable this to convert UPCE1 decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is affected by UPC-A programming selections. Disable this to transmit UPCE1 decoded data as UPCE1 data, without conversion.\n\n## Decode Lengths\nThe allowable decode lengths are specified by options Length1 and Length2 as follows: \n\n* Variable length: Decode symbols containing any number of characters.\n\t* Set both Length1 and Length2 to 0.\n* Range: Decode a symbol with a specific length range (from a to b, including a and b).\n\t* Set Length1 to a and set Length2 to b.\n* Two Discrete Lengths: Decode only symbols containing either of two selected lengths.\n\t* Set either Length1 or Length2 to the specific lengths.\n* One Discrete Length: Decode only symbols containing a specific length.\n\t* Set both Length1 and Length2 to the specific length.\n\n## UPC EAN Params\nAllows the configuration of the parameters that apply to more than one UPC or EAN decoder.\n\n* Security Level - The scanner offers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application.\n\t* Level 0 - This default setting allows the scanner to operate fastest, while providing sufficient security in decoding \"in-spec\" UPC/EAN bar codes.\n\t* Level 1 - As bar code quality levels diminish, certain characters become prone to misdecodes before others (i.e., 1, 2, 7, 8). If the scanner is misdecoding poorly printed bar codes, and the misdecodes are limited to these characters, select this security level.\n\t* Level 2 - If the scanner is misdecoding poorly printed bar codes, and the misdecodes are not limited to characters 1, 2, 7, and 8, select this security level.\n\t* Level 3 - If the scanner is still misdecoding, select this security level. Be advised, selecting this option is an extreme measure against misdecoding severely out of spec bar codes. Selecting this level of security can significantly impair the decoding ability of the scanner. If this level of security is necessary, try to improve the quality of the bar codes.\n* Supplemental2 - Enables or disables this option. \n* Supplemental5 - Enables or disables this option. \n* Supplemental Mode\n\t* No Supplementals - the scanner is presented with a UPC/EAN plus supplemental symbol, the\n\tscanner decodes UPC/EAN and ignores the supplemental characters.\n\t* Supplemental Always - the scanner only decodes UPC/EAN symbols with supplemental characters, and ignores symbols without supplementals.\n\t* Supplements Auto - the scanner decodes UPC/EAN symbols with supplemental characters immediately. If the symbol does not have a supplemental, the scanner must decode the bar code the number of times set via UPC/EAN Supplemental Redundancy before transmitting its data to confirm that there is no supplemental.\n\t* Supplemental Smart - Enables smart supplementals. In this mode the decoder returns the decoded value of the main block right away if it does not belong to one of the following supplemental types: 378, 379, 977, 978, 979, 414, 419, 434 or 439. If the bar code starts with one of the prefixes it searches the image more aggressively for a supplemental. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\t* Supplemental 378-379 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 378 or 379. Disables reading of supplementals for any other UPC/EAN bar code not starting with 378 or 379. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\t* Supplemental 978-979 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 978 or 979. Disables reading of supplementals for another UPC/EAN bar code not starting with 978 or 979. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main barcode is returned.\n\t* Supplemental 414-419-434-439 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 414, 419, 434 or 439. Disables reading of supplementals for another UPC/EAN bar code not starting with 414, 419, 434 or 439. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\t* Supplemental 977 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 977. Disables reading of supplementals for another UPC/EAN barcode not starting with 977. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n* Retry Count - Retry count for auto-discriminating for supplementals. Possible values are 2 to 20 inclusive. Note that this flag is only considered if Supplemental Mode - UPC EAN is set to one of the following values: Supplementals Auto, Supplementals Smart, Supplementals 378-379, Supplementals 978-979, Supplementals 977 or Supplementals 414-419-434-439 (2 to 20).\n* Random Weight Check Digit - Enable random weight check digit verification.\n* Bookland - Enable or disable this option. \n* Coupon - Enables Coupon code decoding. Note that in order to successfully decode Coupon codes, all\nof the correct decoders must be enabled.\n* Coupon Report Mode - Enables one of the coupon report modes\n\t* Old Coupon Report Mode\n\t* New Coupon Report Mode\n\t* Both Coupon Report Mode\n* EAN Zero Extend - Enable this parameter to add five leading zeros to decoded EAN-8 symbols to make them compatible in format to EAN-13 symbols. Disable this to transmit EAN-8 symbols as is.\n\n* Bookland Format - if Bookland option is enabled, select on of the formats for Bookland data\n\t* Format ISBN-10\n\t* Format ISBN-13\n\n* Convert DataBar To UPC EAN - If this is set it converts DataBar bar codes to UPC/EAN format. For this setting to work UPC/EAN symbologies must be enabled.\n* UPC Reduced Quiet Zone - Enable decoding of marginless UPC barcodes\n\n## Reader Params\nAllows the configuration of parameters specific to the selected bar code reader.\n\n* Beam Timer - Sets the maximum amount of time that the reader remains on (0 - 60,000 ms in increments of 100 ms). A value of 0 sets the reader to stay on indefinitely.\n* Adaptive Scanning - Enable/Disable Adaptive Scanning\n* Beam Width - Set Beam Width\n\t* Narrow\n\t* Normal\n\t* Wide\n* Power Mode - Set scanner power mode\n\t* Low Power Mode\n\t* Optimized Power Mode\n\t* High Power Mode\n\t* Always On\n* Mobile Phone Display Mode - Defines finer reader by the DS457\n\t* Disable Mobile Display Mode\n\t* Enable Mobile Display Mode\n* Reader Mode - Defines how the SSI scanner triggers\n\t* Presentation Mode\n\t* Triggered Mode\n* Linear Security Level - Sets the number of times a bar code is read to confirm an accurate decode.\n\t* Security Redundancy and Length - Two times read redundancy based on redundancy flags and\n\tcode length.\n\t* Security Short or Codabar - Two times read redundancy if short bar code or Codabar.\n\t* Security All Twice - Two times read redundancy for all bar codes.\n\t* Security Long and Short - Two times read redundancy for long bar codes, three times for short bar codes.\n\t* Security All Thrice - Three times read redundancy for all bar codes.\n* Picklist - Allows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is targeted for decode.\n\t* Disable - Disables Picklist mode. Any bar code within the field of view can be decoded.\n\t* Centered - Enables the Picklist mode so that only the bar code in the center of the image is decoded. This is most useful when used in conjunction with the static and dynamic reticle viewfinder modes. Note: This mode is only valid for decoder modules that supports a viewfinder. If one tries to set this for a unsupported decoder then the device would issue an error. (Camera scanner only).\n\t* Reticle - Enables the Picklist mode so that only the bar code that is directly under the cross-hair (reticle) is decoded. This is useful when used in conjunction with the static and dynamic reticle viewfinder modes. (Scan Module Only)\n* Aim Type - Type Trigger Modes\n\t* Trigger\n\t* Continuous Read\n* Same Symbol Timeout - Suppress decoding same symbol within this time interval in Continuous Trigger Mode. From 0 to 5000, Steps of 500. Eg: 0, 500, 1000, 1500...\n* Different Symbol Timeout - Suppress decoding another symbol within this time interval in Continuous Trigger Mode. From 0 to 5000, Steps of 500. Eg: 0, 500, 1000, 1500...\n* Illumination mode - Enable/Disable illumination depending on ambient light conditions\n* LCD Mode - Enables or disables LCD mode. LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones (Scan Module Only).\n\t* Disable - Disables the LCD mode. \n\t* Enable - Enables LCD mode.\n\n\tNOTE When using the LCD mode, a degradation in performance may be observed and the aiming crosshair may blink until the bar code is decoded.\n* Time Delay to Low Power - Time delay for scanner to enter low power mode\n\t* 1 Second\n\t* 30 Seconds\n\t* 1 Minute\n\t* 5 Minutes\n* Illumination Brightness Value - Illumination Brightness of the Imager\n* Inverse 1D Mode - This parameter allows the user to select decoding on inverse 1D bar codes.\n\t* Disable - Disables decoding of inverse 1D bar codes.\n\t* Enable - Enables decoding of only inverse 1D bar codes.\n\t* Auto - Allows decoding of both positive and inverse 1D bar codes.\n* Poor Quality Decode Effort\n\t* Level 0\n\t* Level 1\n\t* Level 2\n\t* Level 3 \n\n* Viewfinder Mode - Configures the Viewfinder modes supported for camera scanning.\n\t* Viewfinder Enabled - Enables only the viewfinder.\n\t* Static Reticle - Enables the viewfinder and a red reticle in the center of the screen which helps selecting the bar code.\n\n## Scan Params\nAllows the configuration of Code Id and decode feedback options.\n\n* Code ID Type - A Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol.\n\t* Code ID Type None - No prefix (default).\n\t* Code ID Type Aim - A standards based three character prefix.\n\t* Code ID Type Symbol - A Symbol defined single character prefix.\n\t\n\tNOTE Not all ringtones are fully supported as decode tones. Ringtones of longer length may be truncated when used as a decode tone. The recommendation is to test the selected tone for operation before deployment to a customer site.\n* Volume Type\n\t* Ringer and Notifications\n\t* Music and Media\n\t* Alarms\n* Decode Audio Feedback - Select an audio tone to sound upon a good decode.\n* Decode Haptic Feedback - Enable the MC40 to vibrate upon a good decode.\n* BT Disconnect On Exit - Enable/Disable Bluetooth disconnect on exit.\n* Connection Idle Time - If a bluetooth scanner associated application is opened, Bluetooth scanner will be automatically disconnected after this Connection Time duration of inactivity. From 60 to 1800, Steps of 5. Eg: 60, 65, 70, 75...\n* Decode Feedback LED Timer - Time for which Good Decode LED Notification Runs\n* Display BT Address Barcode - If this value is set to true, the Bluetooth Pairing Utility Application will be opened when the enable method is called \n* Decoding LED Notification - Time for which Good Decode LED Notification Runs\n* Engine Decode LED - Controls Engines' decode LED behavior\n\t* Disabled\n\t* Off on power down\n\t* Power down only after LED off\n\n\n\n## Output Data\nIn order for your application to receive the barcode data, you must specify one or more Output features. Please  refer to their reference documentation for more information.\n\n* [Intent](#guide-profiles-profileintent) \n* [Keystroke](#guide-profiles-profilekeystroke)\n* [IP](#guide-profiles-profileIP)\n"},{"key":"guide-profiles-profileintent","name":" Intent Profile Feature Reference","md":"# Intent Profile Feature Reference\n\n## Overview\nIn order to get Barcode or MSR data in your application, you must create a profile that has both an Input feature and an Output feature:\n\n* [Barcode](#guide-profiles-profilebarcode) / [MSR](#guide-profiles-profilemsr) (Input)\n* [Keystroke](#guide-profiles-profilekeystroke),[Intent](#guide-profiles-profileintent),[IP](#guide-profiles-profileIP) (Output)\n\nThe `Barcode` feature in the Profile Manager is responsible for reading data from the device's integrated bar code scanner and supports different types of bar code readers including laser, imager and internal camera. It also contains detailed parameters for scanner behavior as well as individual barcode symbology parameters.\n\nThe `Intent`, `Keystroke` or `IP` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n* IP - IP Output allows DataWedge to send captured data to a host computer via a network connection. Captured data can be sent over an IP network to a specified IP address and port using either TCP or UDP transport protocols.\n\n## Android Intent Overview\nThe core components of an Android application (its activities, services, and broadcast receivers) are activated by intents. An intent is a bundle of information (an Intent object) describing a desired action - including the data to be acted upon, the category of component that should perform the action, and other pertinent instructions. Android locates an appropriate component to respond to the intent, launches a new instance of the component if one is needed, and passes it the Intent object.\n\nComponents advertise their capabilities, the kinds of intents they can respond to, through intent filters. Since the system must learn which intents a component can handle before it launches the component, intent filters are specified in the manifest as &lt;intent-filter&gt; elements. A component may have any number of filters, each one describing a different capability.\n\nFor example, if the application manifest contains the following:\n\n\t:::xml\n\t<intent-filter . . . >  \n  \t\t<action android:name=\"com.symbol.emdksample.RECVR\" />  \n  \t\t<category android:name=\"android.intent.category.DEFAULT\" />  \n\t</intent-filter>\n\nIn the Intent Feature Profile configuration, the Intent action must be: \n\n\t:::java\n\tcom.symbol.emdksample.RECVR\n\nand the Intent category must be: \n\n\t:::java\n\tandroid.intent.category.DEFAULT\n\n\n## EMDK Intent Output\nAllows configuration of the Intent Feature for the profile. The Intent Output Feature allows the captured data to be sent to an application in the form of an implicit Intent. Refer to the Android Developer web site for more information, http://developer.android.com.\n\n* Name - The name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n* Enabled - Enables or disables this feature. \n* Intent action - Enter the Intent Action name (required). The Intent Filter action must match this.\n* Intent category - Enter the Intent Category name (required). The Intent Filter category must match this.\n* Intent delivery - Select the method by which the intent is delivered:\n\t* Send via StartActivity\n\t* Send via startService\n\t* Broadcast intent\n\n> Note: Most scanning applications might want the user to be able to decode data and for that decode data to be sent to the *current* activity but not necessarily displayed. If this is the case, then the activity needs to be marked as singleTop in its AndroidManifest.xml file. If your activity is not defined as singleTop, then on every decode, the system will create another copy of your Activity and send the decode data to this second copy.\n\n\n## Basic Data Formatting\nAllows configuration of any data formatting. When disabled, any data is passed on without modification.\n\n* Enabled - Enables or disables Basic Data Formatting. \n* Prefix to data - Add characters to the beginning of the data when sent.\n* Suffix to data - Add characters to the end of the data when sent.\n* Send data - Set to transfer the captured data to the foreground application. Disabling this option prevents the actual data from being transmitted. However, the prefix and suffix strings, if present, are still transmitted even when this option is disabled (default - enabled).\n* Send as hex - Set to send the data in hexadecimal format. \n* Send TAB key - Set to append a tab character to the end of the processed data. \n* Send ENTER key - Set to append an Enter character to the end of the processed data. \n\n## EMDK Intent Return Parameters\nThe decode related data added to the Intent's bundle can be retrieved using the Intent.getStringtExtra() and Intent.getSerializableExtra() calls, using the following String tags:\n\n* `com.motorolasolutions.emdk.datawedge.label_type`: String contains the label type of the bar code.\n* `com.motorolasolutions.emdk.datawedge.data_string`:\nString contains the output data as a String. In the case of concatenated bar codes, the decode data is concatenated and sent out as a single string. In the case of MSR output, the data from the MSR tracks is concatenated and sent out as a single string.\n* `com.motorolasolutions.emdk.datawedge.decode_data`:\nDecode data is returned as a list of byte arrays. In most cases there will be one byte array per decode. For barcode symbologies that support concatenation e.g. Codabar, Code128, MicroPDF, etc., the decoded data is stored in multiple byte arrays (one byte array per bar code). Clients can get data in each byte array by passing an index.\n\nThe MSR related data added to the Intent's bundle can be retrieved using the Intent.getStringtExtra() and Intent.getSerializableExtra() calls, using the following String tags:\n\n* `com.motorolasolutions.emdk.datawedge.msr_data`:\nThe data from the MSR tracks is concatenated and sent out as a byte array. The Start/end sentinels and\ntrack separators are included as configured.\n* `com.motorolasolutions.emdk.datawedge.msr_track1`: MSR track 1 data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track2`: MSR track 2 data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track3`: MSR track 3 data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track1_status`: MSR track 1 decode status as an Integer where 0 indicates a successful decode.\n* `com.motorolasolutions.emdk.datawedge.msr_track2_status`: MSR track 2 decode status as an Integer where 0 indicates a successful decode.\n* `com.motorolasolutions.emdk.datawedge.msr_track3_status`: MSR track 3 decode status as an Integer where 0 indicates a successful decode.\n* `com.motorolasolutions.emdk.datawedge.msr_track1_encrypted`: MSR track 1 encrypted data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track2_encrypted`: MSR track 2 encrypted data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track3_encrypted`: MSR track 3 encrypted data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track1_hashed`: MSR track 1 hashed data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track2_hashed`: MSR track 2 hashed data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track3_hashed`: MSR track 3 hashed data is returned as a byte array.\n\n"},{"key":"guide-profiles-profileIP","name":" IP Output Profile Feature Reference","md":"# IP Output Profile Feature Reference\n\n## Overview\nIn order to get Barcode or MSR data in your application, you must create a profile that has both an Input feature and an Output feature:\n\n* [Barcode](#guide-profiles-profilebarcode) / [MSR](#guide-profiles-profilemsr) (Input)\n* [Keystroke](#guide-profiles-profilekeystroke),[Intent](#guide-profiles-profileintent),[IP](#guide-profiles-profileIP) (Output)\n\nThe `Barcode` feature in the Profile Manager is responsible for reading data from the device's integrated bar code scanner and supports different types of bar code readers including laser, imager and internal camera. It also contains detailed parameters for scanner behavior as well as individual barcode symbology parameters.\n\nThe `Intent`, `Keystroke` or `IP` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n* IP - IP Output allows DataWedge to send captured data to a host computer via a network connection. Captured data can be sent over an IP network to a specified IP address and port using either TCP or UDP transport protocols.\n\n## IP Output\nUse to configure the Keystroke Output Feature for the profile.\n\n* Name - The name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n* Enabled - Enables or disables this feature. \n* Remote Wedge - Enable or disable the Remote Wedge option (default - enabled). Remote Wedge is used with the IPWedge application.\n* Protocol - Select the protocol used by the remote application. Options: TCP (default) or UDP.\n* IP address - Enter the IP address used by the remote application (default - 0.0.0.0).\n* Port - Enter the port number used by the remote application (default - 58627).\n\n## Basic Data Formatting \nAllows the configuration of any data formatting. When disabled, any data is passed on without modification.\n\n* Enabled - Enables or disables Basic Data Formatting. \n* Prefix to data - Add characters to the beginning of the data when sent.\n* Suffix to data - Add characters to the end of the data when sent.\n* Send data - Set to transfer the captured data to the foreground application. Disabling this option prevents the actual data from being transmitted. However, the prefix and suffix strings, if present, are still transmitted even when this option is disabled (default - enabled).\n* Send as hex - Set to send the data in hexadecimal format. \n* Send TAB key - Set to append a tab character to the end of the processed data. \n* Send ENTER key - Set to append an Enter character to the end of the processed data. \n\n"},{"key":"guide-profiles-profilekeystroke","name":" KeyStroke Profile Feature Reference","md":"# KeyStroke Profile Feature Reference\n\n## Overview\nIn order to get Barcode or MSR data in your application, you must create a profile that has both an Input feature and an Output feature:\n\n* [Barcode](#guide-profiles-profilebarcode) / [MSR](#guide-profiles-profilemsr) (Input)\n* [Keystroke](#guide-profiles-profilekeystroke),[Intent](#guide-profiles-profileintent),[IP](#guide-profiles-profileIP) (Output)\n\nThe `Barcode` feature in the Profile Manager is responsible for reading data from the device's integrated bar code scanner and supports different types of bar code readers including laser, imager and internal camera. It also contains detailed parameters for scanner behavior as well as individual barcode symbology parameters.\n\nThe `Intent`, `Keystroke` or `IP` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n* IP - IP Output allows DataWedge to send captured data to a host computer via a network connection. Captured data can be sent over an IP network to a specified IP address and port using either TCP or UDP transport protocols.\n\n\n## Keystroke Output\nUse to configure the Keystroke Output Feature for the profile.\n\n* Name - The name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n* Enabled - Enables or disables this feature. \n* Action key character - Enabled decoding a special characters embedded within a bar code or MSR data.\n\t* None - Action key character feature is disabled (default).\n\t* Tab - Tab character (\\t) in a bar code is processed.\n\t* Line feed - Line feed character (\\t) in a bar code is processed.\n\t* Carriage return - Carriage return character (\\t) in a bar code is processed.\n\n## Basic Data Formatting \nAllows the configuration of any data formatting. When disabled, any data is passed on without modification.\n\n* Enabled - Enables or disables Basic Data Formatting. \n* Prefix to data - Add characters to the beginning of the data when sent.\n* Suffix to data - Add characters to the end of the data when sent.\n* Send data - Set to transfer the captured data to the foreground application. Disabling this option prevents the actual data from being transmitted. However, the prefix and suffix strings, if present, are still transmitted even when this option is disabled (default - enabled).\n* Send as hex - Set to send the data in hexadecimal format. \n* Send TAB key - Set to append a tab character to the end of the processed data. \n* Send ENTER key - Set to append an Enter character to the end of the processed data. \n\n"},{"key":"guide-profiles-profilemsr","name":" MSR Profile Feature Reference","md":"# MSR Profile Feature Reference\n\n## Overview\nIn order to get MagStripe (MSR) data in your application, you must create a profile with two profile features selected:\n\n* MSR\n* [Keystroke](#guide-profiles-profilekeystroke),[Intent](#guide-profiles-profileintent),[IP](#guide-profiles-profileIP) (Output)\n\nThe `MSR` feature in the Profile Manager is responsible for reading data from the device's integrated mag-stripe reader (if one such exists).\n\nThe `Intent`, `Keystroke` or `IP` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n* IP - IP Output allows DataWedge to send captured data to a host computer via a network connection. Captured data can be sent over an IP network to a specified IP address and port using either TCP or UDP transport protocols.\n\n## MSR Settings Reference\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Enabled\nEnables or disables this feature. Default is disabled.\n\n## Output Data\nIn order for your application to receive the barcode data, you must specify one or more Output features. Please  refer to their reference documentation for more information.\n\n* [Intent](#guide-profiles-profileintent) \n* [Keystroke](#guide-profiles-profilekeystroke)\n* [IP](#guide-profiles-profileIP)\n"},{"key":"guide-profiles-sdcard","name":" SDCard Manager Profile Feature Reference","md":"# SDCard Manager Profile Feature Reference\n\n\n## Overview\n\nThe SdCard Manager allows your application to manage the use of the devices SD card.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable/Disable SdCard\n\n\n##Enable/Disable\nThis profile feature will allow your application to enable or disable use of external SDCards.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=SdCardMgr&os=All&embed=true\"></iframe> "},{"key":"guide-profiles-settings","name":" Settings Manager Profile Feature Reference","md":"# Settings Manager Profile Feature Reference\n\n## Overview\n\nSettings Manager feature allows you to manage settings UI configuration by providing the ability to invoke Enterprise Reset in Settings application of your device.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable/Disable the Ability to Perform an Enterprise Reset from the Settings Menu\n\n* Enable/Disable the Ability to turn Wi-Fi on or off from the Settings Menu\n\n* Enable/Disable the Ability to turn Install Apps from Unknown Sources on or off from the Settings Menu\n\n* Enable/Disable the Ability to to turn Airplane Mode on or off from the Settings Menu\n\n##Enterprise Reset\nEnable or disable the ability to access the `Enterprise Reset` option in the Settings application.\n\n##Wi-Fi \nEnable or disable the ability to access the `Wi-Fi` option in the Settings application.\n\n##Unknown Sources \nEnable or disable the ability to access the `Install Apps from Unknown Sources` option in the Settings application.\n\n##Airplane Mode\nEnable or disable the ability to access the `Airplane Mode` option in the Settings application.\n\n##Access Applications\nEnable or disable the ability to access the `Applications` option in the Settings application.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=SettingsMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-threat","name":" Threat Manager Profile Feature Reference","md":"# Threat Manager Profile Feature Reference\n\n## Overview\n\nThe Threat Manager feature allows your application to control what security threats a device actively monitors for and how to respond.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable Threat Detection\n* Disable Threat Detection\n* Perform Counter Measures when a Threat is Detected\n\n##Enable/Disable\nThis profile feature will allow your application to enable or disable Threat detection on a device.\n\n\n##Detectable threats:\n* **Max Password Attempts** - User tries to login with with the wrong password\n* **MDM Client Removal** - MDM client has been removed from the device\n  * MDM Client Package Name - Provide the package name of the MDM client to be observed (System app only)\n* **Externally Detected** - An intent has been received that signifies and a custom threat\n* **Exchange Active Sync Command** - While syncing with Exchange, and threat event occurred\n* **Device is Rooted** - Device has detected that it is rooted\n\n##Counter Measures\n* **Format SdCard** - This counter measure would format the external SDCard, all existing data on card would be lost.\n\n* **Factory Reset** - This counter measure would force the device to factory reset. Returning the device to its original configuration. \n\n* **Wipe Secure Storage Keys** - This counter measure would remove Secure Storage Keys\n\n* **Lock Device** - This counter measure would lock the device, requiring the user to perform any device unlock procedure configured for the device.\n\n* **Uninstall Application** - This counter measure would silently remove an application from the device. Provide the package name of the application to uninstall. \n\n* **Unsolicited Alert** - This counter measure would send an explicit intent to an application. Provide and alert message, and the package and class name of the application you would like to notify.\n\n* **Signal Occurrence of Threat** - Select whether the occurrence of an externally detected Threat should be signaled.\n  * Send threat message - Provide a message to be sent, stating what custom threat has occurred. \n\n## Feature Compatibility\n\n<iframe src=\"compare.html#mx=4.3&csp=ThreatMgr&os=All&embed=true\"></iframe> \n"},{"key":"guide-profiles-touch","name":" Touch Manager Profile Feature Reference","md":"# Touch Manager Profile Feature Reference\n\n\n## Overview\n\nTouch Manager feature allows you set the Touch Mode on your device in order to interact with User Interface.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Configure the Screen for Stylus and Finger Input\n* Configure the Screen for Glove and Finger Input\n\n## TouchAction\nSpecify Touch Mode to interact with User Interface on the device.\n\n* Do not change - Keep the existing Touch Mode settings.\n* Stylus and Finger - Set the Touch Mode to Stylus and Finger.\n* Glove and Finger - Set the Touch Mode to Glove and Finger.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=TouchMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-ui","name":" UI Manager Profile Feature Reference","md":"# UI Manager Profile Feature Reference\n\n## Overview\n\nThe UI Manager feature allows you to manage UI configurations using its UI Manager parameters. \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable/Disable Clipboard\n* Clear Clipboard \n* Enable/Disable Auto Correct\n* Enable/Disable Home Key\n* Enable/Disable Bluetooth Paring Popup\n* Set Current Local\n* Set Default Input Method \n\n\n## Clipboard\nThis profile feature allows your application to enable or disable a devices clipboard.\n\n\n### Clear Clipboard\nThis profile feature allows your application to clear a devices clipboard.\n\n* Check Box is marked: Clear the clipboard.\n* Check Box is not marked: Don't clear the clipboard (leave unchanged).\n\n##Auto Correct\nThis profile feature allows your application to enable or disable a devices Auto Correct feature.\n\n##Home Key\nThis profile feature allows your application to enable or disable a devices Home Key.\n\n##Bluetooth Paring Popup\n\n\n\n\n\n\n\n\n##Set Current Local\nThis profile feature allows your application to set a devices local to one of the following values.\n\n  * Canada\n  * Canada French\n  * China \n  * Chines\n  * English \n  * France\n  * French\n  * German\n  * Germany\n  * Italian\n  * Italy\n  * Japan\n  * Japanese\n  * Korea\n  * Korean\n  * PRC\n  * Simplified Chines\n  * Taiwan \n  * Traditional Chines\n  * UK\n  * US\n\n##Set Default Input Method \nThis profile feature allows your application to set a devices Input Method to one of the following.\n  * English (US)\n  * Japanese\n  * Chinese (China)\n  * User Defined Input Method\n\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=UiMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-usb","name":" USB Manager Profile Feature Reference","md":"# USB Manager Profile Feature Reference\n\n## Overview\n\nThe USB Manager feature allows you to manage USB configurations of your device.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable/Disable USB Module Usage\n* Enable/Disable External USB Storage\n* Enable/Disable ADB (Android Debug Bridge) Over USB\n* Enable/Disable Device Storage Access over USB\n* Enable/Disable the Ability to Access the Device Using USM (USB Mass Storage) Mode\n* Enable/Disable the Ability to Access the Device Using MTP (Media Transfer Protocol) Mode\n* Enable/Disable the Ability to Access the Device Using PTP (Picture Transfer Protocol) Mode\n\n## USB Module Usage\nEnabling this feature would allow the use of external USB modules such as a barcode scanner module.  Disabling this feature will disable the use of any usb module attached to the device.\n\n## External USB Storage\nEnabling this feature would allow the device to access data an external USB mass storage device such as a flash drive through an OTG cable. Disabling would prevent access to an attached USB mass storage device.\n\n## ADB Over USB\nEnabling this feature will allow ADB (Android Debug Bridge)  access to a device from an external workstation via USB. Disabling would prevent adb connections to a device.\n\n## Device Storage Access over USB\nEnabling this feature would allow access to a devices storage via protocols such as USM, MTP and PTP. Disabling this feature would restrict any access to a devices storage via USB.\n\n## USB Mass Storage Mode\nEnabling the USM protocol would allow an external workstation to mount a devices storage, which disables a devices access to that storage until unmounted.  Device Storage Access over USB must first be enabled.\n\n## Media Transfer Protocol Mode\nEnabling the MTP protocol would allow an external workstation to access a devices storage without blocking the devices access to that storage.  Device Storage Access over USB must first be enabled.\n\n## Picture Transfer Protocol Mode\nEnabling the PTP protocol would allow an external workstation to access a devices storage without blocking the devices access to that storage.  Device Storage Access over USB must first be enabled.\n\n\n## Feature Compatibility\n\n<iframe src=\"compare.html#mx=4.3&csp=UsbMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-usingwizard","name":" Using EMDK for Android Profiles","md":"# Using EMDK for Android Profiles\n##EMDK Profiles Overview\n\nThe EMDK for Android allows you to easily access various capabilities of your Android device from within an Android application. These capabilities are grouped together into, what is referred to as EMDK profiles. Each EMDK profile is broken into various features. Each profile feature has parameters to provide automatic enablement as well as configuration options that will control it's behavior. One such profile feature is Data Capture, which allows you to accesses the devices bar code scanner and magstripe reader. \n\n##EMDK Profile Features\n\n###Data Capture\n\nEMDK Data Capture profiles allow you to access and configure a devices bar code scanner and magstripe reader, along with how the data captured should be transmitted to your application. There are typically three components that are used to make this work:\n\n* [Activity Selector](#guide-profiles-profileactivity) - Automatically activates the profile based on application & activity combinations.\n* Input Sources - Choose if [Barcode](#guide-profiles-profilebarcode) & [MSR](#guide-profiles-profilemsr) is the source of the data.\n* Output Sources - Output the input source data as a [Keystroke](#guide-profiles-profilekeystroke), [Intent](#guide-profiles-profileintent) or [IP](#guide-profiles-profileIP) output.\n\n###Access Manager \nThe [Access Manager](#guide-profiles-access) profile feature allows you to configure a set of applications that will be allowed to run on the device. When a profile with this feature is enabled, the device will only allow applications on the WhileList to be executed.\n\n###Analytics Manager\nThe [Analytics Manager](#guide-profiles-analytics) profile feature allows you to configure what data about a device should be collected, and where the collected data should be stored. \n\n###App Manager \nThe [App Manager](#guide-profiles-app) profile feature allows you to install, upgrade, remove, enable, disable applications from the device. It also allows you to change the current application launcher, clear recent app list and much more.\n\n###Browser Manager \nThe [Browser Manager](#guide-profiles-browser) profile feature allows you to control the web browser on the device. For example you can set the browser homepage.\n\n###Camera Manager\nThe [Camera Manager](#guide-profiles-camera) profile feature allows you to control access to the cameras in a device. For example you can disable the user from using all cameras on the device.\n\n###Cellular Manager \nThe [Cellular Manager](#guide-profiles-cellular) profile feature allows you to configure options of the cellular radio on your device. For example you can turn\noff data roaming\n\n\n###Cert Manager \nThe [Cert Manager](#guide-profiles-cert) profile feature allows you to install or uninstall certificates that can be used identify your device for a variety of purposes, including VPN or Wi-Fi network access as well as authentication to servers by apps such as Email or Chrome.\n\n###Clock\nThe [Clock Manager](#guide-profiles-clock) profile feature allows you to set the devices current date, time and timezone. \n\n\n###Device Admin Manager \nThe [Device Admin Manager](#guide-profiles-devadmin) profile feature allows you to manage applications allowed configure settings on the device.\n\n###Display Manager \nThe [Display Manager](#guide-profiles-display) profile feature allows you to control the screen timeout value to conserve power.\n\n###Encrypt Manager \nThe [Encrypt Manager](#guide-profiles-encrypt) profile feature allows you to set encryption policies on a device through MX XML. For example a developer can create an EFS for storing application data.\n\n###GPRS Manager \nThe [GPRS Manager](#guide-profiles-gprs) profile feature allows you to configure GPRS APN settings for a carrier's network.\n\n###Persistence Manager \nThe [Persistence Manager](#guide-profiles-persistence) profile feature allows you to keep the MX features persistent on a device even after a reset.\n\n###Power Key Manager \nThe [PowerKey Manager](#guide-profiles-powerkey) profile feature allows you to control which options appear on the power menu on the device.\n\n###Power Manager \nThe [Power Manager](#guide-profiles-power) profile feature allows you to perform power management operations such as putting the device into Sleep mode, re-power or perform an OS Update. It also allows you to perform Enterprise Reset, Factory Reset and full device wipe. The action will be performed when the profile is enabled.\n\n###SD Card Manager \nThe [SD Card Manager](#guide-profiles-sdcard) profile feature allows you to manage the use of the devices SD card.\n\n###Settings Manager \nThe [Settings Manager](#guide-profiles-settings) profile feature allows you to manage settings UI configuration by providing the ability to invoke Enterprise Reset in Settings UI of your device.\n\n###Threat Manager \nThe [Threat Manager](#guide-profiles-threat) profile feature allows you to control what security threats a device actively monitors and how to respond.\n\n###Touch Manager \nThe [Touch Manager](#guide-profiles-touch) profile feature allows you to set the Touch Mode on your device in order to interact with User Interface.\n\n###UI Manager \nThe [UI Manager](#guide-profiles-ui) profile feature allows you to manage UI configurations using its UI Manager parameters. \n\n###USB Manager \nThe [USB Manager](#guide-profiles-usb) profile feature allows you to manage USB configurations of your device. \n\n###Wi-FI\nThe [Wi-Fi](#guide-profiles-wifi) profile feature allows you to manage Wi-Fi profiles available on the device as wells Wi-Fi settings Band and Channel selection, 802.11d / country configuration, and Disable / Enable, etc.\n\n###Wireless Manager \nThe [Wireless Manager](#guide-profiles-wireless) profile feature allows you to configure wireless devices such as Bluetooth, and NFC.\n\n> The Wifi radio is configured through Wi-Fi Manager profile not this Wireless Manager Profile\n\n###XML Manager \nThe [XML Manager](#guide-profiles-xml) profile feature allows you to specify various XML processing modes to be used.\n\n\n##Using the EMDK Profile Manager\n\nProfile Manager is an exclusive EMDK technology offered within your IDE, providing a GUI based development tool. This allows you to write fewer lines of code resulting in reduced development time, effort and errors.  \n\n###Accessing the Profile Manager\n1. Inside your IDE select an open Android Application. \n2. Select \"EMDK\" -> \"Profile Manager\" on the toolbar.  \n    ![img](images/profiles/image001.jpg)\n\n###Creating a Profile\n\n1. Open the \"EMDK Profile Manager\".  \n2. Click \"Create\".  \n\n    ![img](images/profiles/image002.jpg)\n3. Enter a Profile Name and click \"Create\".  This name is how the profile will be identified by the EMDK.\n\n\t![img](images/profiles/image003.jpg)  \n4. Select the features you would like to enable by selecting the item from the list of \"Available Features\" and clicking the right arrow button. \n\t>Note:  \n\t>\n\t> You must enable both a Data Capture Delivery Feature and a Data Capture Input Feature for the profile to send data to your application. For example \"Barcode\" and \"Intent\".\n\t>\n\t> You can remove a feature from the \"Selected Features\" list by clicking the left arrow button.\n\t\n\t![img](images/profiles/image004.jpg)  \n\n5. Select a \"Selected Features\" and the list of parameters will populate on the right hand side of the dialog. When you click on a parameter a description with populate on the lower left hand corner of the dialog.  \n\n\t![img](images/profiles/image005.jpg)  \n6. When complete click \"Finish\". \n7. Click \"Close\".  \n\n\t![img](images/profiles/image006.jpg)\n\t>Note:  \n\t>The profile XML will be generated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder.   \n\t\n###Editing a Profile\n\n1. Open the EMDK Profile Manager.\n2. Select a Profile to modify and click \"Edit\".  \n\n\t![img](images/profiles/image007.jpg)  \n3. Edit the profile using the Profile Manager in the same way you would when creating a new profile.\n4. When complete click \"Finish\".\n5. Click \"Close\".  \n\n\t![img](images/profiles/image008.jpg)\n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\t\n###Renaming a Profile\n\n1. Open the EMDK Profile Manager.\n2. Select a Profile to rename and click \"Rename\".  \n\n\t![img](images/profiles/image009.jpg)  \n3. Enter the new name and click \"Rename\";  \n\n\t![img](images/profiles/image010.jpg)  \n4. Click \"Close\".  \n\n\t![img](images/profiles/image011.jpg)  \n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\n###Copying a Profile\n\n1. Open the EMDK Profile Manager.\n2. Select a Profile to copy and click \"Copy\".  \n\n\t![img](images/profiles/image012.jpg)  \n3. Enter the a name profile name to uses and click \"Copy\";  \n\n\t![img](images/profiles/image013.jpg)  \n4. Click \"Close\".  \n\n\t![img](images/profiles/image014.jpg)  \n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\n\n###Deleting a Profile\n1. Open the EMDK Profile Manager.\n2. Select a Profile to delete and click \"Delete\".  \n\n\t![img](images/profiles/image015.jpg)  \n3. Confirm delete by clicking \"Delete\";  \n\n\t![img](images/profiles/image016.jpg)  \n4. Click \"Close\".  \n\n\t![img](images/profiles/image017.jpg)  \n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\n##Using the Profile Manager API\nOnce you create your profiles using the Profile Manager, they will be bundled with your application and available to access using the [Profile Manager APIs](#guide-reference-EMDKList). These profiles will NOT be applied on the device until it is processed using these APIs.\n\n### Multiple Ways to Access\nIn the ProfileManager API, you will see three methods for `processProfile`. Essentially the last parameter, `extraData`, is one of three types:\n\n* **Document** - data will be handled as a XML Document.\n* **String** - data will be handled as a raw string.\n* **ProfileConfig** - data will be handled as a ProfileConfig class.\n\n>WARNING!: The preferred way is to use the `ProfileConfig` option and the examples below present using such option. Using the Document or String methods may not work if the XML is not structured properly. See usage notes below for more information about using these methods.\n\n###Creating or Activating a Profile\nA profile is created or activated with using the PROFILE_FLAG.SET option. If the profileFlag is set to SET, and if the given profile is not available, it will look for a valid profile in the extraData argument and if present, the profile  will be added to the internal XML volatile repository and also applied to the device.  If the profile is present, then it will be applied to the device. \n\n> Note: The following example uses ProfileConfig object, which is currently only available for DataCapture profile features.\n\n\t:::java\n\t@Override  \n    public void onOpened(EMDKManager emdkmanager)  \n    {  \n        //Create the Profile Config object  \n        ProfileConfig profileConfigObj = new ProfileConfig();  \n       \n        //Get the Profile Manager  \n        ProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);  \n       \n        //Create the new profile  \n        EMDKResults results = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.SET, profileConfigObj);     \n    }  \n\n###Getting a Profile\nIf profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in the extraData object.\n\n> Note: The following example uses ProfileConfig object, which is currently only available for DataCapture profile features.\n\n\t:::java\n\t@Override  \n    public void onOpened(EMDKManager emdkmanager)  \n    {  \n        //Create the Profile Config object  \n        ProfileConfig profileConfigObj = new ProfileConfig();  \n       \n        //Get the Profile Manager  \n        ProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);  \n       \n        //Get the profile and store it in the ProfileConfig object  \n        EMDKResults results = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.GET, profileConfigObj);         \n    }  \n\n###Modifying a Profile\nTo modify a profile, you would:\n\n* Use the PROFILE_FLAG.GET option to retrieve the profile (if it exists).\n* Use the profileConfig Object and APIs to modify the feature parameters.\n* Use the PROFILE_FLAG.SET option to save the parameters.\n\n> Note: The following example uses ProfileConfig object, which is currently only available for DataCapture profile features.\n\n \t:::java\n \t@Override  \n    public void onOpened(EMDKManager emdkmanager)  \n    {  \n        //Create the Profile Config object  \n        ProfileConfig profileConfigObj = new ProfileConfig();  \n       \n        //Get the Profile Manager  \n        ProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);  \n       \n        //Get the profile and store it in the ProfileConfig object  \n        EMDKResults results = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.GET, profileConfigObj);  \n        //Enable MSR  \n        profileConfigObj.dataCapture.msr.msr_input_enabled = ENABLED_STATE.TRUE;  \n        //Modify Profile  \n        EMDKResults ModifyResults = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.SET, profileConfigObj);  \n    }  \n\n## Usage Notes\n\n### Getting Started with Tutorial\nThis is an overview of how you can create and integrate Profiles using EMDK Profile Manager. Click [here](#guide-tutorial-tutdatacaptureprofile) to get started with a detailed tutorial on Data Capture Profiles to understand better.  \n\n### Multiple Instance of Features\nThere should only be one instance of the DataCapture feature. The EMDK Profile Manager will not allow you to add multiple DataCapture features, but may happen if you are manually editing the EMDKConfig.xml. Other profile features can have multiple instances and may be required in some cases. For example, you may need two 'Certificate Manager' features. The first one to initialize the certificate store and the second one to install a new certificate.\n\n### Order of Features\nThe profile features will be applied synchronously in the order they appear. For example, you may want to set the clock before you attempt to connect to a Wi-Fi network.\n\n### extraData as XML String\nThe processProfile method has an overload method that allows sending XML content in the `extraData` parameter as a String.  \n\nMethod Signature:\n\n\t:::java\n\t// Pass in a string in XML form\n\tprocessProfile(String profileName, ProfileManager.PROFILE_FLAG profileFlag, String extraData)\n\n`profileName` can be:\n\n1. `[Name of Profile]` - to reference the entire profile. ex: 'EMDKProfile1'\n2. `[profileName]/[featureType]/[feature friendly name in profile parameters]` to just edit part of the profile. For example, if my profile is called 'Profile1' and the name I gave to the Clock feature is 'ckEST'. Passing 'profileName' as 'Profile1/Clock/ckEST' will just process this part of the profile.\n\t* Valid `[featureType]`:\tActivitySelection, Barcode, MSR, Intent, Keystroke, IP, Clock, PowerMgr, PersistMgr, CertMgr, AppMgr, AccessMgr, Wi-Fi, GprsMgr\n\n#### XML String Structure\nOne way you can see how this XML string should be structured is to use the Profile Manager in Eclipse. \n\n1. Open any project in Eclipse that does not have a EMDK profile defined already (so you get just the parameters you want to change).\n2. Select EMDK / Profile Manager from the menu.\n3. Add the Profile features you want and selection the options you wish to use.\n4. Click Finish when you are done with your selections.\n5. Look in the `assets` folder and open `EMDKConfig.xml`\n\n\t![img](images/MxAppManagerTutorialImages/emdk_config_file_entries.jpg)\n6. Notice the XML structure that is shown. This complete structure is to be passed in the extraData parameter as a string. You can choose to copy and paste this into your code to be used.\n\n> WARNING!: XML parm names and values may not be the same as what is presented in the Profile Manager wizard. Pay close attention to the fields of interest. It is not recommended to manually edit this XML, use the Profile Manager Wizard to ensure proper formation of the XML structure and values.\n\n#### Profile Name Usage Notes\nIf the ProfileName node is given in extraData and the ProfileFlag is SET, ProfileName in ExtraData should match with the first parameter passed to processProfile.\n\nExample:\n\n\t:::java\n\tString[] extraData = new String[1];\n\textraData[0]=\n\t\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" +\n\t\"<characteristic type=\\\"Profile\\\">\" +\n\t\"<parm name=\\\"ProfileName\\\" value=\\\" EMDKProfile1\\\"/>\" +\n\t\"<characteristic type=\\\"Clock\\\">\" +\n\t\"<parm name=\\\"emdk_name\\\" value=\\\"ck1\\\"/>\" +\n\t\"<parm name=\\\"Date\\\" value=\\\"2013-05-23\\\" />\" +\n\t\"<parm name=\\\"Time\\\" value=\\\"6:59:00\\\" />\" +\n\t\"<parm name=\\\"TimeZone\\\" value=\\\"America/Los_Angeles\\\" />\" +\n\t\"</characteristic>\"+\n\t\"</characteristic>\";\n\n\temdkStatus = mProfileManager.processProfile(\"EMDKProfile1\", ProfileManager.PROFILE_FLAG.SET, extraData);\n\n* If the ProfileName node is NOT given in extraData and the ProfileFlag is SET, the content will be merged with the profile given in the first parameter passed to processProfile.\n\n* If the ProfileFlag is SET and the profile given in the first parameter passed to processProfile does not exist in EMDKConfig.xml, the profile will be appended to the internal repository.\n\n* DataCapture content (Activity Selection, Barcode, MSR, Intent, Keystroke, IP) is considered as a whole and setting any individual feature will set as a whole. In other words, setting \"EmdkSampleProfile-1/Keystroke\" will push all the DataCapture features to the device.\n\n#### Feature Name Usage Notes\nEach specific profile feature can be named so that only that portion of the profile can be referenced. This can be accomplished by:\n\n1. Specifying a name for the specific feature within a profile.\n2. Using the fully qualified name as the first parameter of the processProfile method.\n\n* If the ProfileFlag is SET, the emdk_name given in ExtraData should match the third part of the profileName passed to the processProfile method (first parameter).\n\nIn the following example, we created a profile called `EMDKProfile1` and added the Clock feature with a name of `ck2`. Now we can modify that profile using the processProfile method, making sure we specify the `emdk_name` parameter as `ck2` and use a profileName of `EMDKProfile1/Clock/ck2` in the processProfile method:\n\n\t:::java\n\tString[] extraData = new String[1];\n\textraData[0]=\n\t\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" +\n\t\"<characteristic type=\\\"Profile\\\">\" +\n\t\"<parm name=\\\"ProfileName\\\" value=\\\" EMDKProfile1\\\"/>\" +\n\t\"<characteristic type=\\\"Clock\\\">\" +\n\t\"<parm name=\\\"emdk_name\\\" value=\\\"ck2\\\"/>\" +\n\t\"<parm name=\\\"Date\\\" value=\\\"2013-05-23\\\" />\" +\n\t\"<parm name=\\\"Time\\\" value=\\\"6:59:00\\\" />\" +\n\t\"<parm name=\\\"TimeZone\\\" value=\\\"America/Los_Angeles\\\" />\" +\n\t\"</characteristic>\"+\n\t\"</characteristic>\";\n\n\temdkStatus = mProfileManager.processProfile(\"EMDKProfile1/Clock/ck2\", ProfileManager.PROFILE_FLAG.SET, extraData);\n\n* If the ProfileFlag is SET, the emdk_name is NOT given in ExtraData and if the first parameter passed to processProfileis has the fully qualified name (ex: EMDKProfile1/Clock/ck2) , content will be appended to the profile (this only applicable for non-DataCapture features).\n  \nExample:  \n\t\n\t:::java\n\tString[] extraData = new String[1];\n\textraData[0]=\n\t\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" +\n\t\"<characteristic type=\\\"Profile\\\">\" +\n\t\"<parm name=\\\"ProfileName\\\" value=\\\" EMDKProfile1\\\"/>\" +\n\t\"<characteristic type=\\\"Clock\\\">\" +\n\t\"<parm name=\\\"Date\\\" value=\\\"2013-05-23\\\" />\" +\n\t\"<parm name=\\\"Time\\\" value=\\\"6:59:00\\\" />\" +\n\t\"<parm name=\\\"TimeZone\\\" value=\\\"America/Los_Angeles\\\" />\" +\n\t\"</characteristic>\"+\n\t\"</characteristic>\";\n\n\temdkStatus = mProfileManager.processProfile(\"EMDKProfile1/Clock\", ProfileManager.PROFILE_FLAG.SET, extraData);\n\n#### PROFILE_FLAG.SET Usage Summary\nHere is a summary of the above scenarios when using PROFILE_FLAG.SET and XML in the extraData parameter:\n\n<table class=\"table\">\n\t<tr>\n\t\t<th>profileName</th>\n\t\t<th>EMDKConfig.XML</th>\n\t\t<th>extraData</th>\n\t\t<th>Behavior</th>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1</td>\n\t\t<td>Contains all features in xml</td>\n\t\t<td>No</td>\n\t\t<td>Settings specified in XML will get applied to the device.</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Barcode</td>\n\t\t<td>Contains all features in xml</td>\n\t\t<td>No</td>\n\t\t<td>Settings specified in DataCapture nodes in XML will get applied to the device.</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Barcode/Bar1</td>\n\t\t<td>Contains all features in xml</td>\n\t\t<td>No</td>\n\t\t<td>Settings specified in DataCapture nodes in XML will get applied to the device given that the emdk_name is set as Bar1.</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Clock</td>\n\t\t<td>Contains all features in xml(Clk1 and Clk2)</td>\n\t\t<td>No</td>\n\t\t<td>All the Clock feature nodes are applied to the device.</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Clock/Clk1</td>\n\t\t<td>Contains all features in xml(Clk1 and Clk2)</td>\n\t\t<td>No</td>\n\t\t<td>Settings defined in the Clk1 node will be applied to the device.</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Clock/Clk2</td>\n\t\t<td>Contains all features in xml(Clk1 and Clk2)</td>\n\t\t<td>No</td>\n\t\t<td>Settings defined in the Clk2 node will be applied to the device.</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1</td>\n\t\t<td>Contains all features in xml</td>\n\t\t<td>Settings for Barcode and Clk2</td>\n\t\t<td>Settings in XML and in extraData gets applied to the device</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Barcode</td>\n\t\t<td>Contains all features in xml</td>\n\t\t<td>Settings for Barcode and Clk2</td>\n\t\t<td>FAILURE is returned</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Barcode/Bar1</td>\n\t\t<td>Contains all features in xml</td>\n\t\t<td>Settings for Barcode and Clk1</td>\n\t\t<td>FAILURE is returned</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Clock</td>\n\t\t<td>Contains all features in xml(Clk1 and Clk2)</td>\n\t\t<td>Settings for Barcode and Clk1</td>\n\t\t<td>FAILURE is returned</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Clock</td>\n\t\t<td>Contains all features in xml(Clk1 and Clk2)</td>\n\t\t<td>Settings for Barcode and Clk2</td>\n\t\t<td>FAILURE is returned</td>\n\t</tr>\n\t<tr>\n\t\t<td>Profile1/Clock/Clk1</td>\n\t\t<td>Contains all features in xml(Clk1 and Clk2)</td>\n\t\t<td>Settings for Barcode and Clk1</td>\n\t\t<td>FAILURE is returned</td>\n\t</tr>\n</table>"},{"key":"guide-profiles-wifi","name":" Wi-Fi Manager Profile Feature Reference","md":"# Wi-Fi Manager Profile Feature Reference\n\n## Overview\n\nThe Wi-Fi feature allows you to manage your devices Wi-Fi settings as well as manage the network profiles to be used for connecting and remembering networks.\n\n>Note: In order for settings to be applied, Wi-Fi must be enabled. If you do not specify WiFi Enable in the profile you will get an error when attempting to apply other settings if the device's Wi-Fi is not already enabled.\n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable Wi-Fi\n* Disable Wi-Fi\n* Set Wi-Fi to Never Sleep\n* Set Wi-Fi to Never Sleep When Plugged In\n* Set Wi-Fi to Always Sleep\n* Use Network Notifications\n* Do Not User Network Notifications\n* Enable Auto Country Selection\n* Manually Select country\n* Set the RF Band\n* Enable Auto RF Band Selection\n* Enable the Device to set the Clock off the AP (Access Point) Time\n* Enable HF SR (Hyper Fast Secure Roam)\n* Disable HR SR (Hyper Fast Secure Roam)\n* Enable CCKM (Cisco Centralized Key Management)\n* Disable CCKM (Cisco Centralized Key Management)\n* Enable FT (Fast Transition)\n* Disable FT (Fast Transition)\n* Enable FTRIC (Fast Transition Resource Request)\n* Disable FTRIC (Fast Transition Resource Request)\n* Enable OKC (Opportunistic Key Caching)\n* Disable OKC (Opportunistic Key Caching)\n* Enable PreAuth\n* Disable PreAuth\n* Set Power Saving Mode to Fast Power Savings\n* Set Power Savings Mode to Always Active\n* Set Power Savings Mode to Maximum Power Savings\n* Enable Advanced Logging\n* Disable Advanced Logging\n* Enable FIPS Compliance\n* Disable FIPS Compliance\n* Enable Restricted WLAN Settings UI\n* Disable Restricted WLAN Settings UI\n* Add a Wi-Fi Network\n* Remove a Wi-Fi Network\n* Connect to a Wi-Fi Network\n* Disconnect from a Wi-Fi Network\n* Enable an Existing Wi-Fi Network\n* Disable an Existing Wi-Fi Network\n* Disable all Existing Wi-Fi Networks\n* Remove all Existing Wi-Fi Networks\n\n\n## Wi-Fi Enable\nEnable Disable Wi-Fi Radio.\n\n>Note: In order for other settings to be applied, Wi-Fi must be enabled. If you do not specify WiFi Enable in the profile you will get an error when attempting to apply other settings if the device's Wi-Fi is not already enabled.\n\n* Do not change - will use whatever the device is currently configured as.\n* Enable - enabled the Wi-Fi radio\n* Disable - disabled the Wi-Fi radio\n\n## Country Selection Auto/Manual\nBy leaving this option unchecked, the country may be determined by the router or access point setting. To manually select the country, you should select the checkbox. When doing this a country drop-down will appear.\n\n## Country\nCountry to use for Wi-Fi regulatory setting. 802.11d will not be enabled if you select 'U.S.A' in the Country drop-down. When you choose 'AUTO' in the drop-down, 802.11d will be enabled. \n\n## RF Band\nSpecifies the 802.11 band(s) to use.\n\n* Unchanged - will use whatever the device is currently configured as.\n* 2.4GHZ - enable 2.4GHz band\n* 5.0GHZ - enable 5.0GHz band\n* Auto - enable both bands and connect automatically to either.\n\n## Wi-Fi Channel\n* 2.4GHz Channels - enable the specified channels in the 2.4GHz band. \n    * String containing a set of valid channels. Comma separated and may contain a range specified with a dash '-'. Example: 1,7-10\n* 5.0GHz Channels - enable the specified channels in the 5.0GHz band.\n    * String containing a set of valid channels. Comma separated and may contain a range specified with a dash '-'. Example: 36-60\n\n## Sleep Policy\nSpecifies the state of the Wi-Fi radio when the device suspends.    \n\n* Do not change - will use whatever the device is currently configured as.\n* Always Sleep - Power down the Wi-Fi radio.\n* Never Sleep When Plugged - Leave Wi-Fi radio powered while it is connected to A/C power and power down the Wi-Fi radio while it is on battery.\n* Never Sleep - Leave Wi-Fi radio powered.\n\n## Network Notification\nSpecifies whether or not to notify the user when a open network comes in range.\n\n* Do not change - will use whatever the device is currently configured as.\n* Use network notification - Notify the user when a network comes in range.\n* Do not use network notification - Don't notify the user when a network comes in range.\n\n## Network Action\nUsed to manage the network profiles on the device.\n\n* Add a New Network - will add a new profile with the provided profile settings.\n* Remove an Existing Network - will remove the a network profile based on the SSID.\n* Connect to an Existing Network - will initiate a connection to the network based on the SSID.\n* Disconnect from an Existing Network - will disconnect from a network based on the SSID.\n* Enable an Existing Network - will enable a network profile based on the SSID.\n* Disable an Existing Network - will disable a network profile based on the SSID.\n* Disable All Existing Networks - will disable all network profiles.\n* Remove All Existing Networks - will remove all network profiles.\n\n## Wi-Fi Profiles\nParameters used for adding a network. SSID is used to identify the network profile to be acted on when choosing an '... an Existing Network' network action above.\n\n* SSID - the SSID name of the network\n* Security Mode \n    * Open - Open network\n    * Personal - PSK or WEP\n    * Enterprise - 802.1x EAP profiles\n* WPA Mode:  WPA mode used by the network. Ex: WPA, WPA2, WPA/WPA2, WEP\n>Note: WEP is not supported with a Enterprise Security Mode. It is only supported using Personal Security Mode.\n\n* Authentication Mode: Authentication mode used by the network. used with Enterprise Security Mode. Ex: EAP-TLS, EAP-FAST-GTC, EAP-FAST-MSCHAPV2, EAP-TTLS-PAP, EAP-TTLS-MSCHAP, EAP-TTLS-MSCHAPV2, LEAP, PEAP-MSCHAPV2, PEAP-GTC\n* DHCP: When selected DHCP will be used. When not selected, Static IP address is used and IP address settings should be provided ex: Static IP Address, Gateway IP Address, Subnet Mask, DNS Server IP Address\n* Proxy: When selected, a Proxy is used for network connections. Proxy settings should be supplied. Ex: Proxy Host Name, Port, Bypass Proxy\n\n## Encryption Details\n* Encryption Type: Type of encryption used by the network. The values in this drop-down will change based on the WPA Mode selected. Ex: TKIP, AES-CCMP, AES-CCMP/TKIP, WEP-40, WEP-104\n* Key Type: Passphrase or Hex Key\n* Protect Key: Enables encryption of the Key\n* Web Key Index: Only `wep[0]` is a valid option\n\n## Authentication Details\nSpecific authentication settings when Enterprise Mode and specific Authentication modes are selected.\n\n* Identity - the name that should be used to join the network.\n* Server Certificate - the name of the certificate alias that should be used to verify the server (Optional).\n* Client Certificate - the name of the certificate alias that should be used to join the network (Mandatory).\n* Anonymous Identity - the anonymous identity to be used to join the network.\n* Password - the password to be used to connect to the network.\n* Protect Password - when selected will encrypt the password.\n\n### EAP-TLS and Certificate Alias \nDue to current limitations of the Certificate Manager Feature (in an EAP-TLS scenario), it is not possible to \"override\" the Alias that is assigned to a Client Certificate and Private Key when they are installed into the Android KeyStore\n\nThe only way to determine the actual Alias that is assigned to a Client Certificate and Private Key when they are installed into the Android KeyStore is to examine the Android KeyStore after installation to determine which Alias was used:\n\n1. The same Alias will ALWAYS be assigned to a given Client Certificate and Private Key, no matter when, or on which device, it is installed\n\n2. Whenever a different Client Certificate is used, a different Alias will generally be assigned to the Client Certificate and Private Key\n\n#### Manually Determining the Certificate Alias\nA device can be used to capture the alias being used for the certificate being installed. It is recommended that the key store be cleared before performing these steps (Settings->Security->Clear Credentials)\n\n1. Use Certificate Manager to install the certificate onto a device.\n2. Navigate to Settings->Wi-Fi->'+'' to add a network\n3. Scroll to security, tap and select 802.1x EAP\n4. Scroll to EAP method, tap and select TLS\n5. Scroll to client certificate, tap and note a drop down box with \"(unspecified)\" and the alias of the installed certificate. The alias listed can become the value to use as the certificate when using WiFiConfig to configure a profile that uses EAP-TLS.\n\n## Advanced Options\n\n>Note: The following steps must be followed in order to use the Advanced Options under the WiFi feature:\n>\n>* PMKID must be enabled in order to enable PreAuth (PreAuth =1 and PMKID =1)\n>* FT must be enabled in order to enable FTRIC (FT=1 and FTRIC =1)\n>* OKC must be disabled (OKC =0 and PMKID =1) in order to use PMKID caching\n>\n> Important Note: The default \"Fast Power Savings\" value must be used for the \"Power Save\" parameter under the Advanced Options. Using the \"Do Not Change\" value will result in failure.\n\n* AutoTimeConfig- Enable AutoTimeConfig feature. Updates device timestamp based on based on Symbol IE in 802.11 beacon. This is a Symbol specific feature.\n* HFSR - Hyper Fast Secure Roam (HFSR) is a Symbol's fast roam algorithm. \n* CCKM - This is to enable / disable CCX roam algorithm (CCKM).\n* FT - This is to enable / disable Fast Transition roam algorithm (802.11r).\n* FTRIC - This is to enable / disable Fast Transition Resource Request (802.11r).\n* OKC- This is to enable / disable Opportunistic Key Caching (OKC).\n* PMKID - This is to enable / disable PMKID Caching. We need to disable OKC and enable PMKID for PMKID caching to work.\n* PreAuth- This is to enable / disable 802.1x Pre-Authentication.\n* PowerSave - This option is to configure different Power Save Modes of Radio.\n    * Do not change - will use whatever the device is currently configured as.\n    * Always Active: This will keep the radio in active\n    * Fast Power Savings: This will keep the radio in Auto Power Save.\n    * Maximum Power Savings: This will keep the radio in Auto Power Save.\n* Advanced Logging - Start or Stop advanced Wi-Fi logging.\n* FIPS - We can use this option to enable disable FIPS data in motion supported in WLAN. WLAN FIPS 140-2, level 1 compliance.\n* Enable Restricted Settings UI - When enabled the Wi-Fi settings will be in Read-Only mode.\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=Wi-Fi&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-wireless","name":" Wireless Manager Profile Feature Reference","md":"# Wireless Manager Profile Feature Reference\n\n## Overview\n\nThe Wireless Manager allows you to configure wireless configurations on your device. (Ex. Configure device's Bluetooth)  \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Enable/Disable Bluetooth\n* Turn on/off Bluetooth\n* Turn on/off NFC\n* Turn on/off GPS\n* Turn on/off WWAN (Wireless WAN)\n\n\n## Bluetooth\nThis profile feature allows your application to enable or disable usage of bluetooth on a device.\n\n### Turn on/off Bluetooth\nThis profile feature allows your application to turn on or off a devices bluetooth radio. Bluetooth must be enabled\nbefore turning it on.\n\n## NFC\nThis profile feature allows your application to turn on or off a devices NFC radio.\n\n## GPS\nThis profile feature allows your application to turn on or off a devices GPS radio.\n\n## WWAN \nThis profile feature allows your application to turn on or off a devices WAN (Wireless WAN) radio.\n\n\n## Feature Compatibility\n\n<iframe src=\"compare.html#mx=4.3&csp=WirelessMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-profiles-xml","name":" XML Manager Profile Feature Reference","md":"# XML Manager Profile Feature Reference\n\n## Overview\n\nThe XML Manager feature allows you to specify various XML processing modes to be used.  \n\n## Name\nThe name field is used by the EMDK to identify this particular feature parameter set when you want to manage just part of the profile programmatically using the EMDK [ProfileManager](#api-ProfileManager) API. This can be useful if you have multiple types of the same feature and want to update only one of them without having to update the whole profile. See [EMDK Profiles Overview](#guide-profiles-usingwizard) for more information.\n\n## Main Functionality\n\n* Specify the XML processing mode to use\n * Execute all to end\n * Execute until error, then stop\n * Try until error, then Skip to Catch\n * Catch error, Execute remainder\n\n\n## XML Processing Mode\nSpecify the XML processing mode to use\n\n* Execute all to end\n* Execute until error, then stop\n* Try until error, then Skip to Catch\n* Catch error, Execute remainder\n\n## Feature Compatibility\n<iframe src=\"compare.html#mx=4.3&csp=XmlMgr&os=All&embed=true\"></iframe> \n\n\n"},{"key":"guide-reference-EMDKList","name":"EMDK For Android API List","md":"#EMDK For Android API List\n\n## Core and ProfileManager APIs\nThe following APIs are to be used to process EMDK features and profiles using the [Profile Manager](#guide-profiles-usingwizard) as well as getting information about the EMDK.\n\n###EMDKBase\n* [EMDKBase](#api-EMDKBase)\n\n###EMDKManager\n* [EMDKManager](#api-EMDKManager) \n* [EMDKManager.EMDKListener](#api-EMDKManager-EMDKListener) \n\n###EMDKResults\n* [EMDKResults](#api-EMDKResults)\n\n###ProfileConfig\n* [ProfileConfig](#api-ProfileConfig)\n* [ProfileConfig.ActivitySelection](#api-ProfileConfig-ActivitySelection) \n* [ProfileConfig.ActivitySelection.ActivityElement](#api-ProfileConfig-ActivitySelection-ActivityElement) \n* [ProfileConfig.DataCapture](#api-ProfileConfig-DataCapture) \n* [ProfileConfig.DataCapture.Barcode](#api-ProfileConfig-DataCapture-Barcode) \n* [ProfileConfig.DataCapture.Barcode.Decoders](#api-ProfileConfig-DataCapture-Barcode-Decoders) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams](#api-ProfileConfig-DataCapture-Barcode-DecoderParams) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code11](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code128](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code39](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code93](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB)\n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5)\n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.MSI](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.USPlanet](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-USPlanet)\n* [ProfileConfig.DataCapture.Barcode.DecoderParams.USPostnet](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-USPostnet)\n* [ProfileConfig.DataCapture.Barcode.ReaderParams](#api-ProfileConfig-DataCapture-Barcode-ReaderParams) \n* [ProfileConfig.DataCapture.Barcode.ScanParams](#api-ProfileConfig-DataCapture-Barcode-ScanParams) \n* [ProfileConfig.DataCapture.Barcode.UpcEanParams](#api-ProfileConfig-DataCapture-Barcode-UpcEanParams) \n* [ProfileConfig.DataCapture.MSR](#api-ProfileConfig-DataCapture-MSR) \n* [ProfileConfig.DataCapture.DataDelivery](#api-ProfileConfig-DataCapture-DataDelivery) \n* [ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting) \n* [ProfileConfig.DataCapture.DataDelivery.Intent](#api-ProfileConfig-DataCapture-DataDelivery-Intent) \n* [ProfileConfig.DataCapture.DataDelivery.Keystroke](#api-ProfileConfig-DataCapture-DataDelivery-Keystroke)\n\n###ProfileManager\n* [ProfileManager](#api-ProfileManager)\n* [ProfileManager.DataListener](#api-ProfileManager-DataListener)\n* [ProfileManager.ResultData](#api-ProfileManager-ResultData) \n\n###VersionManager\n* [VersionManager](#api-VersionManager) \n\n\n\n## Barcode APIs\nThe following APIs are used when you wish to handle all barcode scanning entirely in Java. These API's work independently of any [Data Capture profiles.](#guide-profiles-profilebarcode)\n\n###BarcodeManager\n* [BarcodeManager](#api-BarcodeManager)\n* [BarcodeManager.ScannerConnectionListener](#api-BarcodeManager-ScannerConnectionListener)\n* [BarcodeManager.ScannerConnectionListener.ConnectionStatus](#api-BarcodeManager-ScannerConnectionListener-ConnectionStatus)\n\n###Collection\n* [Collection.ScanData](#api-Collection-ScanData)\n\n###InterfaceConfig\n* [InterfaceConfig](#api-BarcodeInterfaceConfig)\n\n###ScanDataCollection\n* [ScanDataCollection](#api-ScanDataCollection)\n\n\n###Scanner\n* [Scanner](#api-Scanner)\n* [Scanner.DataListener](#api-Scanner-DataListener)\n* [Scanner.StatusListener](#api-Scanner-StatusListener)\n\n###ScannerConfig\n* [ScannerConfig](#api-ScannerConfig)\n* [ScannerConfig.DecoderParams](#api-ScannerConfig-DecoderParams)\n* [ScannerConfig.DecoderParams.AustralianPostal](#api-ScannerConfig-DecoderParams-AustralianPostal)\n* [ScannerConfig.DecoderParams.Aztec](#api-ScannerConfig-DecoderParams-Aztec)\n* [ScannerConfig.DecoderParams.BaseDecoder](#api-ScannerConfig-DecoderParams-BaseDecoder)\n* [ScannerConfig.DecoderParams.CanadianPostal](#api-ScannerConfig-DecoderParams-CanadianPostal)\n* [ScannerConfig.DecoderParams.Chinese2of5](#api-ScannerConfig-DecoderParams-Chinese2of5)\n* [ScannerConfig.DecoderParams.CodaBar](#api-ScannerConfig-DecoderParams-CodaBar)\n* [ScannerConfig.DecoderParams.Code11](#api-ScannerConfig-DecoderParams-Code11)\n* [ScannerConfig.DecoderParams.Code128](#api-ScannerConfig-DecoderParams-Code128)\n* [ScannerConfig.DecoderParams.Code39](#api-ScannerConfig-DecoderParams-Code39)\n* [ScannerConfig.DecoderParams.Code93](#api-ScannerConfig-DecoderParams-Code93)\n* [ScannerConfig.DecoderParams.CompositeAB](#api-ScannerConfig-DecoderParams-CompositeAB)\n* [ScannerConfig.DecoderParams.CompositeC](#api-ScannerConfig-DecoderParams-CompositeC)\n* [ScannerConfig.DecoderParams.D2of5](#api-ScannerConfig-DecoderParams-D2of5)\n* [ScannerConfig.DecoderParams.DataMatrix](#api-ScannerConfig-DecoderParams-DataMatrix)\n* [ScannerConfig.DecoderParams.DutchPostal](#api-ScannerConfig-DecoderParams-DutchPostal)\n* [ScannerConfig.DecoderParams.Ean13](#api-ScannerConfig-DecoderParams-Ean13)\n* [ScannerConfig.DecoderParams.Ean8](#api-ScannerConfig-DecoderParams-Ean8)\n* [ScannerConfig.DecoderParams.Gs1Databar](#api-ScannerConfig-DecoderParams-Gs1Databar)\n* [ScannerConfig.DecoderParams.Gs1DatabarExp](#api-ScannerConfig-DecoderParams-Gs1DatabarExp)\n* [ScannerConfig.DecoderParams.Gs1DatabarLim](#api-ScannerConfig-DecoderParams-Gs1DatabarLim)\n* [ScannerConfig.DecoderParams.HanXin](#api-ScannerConfig-DecoderParams-HanXin)\n* [ScannerConfig.DecoderParams.I2of5](#api-ScannerConfig-DecoderParams-I2of5)\n* [ScannerConfig.DecoderParams.JapanesePostal](#api-ScannerConfig-DecoderParams-JapanesePostal)\n* [ScannerConfig.DecoderParams.Korean3of5](#api-ScannerConfig-DecoderParams-Korean3of5)\n* [ScannerConfig.DecoderParams.MailMark](#api-ScannerConfig-DecoderParams-MailMark)\n* [ScannerConfig.DecoderParams.Matrix2of5](#api-ScannerConfig-DecoderParams-Matrix2of5)\n* [ScannerConfig.DecoderParams.MaxiCode](#api-ScannerConfig-DecoderParams-MaxiCode)\n* [ScannerConfig.DecoderParams.MicroPdf](#api-ScannerConfig-DecoderParams-MicroPdf)\n* [ScannerConfig.DecoderParams.MicroQr](#api-ScannerConfig-DecoderParams-MicroQr)\n* [ScannerConfig.DecoderParams.Msi](#api-ScannerConfig-DecoderParams-Msi)\n* [ScannerConfig.DecoderParams.Pdf417](#api-ScannerConfig-DecoderParams-Pdf417)\n* [ScannerConfig.DecoderParams.QrCode](#api-ScannerConfig-DecoderParams-QrCode)\n* [ScannerConfig.DecoderParams.Signature](#api-ScannerConfig-DecoderParams-Signature)\n* [ScannerConfig.DecoderParams.Tlc39](#api-ScannerConfig-DecoderParams-Tlc39)\n* [ScannerConfig.DecoderParams.TriOptic39](#api-ScannerConfig-DecoderParams-TriOptic39)\n* [ScannerConfig.DecoderParams.UkPostal](#api-ScannerConfig-DecoderParams-UkPostal)\n* [ScannerConfig.DecoderParams.UpcEanParams](#api-ScannerConfig-DecoderParams-UpcEanParams)\n* [ScannerConfig.DecoderParams.Upca](#api-ScannerConfig-DecoderParams-Upca)\n* [ScannerConfig.DecoderParams.Upce0](#api-ScannerConfig-DecoderParams-Upce0)\n* [ScannerConfig.DecoderParams.Upce1](#api-ScannerConfig-DecoderParams-Upce1)\n* [ScannerConfig.DecoderParams.Us4State](#api-ScannerConfig-DecoderParams-Us4State)\n* [ScannerConfig.DecoderParams.Us4StateFics](#api-ScannerConfig-DecoderParams-Us4StateFics)\n* [ScannerConfig.DecoderParams.UsPlanet](#api-ScannerConfig-DecoderParams-UsPlanet)\n* [ScannerConfig.DecoderParams.UsPostNet](#api-ScannerConfig-DecoderParams-UsPostNet)\n* [ScannerConfig.DecoderParams.WebCode](#api-ScannerConfig-DecoderParams-WebCode)\n* [ScannerConfig.ReaderParams](#api-ScannerConfig-ReaderParams)\n* [ScannerConfig.ReaderParams.ReaderSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific)\n* [ScannerConfig.ReaderParams.ReaderSpecific.CameraSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific-CameraSpecific)\n* [ScannerConfig.ReaderParams.ReaderSpecific.ContinuousRead](#api-ScannerConfig-ReaderParams-ReaderSpecific-ContinuousRead)\n* [ScannerConfig.ReaderParams.ReaderSpecific.ImagerSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific-ImagerSpecific)\n* [ScannerConfig.ReaderParams.ReaderSpecific.LaserSpecific](#api-ScannerConfig-ReaderParams-ReaderSpecific-LaserSpecific)\n* [ScannerConfig.ScanParams](#api-ScannerConfig-ScanParams)\n\n###ScannerException\n* [ScannerException](#api-ScannerException)\n\n###ScannerInfo\n* [ScannerInfo](#api-ScannerInfo)\n\n###StatusData\n* [StatusData](#api-StatusData)\n\n\n\n## ScanAndPair APIs\nThe ScanAndPair API provides simple methods to scan a Bluetooth barcode (Bluetooth name or address) of a remote device and pair/unpair with the Bluetooth device. \n\n###ScanAndPairManager\n* [ScanAndPairManager](#api-ScanAndPairManager)\n* [ScanAndPairManager.StatusListener](#api-ScanAndPairManager-StatusListener)\n\n###ScanAndPairConfig\n* [ScanAndPairConfig](#api-ScanAndPairConfig)\n* [ScanAndPairConfig.BluetoothInfo](#api-ScanAndPairConfig-BluetoothInfo)\n* [ScanAndPairConfig.ScanInfo](#api-ScanAndPairConfig-ScanInfo)\n\n###ScanAndPairException\n* [ScanAndPairException](#api-ScanAndPairException)\n\n###StatusData\n* [StatusData](#api-ScanAndPairStatusData)\n\n\n\n## SimulScan APIs\nSimulScan is an end-to-end data capture solution for extracting critical data from documents. A differentiating data capture value-add, it involves capturing fields of interest in a given document and converting it into data that an end-user application can use immediately at the point of transaction. SimulScan customers benefit from:\n\n* Productivity gain by decoding multiple bar codes read with a single trigger pull\n* Automated data entry with character recognition [OCR]\n* Simplified workflow exceptions with checked mark recognition [OMR] and Signature presence detection.\n\nCustomers can interactively capture documents and obtain meaningful data present in the document.  Barcodes are identified and decoded; strings are recognized from fields containing text; images are refined from fields containing pictures and so forth. Based on a \"template\", an image of the entire document is processed by various engines to extract the relevant data.\n\n###SimulScanManager\n* [SimulScanManager](#api-SimulScanManager)\n\n\n###SimulScanConfig\n* [SimulScanConfig](#api-SimulScanConfig)\n\n\n###SimulScanData\n* [SimulScanData](#api-SimulScanData)\n\n\n###SimulScanElement\n* [SimulScanElement](#api-SimulScanElement)\n\n\n###SimulScanException\n* [SimulScanException](#api-SimulScanException)\n\n\n###SimulScanGroup\n* [SimulScanGroup](#api-SimulScanGroup)\n\n\n###SimulScanMultiTemplate\n* [SimulScanMultiTemplate](#api-SimulScanMultiTemplate)\n\n\n###SimulScanReader\n* [SimulScanReader](#api-SimulScanReader)\n* [SimulScanReader.DataListerner](#api-SimulScanReader-DataListerner)\n* [SimulScanReader.StatusListerner](#api-SimulScanReader-StatusListerner)\n\n\n###SimulScanReaderInfo\n* [SimulScanReaderInfo](#api-SimulScanReaderInfo)\n\n\n###SimulScanRegion\n* [SimulScanRegion](#api-SimulScanRegion)\n\n\n###SimulScanStatusData\n* [SimulScanStatusData](#api-SimulScanStatusData)\n* [SimulScanStatusData.ExtendedInfo](#api-SimulScanStatusData-ExtendedInfo)\n\n\n###SimulScanTemplate\n* [SimulScanTemplate](#api-SimulScanTemplate)\n\n\n###SimulScanTemplateElement\n* [SimulScanTemplateElement](#api-SimulScanTemplateElement)\n\n\n###SimulScanTemplateGroup\n* [SimulScanTemplateGroup](#api-SimulScanTemplateGroup)\n\n\n###SimulScanTemplateRegion\n* [SimulScanTemplateRegion](#api-SimulScanTemplateRegion)"},{"key":"guide-reference-refbatteryintent","name":" Battery Intent API Reference","md":"# Battery Intent API Reference\n\n## Overview\nThe purpose of this document is to describe the functionality of the Battery Intent API Interface. Its intended audience are Android developers. \n \n## Requirements\nKnowledge of Android programming and familiarity with the Android intent mechanism are assumed. \n \n* Android Versions:\t\n\t* 2.3.4 and later.\n* Devices:\t\n\t* Symbol Android devices, such as the ET1 rev D, MC40 rev A.\n \n \n## Features\nOn Symbol devices like the MC40, extra battery information can be retrieved using the standard [Android Battery Intent](http://developer.android.com/training/monitoring-device-state/battery-monitoring.html). Setting up to receive this information is the same as with consumer Android devices. However, the data that is returned to your application includes some extra information like:\n\n* Backup Battery Voltage\n* Battery Manufacture Date\n* Battery Serial Number\n* Part Number for Battery\n* Unique ID for Battery\n* Rated Capacity of the Battery\n* Charge Cycle count of the Battery\n \n## Programming Interface\n \n#### Function Prototype\n\t\n\t:::java\n\tmIntent_Receiver = new Intent_Receiver();  \n\tmIntentFilter = new IntentFilter();  \n\tmIntentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);  \n\tregisterReceiver(mIntent_Receiver,mIntentFilter); \n\n#### Parameters\n\nPlease reference the Android Battery Manager [API](http://developer.android.com/reference/android/os/BatteryManager.html). \n\n#### Return Values\n\nIn addition to the battery information Android returns by default, which can be found [here](http://developer.android.com/reference/android/os/BatteryManager.html), Symbol devices return the following additional parameters: \n\n* **bkvoltage** - Backup Battery Voltage\n* **mfd**  - Battery Manufacture Date\n* **serialnumber** - Battery Serial Number\n* **partnumber** - Part Number for Battery\n* **uniqueid** - Unique ID for Battery\n* **ratedcapacity** - Rated Capacity of the Battery\n* **cycle** - Charge Cycle count of the Battery\n\n#### Example\n\n\t:::java\n\tpublic void onReceive(Context context, Intent intent) {      \n\t\tif (BATTERY_STATE_CHANGED_INTENT.equals(intent.getAction())) {          \n\n\t\t\tint bkvoltage = intent.getExtras().getInt(\"bkvoltage\");  \n\t\t\tString mfd = intent.getExtras().getString(\"mfd\");  \n\t\t\tString serialnumber = intent.getExtras().getString(\"serialnumber\");  \n\t\t\tString partnumber = intent.getExtras().getString(\"partnumber\");  \n\t\t\tString uniqueid = intent.getExtras().getString(\"uniqueid\");  \n\t\t\tint ratedcapacity = intent.getExtras().getInt(\"ratedcapacity\");  \n\t\t\tint cycle = intent.getExtras().getInt(\"cycle\");  \n\t\t     \n\t\t}  \n\t} \n"},{"key":"guide-reference-refdatacaptureintent","name":" Data Capture Intent API Reference","md":"# Data Capture Intent API Reference\n## Overview\nThe purpose of this document is to describe the functionality of the Data Capture API. Its intended audience are Android developers. The Data Capture API is an application programming interface which provides a number of specific commands that another application can use to control certain aspects of data capture on Android devices.\n \n## Requirements\nKnowledge of Android programming and familiarity with the Android intent mechanism are assumed. Also assumed is some familiarity with DataWedge and that you have read the DataWedge section in the Integrator Guide for your device.\n \n* Android Versions:\t\n\t* 2.3.4 and later\n* Devices:\t\n\t* ET1 rev D, MC40 rev A, TC55, etc.\n \n \n## Features\nThe following is a list of the high-level API functions:\n\n* Start/stop/toggle the soft scan trigger.\n* Disable/enable the scanner plug-in in the currently active profile.\n* Provide a list of available scanners.\n* Make an un-associated user created profile the default profile.\n* Reset the default profile back to Profile0.\n* Switch the current profile to a user created profile that is un-associated.\n \n## DataWedge Profiles\nThe DataCapture APIs use the DataWedge profiles for collecting and formatting data.  For example, each user application can have a profile which outputs scanned data in the required format when that application comes to the foreground. DataWedge can be configured to process the same set of captured data differently based on the requirements of each application.  Refer to the DataWedge section in your devices Integrator Guide for more information on DataWedge profiles.\n \n## Programming Interface\nAn application will access the Data Capture API by broadcasting an intent. It will use the primary pieces of information in a intent, action and data, to specify the API function to perform.\n \n### SoftScanTrigger\n#### Description\nThe SoftScanTrigger API command can be used to start, stop or toggle the soft scan trigger.\n \n \n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<parameter>\");\n\n#### Parameters\n\n* ACTION: String \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\"\n* EXTRA_DATA: String \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\"\n* `<parameter>`:\tThe parameter as a string, either of the following:\n\t* \"START_SCANNING\" - to start scanning\n\t* \"STOP_SCANNING\" - to stop scanning\n\t* \"TOGGLE_SCANNING\" - to toggle between start scanning and stop scanning\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n* `$ adb logcat -s DWAPI`\n* Error messages will be logged for invalid actions and parameters\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString softScanTrigger = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";  \n\t  \n\t// create the intent  \n\tIntent I = new Intent();  \n\t// set the action to perform  \n\ti.setAction(softScanTrigger);  \n\t// add additional info  \n\ti.putExtra(extraData, \"START_SCANNING\");  \n\t// send the intent to DataWedgecontext.this.sendBroadcast(i);  \n\n#### Comments\nThe received API commands are not queued; API commands are processed immediately. Commands received while the current API command is still being processed may be ignored. For example, attempting to send the soft scan trigger start command immediately after sending the scanner enable command will result in the soft scan trigger command being ignored because the scanner enable will not have had time to complete. In this case, the soft scan trigger command should be delayed sufficiently for the scanner enable to complete; one example of how this could be done is given below.\n\n\t:::java\n\tint triggerDelay = 250; // delay in milliseconds  \n\t  \n\tHandler handler = new Handler();  \n\thandler.postDelayed(new Runnable() {       \n\t      public void run()  \n\t      {               \n\t          // for clarity, assume the following method contains the code in the example above               \n\t          startSoftScan();       \n\t      }  \n\t}, triggerDelay);  \n\n### ScannerInputPlugin\n#### Description\nThe ScannerInputPlugin API command can be used to enable/disable the scanner plug-in in the currently active profile. Disabling the scanner plug-in effectively disables scanning in that profile (associated or un-associated).\n \n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<parameter>\"); \n\n#### Parameters\n\n* ACTION: String \"com.motorolasolutions.emdk.datawedge.api.ACTION_SCANNERINPUTPLUGIN\"\n* EXTRA_DATA: String \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\"\n* `<parameter>`:\tThe parameter as a string, either of the following:\n\t* \"ENABLE_PLUGIN\" - enables the plug-in\n\t* \"DISABLE_PLUGIN\" - disables the plug-in\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* `$ adb logcat -s DWAPI`\n* Error messages will be logged for invalid actions and parameters\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString scannerInputPlugin = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SCANNERINPUTPLUGIN\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";  \n\t  \n\tpublic void onResume() {       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(scannerInputPlugin);       \n\t    // add additional info       \n\t    i.putExtra(extraData, \"DISABLE_PLUGIN\");       \n\t    // send the intent to DataWedge       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\nThis Data Capture API intent will allow you to enable/disable the scanner plug-in for the current profile. For example, lets say that activity A launches and uses the Data Capture API intent to switch to profileA in which the scanner plug-in is enabled, then at some point it uses the Data Capture API to disable the scanner plug-in. Activity B is launched. In DataWedge, profileB is associated with activity B. DataWedge switches to profileB. When activity A comes back to the foreground, in the onResume method, activity A will need to use the Data Capture API intent to switch back to profileA, then use the Data Capture API intent again to disable the scanner plug-in, to return back to the state it was in.\n\n>Note: The above assumes that profileA is not associated to any applications/activities, therefore when focus switches back to activity A, DataWedge will not automatically switch to profileA therefore activity A must switch back to profileA in its onResume method. Because DataWedge will automatically switch profile when your activity is paused, it is recommended that this API function be called from the onResume method of your activity.\n\n### enumerateScanners\n#### Description\nThe enumerateScanners API command can be used to get a list of scanners available on the device.\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATESCANNERS\"\n\n#### Return Values\n* The enumerated list of scanners will be returned via a broadcast intent. The broadcast intent action is \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATEDSCANNERLIST\" and the list of scanners is returned as a string array (see the example below).\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* $ adb logcat -s DWAPI\n* Error messages will be logged for invalid actions and parameters\n\n#### Example\n\n\t:::java\n\t// first send the intent to enumerate the available scanners on the device  \n\t// define action string  \n\tString enumerateScanners = \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATESCANNERS\";  \n\t// create the intent  \n\tIntent I = new Intent();  \n\t// set the action to perform  \n\ti.setAction(enumerateScanners);  \n\t// send the intent to DataWedge  \n\tcontext.this.sendBroadcast(i);// now we need to be able to receive the enumerate list of available scanners  \n\tString enumeratedList = \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATEDSCANNERLIST\";  \n\tString KEY_ENUMERATEDSCANNERLIST = \"DataWedgeAPI_KEY_ENUMERATEDSCANNERLIST\";  \n\t// Create a filter for the broadcast intentIntentFilter filter = new IntentFilter();  \n\tfilter.addAction(enumeratedList);registerReceiver(myBroadcastReceiver, filter);// now we need a broadcast receiver  \n\tprivate BroadcastReceiver myBroadcastReceiver = new BroadcastReceiver() {       \n\t      @Override        Public void onReceive(Context context, Intent intent) {               \n\t          String action = intent.getAction();               \n\t          if (action.equals(enumeratedList)) {                       \n\t                Bundle b = intent.getExtras();                       \n\t                String[] scanner_list = b.getStringArray(KEY_ENUMERATEDSCANNERLIST);               \n\t          }       \n\t      }  \n\t};  \n\n#### Comments\nThe scanner and its parameters are set based on the currently active profile.\n\n### setDefaultProfile\n#### Description\nThe setDefaultProfile API function can be used to set the specified profile as the default profile.\n\n#### Default Profile Recap\nProfile0 is the generic profile used when there are no user created profiles associated with an application. Profile0 can be edited but cannot be associated with an application. That is, DataWedge allows manipulation of plug-in settings for Profile0 but it does not allow assignment of a foreground application.\n\nThis configuration allows DataWedge to send output data to any foreground application other than applications associated with user-defined profiles when Profile0 is enabled.\n\nProfile0 can be disabled to allow DataWedge to only send output data to those applications which are associated in user-defined profiles. For example, create a profile associating a specific application, disable Profile0 and then scan. DataWedge only sends data to the application specified in the user-created profile. This adds additional security to DataWedge enabling the sending of data only to specified applications.\n\n#### Usage Scenario\nLets say a launcher application has a list of apps that a user can launch and that none of the listed apps has an associated DataWedge profile. Once the user has selected an app, the launcher needs to set the appropriate DataWedge profile for the selected app. This could be done by using setDefaultProfile to set the default profile to the required profile. Then when the user selected app is launched, DataWedge auto profile switching will switch to the default profile (which is now the required profile for that app).\n\nIf, for some reason, the launched app has an associated DataWedge profile then that will override the set default profile.\n\nWhen control is returned to the launcher application, resetDefaultProfile can be used to reset the default profile.\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<profile name>\");\n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_SETDEFAULTPROFILE\"\n* EXTRA_DATA:\tString \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\"\n* `<profile name>`:\tThe profile name to set as the default profile as a string (case-sensitive).\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* `$ adb logcat -s DWAPI`\n* Error messages will be logged for invalid actions, parameters and failures (e.g. profile not found or associated to an application).\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString setDefaultProfile = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SETDEFAULTPROFILE\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\";  \n\t  \n\tpublic void onResume() {       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(setDefaultProfile);       \n\t    // add additional info       \n\t    i.putExtra(extraData, \"myProfile\");       \n\t    // send the intent to DataWedge       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\n\n* The API command will have no effect if the specified profile does not exist or if the specified profile is already associated to an application.\n* Because DataWedge will automatically switch profile when your activity is paused, it is recommended that this API function be called from the onResume method of your activity.\n* It is recommended this profile be created to cater to all applications/activities that would otherwise default to using Profile0. This will ensure that these applications/activities continue to work with a consistent configuration.\n\nTo explain by example, lets say that initially Profile0 is the default profile using the camera as the barcode scanner. Using the Browser application and scanning a barcode with the camera, DataWedge enters the data into the Browser. Now you launch an application that changes the default profile to a profile using the blockbuster as the barcode scanner. When you go back to the Browser application, since it is using the default profile, scanning will now be via the blockbuster not the camera as previously. To ensure that the Browser continues to use the camera as the barcode scanner a profile should be created and associated to the Browser that specifies the camera as the barcode scanner.\n\n### resetDefaultProfile\n#### Description\nThe resetDefaultProfile API function can be used to reset the default profile back to Profile0.\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<profile name>\");\n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_RESETDEFAULTPROFILE\"\n* EXTRA_DATA:\tString \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\"\n* `<profile name>`:\tThe profile name to set as the default profile as a string (case-sensitive).\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* `$ adb logcat -s DWAPI`\n* Error messages will be logged for invalid actions, parameters and failures (e.g. profile not found or associated to an application).\n\n#### Example\n\n\t:::java\n\t// define action string  \n\tString resetDefaultProfile = \"com.motorolasolutions.emdk.datawedge.api.ACTION_RESETDEFAULTPROFILE\";  \n\t  \n\tpublic void onResume() {       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(resetDefaultProfile);       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\n\n* None.\n\n### switchToProfile\n\n#### Description\nThe switchToProfile API action can be used to switch to the specified profile.\n\n#### Profiles Recap\nDataWedge is based on profiles and plug-ins. A profile contains information on how DataWedge should behave with different applications.\n\nProfile information consists of:\n\n* Associated application\n* Input plug-in configurations\n* Output plug-in configurations\n* Process plug-in configurations\n\n\nDataWedge includes a default profile, Profile0, that is created automatically the first time DataWedge runs.Using profiles, each application can have a specific DataWedge configuration. For example, each user application can have a profile which outputs scanned data in the required format when that application comes to the foreground. DataWedge can be configured to process the same set of captured data differently based on the requirements of each application.\n\n>Note: A single profile may be associated with one or many activities/apps, however, given an acitivty, only one profile may be associated to it.\n\n#### Usage Scenario\nLets say an application has two activities. ActivityA only requires EAN13 barcodes to be scanned. ActivityB only requires MSR card data. ProfileB is configured to only scan EAN13 barcodes and is left unassociated. ProfileM is configured to only accept MSR input and is left unassociated. When ActivityA launches it uses switchToProfile to activate ProfileB. Similarily, when ActivityB launches it uses switchToProfile to activate ProfileM.\n\nIf another activity/app comes to the foreground, DataWedge auto profile switching will set the DataWedge profile accordingly either to the default profile or to an associated profile.\n\nWhen ActivityA (or ActivityB) comes back to the foreground it will use switchToProfile to reset the profile back to ProfileB (or ProfileM).\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<profile name>\");  \n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_SWITCHTOPROFILE\"\n* EXTRA_DATA:\tString \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\"\n* `<profile name>`:\tThe profile name to switch to as a string (case-sensitive).\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* `$ adb logcat -s DWAPI`\n* Error messages will be logged for invalid actions, parameters and failures (e.g. profile not found or associated to an application).\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString switchToProfile = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SWITCHTOPROFILE\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\";  \n\t  \n\tpublic void onResume() {       \n\t    super.onResume();       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(switchToProfile);       \n\t    // add additional info       \n\t    i.putExtra(extraData, \"myProfile\");       \n\t    // send the intent to DataWedge       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\n* This API function will have no effect if the specified profile does not exist or if the specified profile is associated to an application.\n* DataWedge has a one-to-one relationship between profiles and activities, i.e. only one profile can be associated to any given activity. When a profile is initially created, it is not associated to any application. Until this profile is associated to an activity it will never be activated. In this way it is possible to create multiple profiles that are un-associated.\n* This API function allows you to switch to one such unassociated profile.\n\nFor example, let's say that ProfileA is one such un-associated profile and ProfileB is associated with activity B. Now, activity A is launched and uses this Data Capture API intent to switch to profileA. ProfileA will be active whilst activity A is in foreground. When another activity, say activity B, comes to the foreground DataWedge will automatically switch profile (to profileB which is associated to activity B for example). Then when activity A comes back to the foreground again, the app will need to use this Data Capture API intent to switch back to profileA. This would be done in the onResume method of activity A.\n \n> Note: Because DataWedge will automatically switch profile when your activity is paused, it is recommended that this API function be called from the onResume method of your activity.\n\n> Note: After switching to a profile, this un-associated profile does not get assigned to the application/activity and is available to be used in the future with a different app/activity.\n\n> Note: DataWedge automatic profile switching\n\nFor backward compatibility, DataWedge's automatic profile switching is not affected by the above API commands, and this also why the above API commands only work with unassociated profiles and apps.\n\nDataWedge auto profile switching works as follows:\n\n* Every second:\n\t1. Set newProfileId to the associated profile id of the current foreground activity\n\t2. If no associated profile found then set newProfileId to the associated profile id of the current foreground app\n\t3. If no associated profile found then set newProfileId to the current default profile (note: this may not be Profile0)\n\t4. Check the newProfileId against the currentProfileId\n\t5. If they are different then...\n\t\t* deactivate current profile\n\t\t* activate new profile (newProfileId)\n\t\t* set currentProfileId = newProfileId"},{"key":"guide-reference-refnativeandroid","name":" Using Native Android APIs","md":"# Using Native Android APIs\n\n## Overview\nSymbol offers Android products that are built on Android Open Source Platform (AOSP). Two variants are now being offered on the TC55 and planned for certain future products.\n\n### \"Standard Configuration\"\nThis version of the operating system incorporates Google Mobile Services. All standard Google API's are available to use in your application. Please consult [http://developer.android.com](http://developer.android.com) for details of using these APIs. Your application also has access to the [EMDK For Android APIs](#guide-reference-EMDKList) as well.\n\n### \"Professional Configuration\" \nThis version of the operating system does not incorporate Google Mobile Services. Standard Google APIs that doe not rely on the availability of GMS services will work on our devices. Please consult [http://developer.android.com](http://developer.android.com) for details of using these APIs. Your application also has access to the [EMDK For Android APIs](#guide-reference-EMDKList) as well.\n\n## About GMS\nGoogle offers a variety of applications and services collectively known as Google Mobile Services (GMS). There are also optional Android API extensions that allow applications to interface with said services. GMS is independent of Android and under a separate license from Google. GMS runs as an add-on above AOSP (Android Open Source Platform)\n\n### GMS Applications and Services\n\n* Google Maps\n* Google Play Services\n* Google Cloud Messaging\n* Google Analytics\n* Google+\n* Google Mail - Gmail\n* Google Cloud Platform\n* Google Wallet Instant Buy\n* Google Play In-App Billing\n* Google Mobile Ads\n* Google Drive\n* Google Cast\n\n### Challenges with GMS\nCareful considering should be made when deciding if your application requires the use of GMS.\n\n* Security \n\t* Google Mobile Services requires devices to be identified with a specific GoogleID. \n\t* Any enterprise data (Gmail, Maps, Cloud etc) will be pushed through Google's servers.\n\t* Gmail content is read by Google servers to improve relevance of advertisements.\n* Privacy\n\t* Google revamped their privacy policy in early 2012 allowing for richer user profiling across all services, for targeted advertising.\n\t* Usage acceptance allows Google to track a device's every move.\n\t* Google may collect IP Addresses, location, nearby Wi-Fi info, local storage and device setting details.  \n* Configuration\n\t* Extra manual steps may be required to be performed when the device boots up for the first time. \n\n### GMS Alternatives\nDepending on the feature your application requires, you my want to consider alternative choices before declaring that your application requires GMS. \n\n* Mapping\n\t* Consider cloud based mapping solutions like MapQuest or OpenStreetMap.\n\t* Consider alternative device resident solutions like ALK CoPilot, Sygic and Tele Atlas to name a few.\n* Push Messaging\n\t* Consider cross-platform solutions like RhoConnect.\n\t* Consider other cloud based messaging providers like Parse, Amazon SNS, Pushwoosh and others.\n* Play Store\n\t* Consider MDM solutions for application distribution.\n\t* Consider cross-platform solutions like RhoGallery.\n"},{"key":"guide-sample-emdksamples","name":"Using the EMDK Samples","md":"#Using the EMDK Samples\n\n##Overview\n\nThis guide will walk you through using the EMDK sample applications that are included with the EMDK for Android installation. Each version and updates of the EMDK For Android may come with a different set of sample applications. This guide generically describes how to make use of one of the samples. The general instructions apply to all samples. To learn more about each sample application, see their corresponding guide in the Samples menu.\n\n##Prerequisites\n- Java JDK \n- Eclipse with ADT plugin or  Android Studio\n- EMDK for Android  \n- An EMDK supported Android device\n\nFor more information about setting up the EMDK please see the [EMDK Overview](#guide-about).\n\n##Loading the Sample Application\nSample Applications are installed along with the EMDK and can be found in your start bar. Choose one of \nthe follow guides to setup the EMDK samples in your IDE.\n\n* [Eclipse with ADT Plugin](#guide-sample-emdksamples_eclipse)\n* [Android Studio](#guide-sample-emdksamples_androidstudio)\n\n##About the Sample Applications\nYou can inspect the code of the sample application to see what it is doing as well as consult the overview guide for each sample application.\n\n* [Datacapture](#guide-sample-sampledatacaptureprofile)\n* [App Manager](#guide-sample-sampleprofileapp)\n* [Clock](#guide-sample-sampleprofileclock)\n* [Power Manager](#guide-sample-sampleprofilepower)\n* [GPRS Manager](#guide-sample-sampleprofilegprs)\n* [Wi-Fi Manager](#guide-sample-sampleprofilewifi)\n* [Scanning/Barcode APIs](#guide-sample-samplebarcode)\n* [Wireless Manager](#guide-sample-samplewireless)\n* [Scan and Pair](#guide-sample-samplescanandpair)\n"},{"key":"guide-sample-emdksamples_androidstudio","name":"Using the EMDK Samples with Android Studio","md":"#Using the EMDK Samples with Android Studio\n\n##Loading the Sample Application\nSample Applications are installed along with the EMDK and can be found in your start bar. \n\n1. Select Start \n2. Select \"EMDK for Android v2.0\"\n3. Select \"Samples\"\n\n      ![img](images/sample/1.jpg)\n4. Your browser should open with a list of included samples\n\n      ![img](images/sample/2.jpg)\n5. Select \"ADTSamples\" from the web page   \n\n      ![img](images/sample/3.jpg)\n6. Copy the path to the directory on your computer    \n      ![img](images/sample/4.jpg)\n\n7. In the Android Studio Quick Start pane, select **Import project(Eclipse ADT,Gradle,etc.)**\n  ![img](images/sample/as_import_samples_1.png)\n\n8. Paste the path copied from step 6, into the import dialog, and click OK.\n  ![img](images/sample/as_import_samples_2.png)\n\n9. Accept the default options on the following six dialogs by clicking **Next**, then select **Finish** on the last dialog\n  ![img](images/sample/as_import_samples_9.png)\n\n10. When the projects are imported, the run configuration for each App is defaulted to run in the android emulator. Lets change that by clicking on the run configuration drop down and select **Edit Configurations**. \n  ![img](images/sample/as_import_samples_12.png)\n11. Select the configuration you want to edit in the left pane, select the **USB device** radio button under target device, and then click **OK**\n  ![img](images/sample/as_import_samples_13.png)\n\n\n  \n\n##Deploying a Sample Application\n\n1. Select the project you want to deploy from the run configuration drop down, then press the green play button.\n![img](images/sample/as_import_samples_11.png)\n\n \n Android studio will push the application to your device via USB and start the main activity.\n\n ![img](images/sample/BarcodeSample1_screen.png)\n\n"},{"key":"guide-sample-emdksamples_eclipse","name":"Using the EMDK Samples with Eclipse","md":"#Using the EMDK Samples with Eclipse\n\n##Loading the Sample Application\nSample Applications are installed along with the EMDK and can be found in your start bar. \n\n1. Select Start \n2. Select \"EMDK for Android v2.0\"\n3. Select \"Samples\"\n\n\t  ![img](images/sample/1.jpg)\n4. Your browser should open with a list of included samples\n\n\t  ![img](images/sample/2.jpg)\n5. Select \"ADTSamples\" from the web page   \n\n\t  ![img](images/sample/3.jpg)\n6. Copy the path to the directory on your computer   \n\t  ![img](images/sample/4.jpg)\n\n\n7. In Eclipse select From the tool bar \"File\" -> \"Import\"\n8.  Select Android \"Existing Android Code Into Workspace\"\n\n    ![img](images/sample/5.jpg)\n9. Browse to the samples directory from the web page and select a sample for example\"ProfileDataCaptureSample1\"\n\n    ![img](images/sample/6.jpg)\n10. Select Finish\n\n##Deploying a Sample Application\n\n1. Select the project.  \n2. Select \"File -> Properties\" or right click on the project and select \"Properties\".  \n    ![img](images/setup/image033.jpg)   \n    ![img](images/setup/image035.jpg)   \n3.    Click \"Android\" from the left pane.  \n    ![img](images/setup/image037.jpg) \n4. Select the \"EMDK\" target name from the list of Project Build Targets for the API version you require.  \n    ![img](images/setup/image039.jpg)  \n\n    >Note:  \n    >If an \"EMDK...\" target name is not on the list of Build Targets, please confirm you have installed Android API 16 SDK Platform.\n\n5. Click \"Apply\" and \"OK\".  \n6. Attach an EMDK supported Android device to your computer in USB debug mode. \n\n\t>NOTE: The device needs the EMDK runtime installed.\n7. From the Package Explorer right click on the select the sample application \n8. Right click on the project and select \"Run As\" -> \"Android Application\"\n\n\t![img](images/sample/7.jpg)\n9. Select your Android device and click \"Okay\". \n    \n    ![img](images/sample/8.jpg)\n\n\n"},{"key":"guide-sample-samplebarcode","name":"Barcode Manager Feature Sample","md":"#Barcode Manager Feature Sample\n\n##Overview\nThe EMDK for Android is used when you wish to handle all barcode scanning entirely in Java using [Barcode/Scanning APIs](#guide-reference-EMDKList) introduced in EMDK V3.0. These API's work independently of any [Data Capture profiles.](#guide-profiles-profilebarcode).  \n\nThe available actions in the [Barcode/Scanning API](#guide-reference-EMDKList) are:\n  \n* Set Scanner Device  \n* Set [TriggerType](#api-Scanner)\n* Set [Decoder Params](#api-ScannerConfig-DecoderParams)\n* Set [Reader Params](#api-ScannerConfig-ReaderParams)\n* Set [Scan Params](#api-ScannerConfig-ScanParams)\n* Scan barcodes based on selected features   \n\nThis sample application will allow you to scan barcodes based on selected scanner device, trigger type and few decoder [Decoder Params](#api-ScannerConfig-DecoderParams).\n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n1. When the application starts it should look like the following.\n  \n\t![img](images/samples/barcode_1.png)\n  \n2. Set scanner to \"Serial SSI Scanner\", which is the default one\". \n\n\t![img](images/samples/barcode_2.png)\n\n3. Set Trigger Type to \"HARD\".\n\n\t![img](images/samples/barcode_3.png)\n\n\t> Note: Trigger Type \"HARD\" lets you scan the barcode using device's hard scan key whereas \"SOFT\" allows you to scan without using devic's hard scan key.\n\n4. Keep all checkboxes checked for decoder params and this is how it should look after setting all fields.\n    \n\t![img](images/samples/barcode_4.png)  \t\n\n5. Click \"Start\" button and the status will be updated.\n\n\t![img](images/samples/barcode_5.png) \n \n6. Since we selected Trigger Type as \"HARD\", press the hard scan key of Symbol device and scan a particular barcode. It will get the scanned barcode data in \"Data\" field of UI.\n   \n\t![img](images/samples/barcode_6.png)  \n\t"},{"key":"guide-sample-samplebatteryintent","name":" Battery Intent Sample","md":"# Battery Intent Sample\n\n## Overview\nOn Symbol Android devices like the MC40, extra battery information can be retrieved using the standard [Android Battery Intent](http://developer.android.com/training/monitoring-device-state/battery-monitoring.html). Setting up to receive this information is the same as with consumer Android devices. However, the data that is returned to your application includes some extra information like:\n\n* Backup Battery Voltage\n* Battery Manufacture Date\n* Battery Serial Number\n* Part Number for Battery\n* Unique ID for Battery\n* Rated Capacity of the Battery\n* Charge Cycle count of the Battery\n \n## Using This Sample\nYou may choose to install the Battery Sample Application.apk or to run the project from Eclipse:\n\n1. Download the battery sample application zip. \n2. Unzip the battery sample application zip.\n3. Start the Android ADT or compatible eclipse environment. \n4. Import the sample application. \n\t>How to import:  \n \t>1. Go to \"File\" -> \"Import\"  \n \t>![img](images/FileImport.jpg)   \n \t>2. Select \"Android\" -> \"Existing Android Code Into Workspace\" -> \"Next\"   \n \t>![img](images/ImportNext.jpg)   \n \t>3. Select \"Browse\" and navigate to your unzipped battery sample application folder.  \n \t>![img](images/Browse.jpg)  \n \t>4. Select \"Finish\".  \n \t>![img](images/Finish.jpg)  \n\n5. Run the sample application. \n\t>How to run the sample application:   \n \t>1. Select the sample application folder in \"Package Explorer\".      \n \t>2. Right click and select \"Run As\" -> \"Android Application\"  \n \t>![img](images/RunAs.jpg)   \n\n6. The battery sample application should look like the following:  \n\n![img](images/BatterySampleApplication.jpg)  \n\n7. The information on the screen will update each time a battery intent is received. To force the intent you may change power state of the device by charging or unplugging it from a power source.\n\n\n## How This Sample Was Built \nA [Tutorial](#guide-tutorial-tutbatteryintent) walks through how this sample application was built. \n\n## Download\nThe project [source](https://s3.amazonaws.com/emdk/Tutorials/BatterySampleApplication.zip) and [application](https://s3.amazonaws.com/emdk/Tutorials/BatterySampleApplication.apk.zip) to this tutorial can be downloaded (Internet Connection Required).\n<a name=\"theend\"></a>\n"},{"key":"guide-sample-sampledatacaptureintent","name":" Data Capture Intent Sample","md":"# Data Capture Intent Sample\n\n## Overview\nThis sample demonstrates how to use the DataWedge Intent output plug-in and the [Data Capture Intent API](#guide-reference-refdatacaptureintent) to receive captured data in your native Android application. \n\nA [Tutorial](#guide-tutorial-tutdatacaptureintent) walks through how this sample application was built from scratch. If you would simply like to see the application run on your device, follow the instructions in the next section.\n\n## Using This Sample\n\n1. Download DataCaptureDemoSource.apk to your computer\n2. Copy the APK from your computer to a Android device like a MC40 (using USD file copy or ADB)\n3. From the device, launch the File Manager application and click on the APK file you just copied to install the DWDemoSample application.\n4. On the device, Launch DataWedge\n5. Create a new profile and give it a name such as \"dwdemosample\"\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/2.png)\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/4.png)\n6. Edit the profile\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/5.png)\n7. Go into Associated apps, tap the menu button, and add a new app/activity\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/7.png)\n8. For the application select com.motorolasolutions.emdk.sample.dwdemosample\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/8.png)\n9. For the activity select com.motorolasolutions.emdk.sample.dwdemosample.MainActivty\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/9.png)\n10. Go back and disable the keystroke output plug-in\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/11.png)\n11. Enable the intent output plug-in\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/12.png)\n12. For the intent action enter com.motorolasolutions.emdk.sample.dwdemosample.RECVR\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/18.png)\n13. For the intent category enter android.intent.category.DEFAULT\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/14.png)\n14. Launch the DataWedge Demo Sample application\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/17.png)\n15. Press the back button to clear the keyboard\n16. Press the scan trigger on the device and scan a printed barcode\n17. Notice that the output displays the barcode data preceded with additional info (source, symbology and length) that is handled by the handleDecodeData() Intent receiver method.\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/emdk/SampleDataIntent/20.png)\n\n## Download\nThe project [source](https://s3.amazonaws.com/emdk/Tutorials/DataCaptureDemoSource.zip) and [application](https://s3.amazonaws.com/emdk/Tutorials/DataCaptureDemoApp.apk.zip) to this tutorial can be downloaded (Internet Connection Required).\n\n<a name=\"theend\"></a>\n\n\n\n"},{"key":"guide-sample-sampledatacaptureprofile","name":"Data Capture Profile Feature Sample","md":"#Data Capture Profile Feature Sample\n\n##Overview\nOne of the features of the EMDK is the ability to create Barcode scanning profiles. This application allows you to modify a Barcode profile to select which times of Barcodes should be interpreted.  \n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n1) When the application first loads you will see:\n\n* Checkboxes for changing Barcode options\n* A text area where Barcode data will be displayed\n* A Status area where status will be shown\n\n![img](images/sample/9.png)\n\n2) Select which Barcode types you would like to enable.  \n3) click \"Set\".  \n4) San a Barcode of one of the selected Barcode types.  \n5) The data from the Barcode should populate on the screen.  \n  ![img](images/sample/new.png)\n\n## Application Startup\nUsing the Profile Manager Wizard, a profile called 'DataCaptureprofile-1' was created. You can inspect the parameters it has by launching the EMDK Profile Manager from Eclipse.\n\n![img](images/sample/10.jpg)\n\nYou will see that the MainActivity for the application has been selected to indicate when this profile will be used. As you can see in EMDK for Android V 2.1, the existing features of V 2.0 are categorized based on their operations such as Activity Selection, Data Input (Barcode, MSR) and Data Delivery (Intent, Keystroke and IP). Moreover it has introduced several new MX (Mobility Extension) features (Ex. Clock, App Manager, Power Manager etc). These MX features are used for configuring Symbol Android devices.\n\n   > Note: The field \"Name\" contains user defined name to identify a particular feature. This is required when editing any specific feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n\n![img](images/sample/11.jpg)\n\n   > Note: The field \"Name\" contains user defined name to identify a particular Barcode Scanner Input feature. This is required when editing any specific Barcode Scanner Input feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n\nThe profile feature parameters that have been chosen can be inspected to see that certain barcode decoders have been enabled and the output will be using the Keystroke feature. This profile has MSR and Intent output disabled.\n\n![img](images/sample/12.jpg)\n\n![img](images/sample/13.jpg)\n\n![img](images/sample/14.jpg)\n\nWhen the application starts up, the onOpened method is executed and the profile is processed.\n\n![img](images/sample/15.jpg)\n\n![img](images/sample/16.jpg)\n\nIt if was successful, you will see \"Profile initialization Success\" on the application's status area.\n\n![img](images/sample/17.png)\n\n## Scanning a Barcode\nAfter the application has been loaded, you can begin scanning barcodes. Notice that only Code128, EAN8, UPCA types have been chosen. When you press the scan trigger on the device, you should see the default scanner become activated and a barcode is attempted to be read. If the barcode you have chosen is not one of the ones listed above, it will not decode and display in the text area. \n\n>NOTE: Most everyday items you may have in your home use the UPCA type barcode. You may also Google these types of barcode to see what they look like and print one out for testing\n\nUpon successful Barcode scanning, the barcode data will be output into the text field.\n\n![img](images/sample/18.png)\n\n## Changing Barcode Settings\nWhen you uncheck the checkboxes in the application, the DataCaptureProfile-1 is modified on the fly using the ProfileConfig API. \n\n* Uncheck the barcode type you just scanned in \n* tap 'Set' and you should see 'Profile update success' in the status area\n\n![img](images/sample/19.png)\n\nNow when you scan the same Barcode, you will still see the barcode aimer but the data will not be decoded and you will not see the data displayed in the text area.\n\n## Next Steps\nNow that you have played with a pre-built sample application, it is time to try and build your own application from scratch. Follow the steps in the [DataCapture Profile Manager Tutorial](#guide-tutorial-tutdatacaptureprofile).\n\n"},{"key":"guide-sample-sampleprofileapp","name":"App Manager Profile Feature Sample","md":"#App Manager Profile Feature Sample\n\n##Overview\n\nThe EMDK for Android allows you to manage applications on the device. \n\nThe available actions are:  \n- Install an application\n- Uninstall an application\n- Upgrade an application  \n- Set an application as the default launcher \n\nThis sample application will allow you to install, upgrade, and uninstall an application. \n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n1. When the application starts it should look like the following.  \n\t![img](images/samples/2_1.png)  \n2. Enter the path to an APK file that you have placed on your device.  /sdcard/Battery Sample Application.apk\n\t![img](images/samples/2_2.png)  \t\n\t>Note:  \n\t>To place an APK file on the device connect the device to to you computer over USB as a \"Medea Device\" and copy an APK to your device.  \n3.  Click \"Set\" \n4.  Check the status field.   \n\t![img](images/samples/2_3.png)  \n\t\n"},{"key":"guide-sample-sampleprofileclock","name":"Clock Profile Feature Sample#","md":"#Clock Profile Feature Sample#\n\n##Overview##\nOne of the features of the EMDK for Android is the ability to set the system clock. This sample application will show you how you can create a custom application for setting the system time. \n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n1. When the application starts it should look like the following.  \n\t![img](images/samples/3_1.png)  \n2. Enter the time you would like to set.  \n\t![img](images/samples/3_2.png)  \t\n3.  Click \"Set\" \n4.  Check the status field.   \n\t![img](images/samples/3_3.png)  \n\t\n"},{"key":"guide-sample-sampleprofilegprs","name":"GPRS Manager Profile Feature Sample","md":"#GPRS Manager Profile Feature Sample\n\n##Overview\nThe EMDK for Android allows you to allows you to add or remove APNs to a Symbol device. \n\nThe available actions are:\n  \n* Add/Replace named APN  \n* Remove existing named APN  \n* Remove all existing APNs  \n\nThis sample application will allow you to Add/Replace named APN and remove existing named APN.\n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n1. When the application starts it should look like the following.\n  \n\t![img](images/samples/gprs_1.png)\n  \n2. Select Add/Remove named APN\n  \n\t![img](images/samples/gprs_2.png)  \t\n\n3. Provide APN Name (Ex. \"Test_APN\") and check the checkbox \"Replace if exist\".\n\n\t![img](images/samples/gprs_3.png)\n\n4. Provide the applicable APN details such as:\n\n\tAccess Point: wap.cingular\n\n\tUse Name: WAP@CINGULARGPR.COM\n\n\tPassword: CINGULAR1\n\n\t![img](images/samples/gprs_4.png)\n  \n5. Click \"Apply\" button.\n\n6. Check the status field.   \n\t![img](images/samples/gprs_5.png)  \n\t"},{"key":"guide-sample-sampleprofilepower","name":"Power Manager Profile Feature Sample","md":"#Power Manager Profile Feature Sample\n\n##Overview\nThe EMDK for Android allows you to control the power state of a Symbol device. \n\nThe available actions are:  \n- Do Nothing  \n- Sleep Mode  \n- Reboot  \n- OS Update  \n\nThis sample application will allow you to set the power state of \"Suspend\" (sleep mode) or \"Reset\" (reboot).\n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n1. When the application starts it should look like the following.  \n\t![img](images/samples/1_1.png)  \n2. Select the power mode you would like to set.  \n\t![img](images/samples/1_2.png)  \t\n3.  Click \"Set\" \n4.  Check the status field.   \n\t![img](images/samples/1_3.png)  \n\t"},{"key":"guide-sample-sampleprofilewifi","name":"Wi-Fi Manager Profile Feature Sample","md":"#Wi-Fi Manager Profile Feature Sample\n\n##Overview\nThe EMDK for Android allows you to configure Wi-Fi of a Symbol device. \n\nThe available actions are:\n  \n* Disable Wi-Fi  \n* Enable Wi-Fi  \n* Add a Network  \n* Connect to a Network\n* Enable a Network\n* Disconnect from a Network\n* Disable a Network\n* Remove a Network\n\n> Note: In order to perform all Wi-Fi network operations, Wi-Fi should be enabled.  \n\nThis sample application will allow you to perform all the above mentioned Wi-Fi actions on Symbol device.\n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n\n1. When the application starts it should look like the following.\n  \n\t![img](images/samples/wifi_1.png)\n  \n2. Select the Wi-Fi operation you want (Enable/Disable).\n   \n\t![img](images/samples/wifi_2.png)  \t\n\n3. Select the Network action you want to execute from the Network Action drop-down. \n\tLet us select \"Add(Default Open Network)\" option.\n\n\t![img](images/samples/wifi_3.png)\n\n\t> Note: You could also add Personal Network with Passphrase and Enterprise Network with required certificate, which is not in the scope of this sample. \n4. Provide some SSID to the network you want to add in SSID field (Ex. Test_Network).\n\n\t![img](images/samples/wifi_4.png)\n\n5. Click \"Apply\" button.\n\n6. Check the status field.\n   \n\t![img](images/samples/wifi_5.png)  \n\t"},{"key":"guide-sample-samplescanandpair","name":"Scan and Pair API Sample#","md":"#Scan and Pair API Sample#\n\n##Overview##\nThis sample application will show how the Scan and Pair API can be used to pair two bluetooth devices programmatically.\n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\nFor this sample, you will need two Android Bluetooth devices, one must be an EMDK for Android supported device. You will also need a barcode that contains the Bluetooth MAC address of the remote bluetooth device that we will be pairing with(The one not running the EMDK app).\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n\n1.  When the application starts it should look like the following. Leave the **Always Scan** and **Hard Trigger** check boxes selected, and insure the **ScanData Type** spinner is set to **MAC ADDRESS**.  \n\n\t![img](images/samples/scanandpair1.png)  \n\n2. Press the **Pair** button. The Status label will update, stating that the Scan and Pair process has started, and then prompt the user to press the hard scan trigger.\n\n\t![img](images/samples/scanandpair3.png)  \t\n\n3. Now place the Pairing Barcode in view of the devices scan window, and then press the devices Hard Scan Trigger. The Scan and Pair sample app will retrieve MAC address from the barcode and place it in the **Bluetooth Address** field, then it will initiate the pairing and connection process. Press **Pair** in the Pairing Request dialog, to complete the pairing process. \nAfter pairing is complete, the status label will display \"Bluetooth device is paired successfully\".\n\n\t![img](images/samples/scanandpair4.png) "},{"key":"guide-sample-samplesimulscan","name":"SimulScan API Sample#","md":"#SimulScan API Sample#\n\n##Overview##\nThis sample application will show how the Simulscan API's can be used to capture multiple types of data from forms, boxes and the like.\n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\nYou will also need:\n\n* A SimulScan licensed device\n* A Simulscan template\n* A printed copy of the form used to create the template\n\nFollow the template generation and device licensing sections of the [SimulScan API tutorial](#guide-tutorial-tutSimulScanAPI)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n\n1. Place a template on the sdcard of you SimulScan licensed device.\n\n\t\t:::\n\t\tadb push myTemplate.xml /sdcard/simulscan/templates/\n\t\n\n2. Launch The SimulScan sample application\n\t\n\tThe Simulscan sample app will find the templates you place on the devices sdcard, and populate the \"Set Template\" option list.  Select the template you wish to use from that list.\n\t![img](images/samples/simulscanSample1.png) \n\n\n3. Press the \"Read\" button, and follow the on screen instructions. The sample app will extract the fields defined in the template. If the \"Display Results View\" option is checked, a list of results will be displayed for you to review.\n\n\t![img](images/samples/simulscanSample2.png)  ![img](images/samples/simulscanSample3.png)   \n\n\n4. Press the \"Accept\" button. The sample app will then display a screen showing how long simulscan took to capture and decode the template fields. Press the devices \"Back\" hardware button to return to the main screen.\n\n\t![img](images/samples/simulscanSample4.png) \n\n\n"},{"key":"guide-sample-samplewireless","name":"Wireless Manager Profile Feature Sample#","md":"#Wireless Manager Profile Feature Sample#\n\n##Overview##\nThis sample application will show you how to enable or disable the bluetooth radio on a device\n\n##Prerequisites\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Loading the Sample Application\n[See Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Deploying The Sample Application\n[Using the EMDK Samples](#guide-sample-emdksamples)\n\n##Using This Sample\n1. When the application starts it should look like the following.  \n\t![img](images/samples/wireless1.png)  \n2. Select Enable or Disable, then click **Set**\n\t\n\tThe Status field will update after submitting the profile.\n\t![img](images/samples/wireless2.png)  \t\n\n"},{"key":"guide-setup","name":" EMDK For Android Setup","md":"# EMDK For Android Setup\n\n## Overview\n\nThe EMDK for Android provides the interface to Symbol value adds such as scanning and magstripe for developing Enterprise applications on Symbol Android devices.\nThis document is a guide to start working the \"EMDK for Android\" in your preferred development environment. \n\n##Configuring Development Environment\nIn order to develop Android applications with Android Studio or Eclipse, you must first install the Java Development Kit.\n\n### Installing Java Development Kit (JDK) for Windows\n\n1.\tGo to [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).\n2.\tDownload and install JDK v7u45 or newer. \n\n### Installing Java Development Kit (JDK) for Mac\n\nInstalling Java for OS X 2014-00x:\n\n1. Go to https://support.apple.com/kb/dl1572?locale=en_US.\n\t![img](images/setup/mac/image1.png)\n\n2. Download and install Java for OS X 2014 (ex: JavaForOSX2014-001.dmg).\n\nInstalling Java Development Kit (JDK) 7\n\n1. Go to http://www.oracle.com/technetwork/java/javase/downloads/index.html.\n\n2. Download and install JDK 7 (v7u75  the JRE alone is not sufficient) or newer for Mac OS X x64 (ex: jdk-7u75-macosx-x64.dmg).  \n\n##Choosing a Development Environment\n###Android Studio\nAndroid studio is now Google's official IDE for Android development. Using Android Studio will give you access to the latest IDE updates. \n\n**Windows** - Follow this [**guide**](#guide-setupAndroidStudio) to setup the EMDK for Android in Android Studio.\n\n**Mac** - Follow this [**guide**](#guide-setupAndroidStudioMac) to manually setup the EMDK for Android in Android Studio.\n\n\n\n###Eclipse-ADT bundle\nSince the 1.0 release of Android Studio, Google no longer offers the Eclipse based ADT bundle. However, the Eclipse IDE can be downloaded separately and the ADT can be installed as a plugin. The EMDK installer still supports the use of Eclipse to develop \"EMDK for Android\" applications. \n\n**Windows** - Follow this [**guide**](#guide-setupEclipse) to setup \"EMDK for Android\" in Eclipse.\n\n**Mac** - EMDK for android development in Eclipse on Mac, is not supported.\n\n"},{"key":"guide-setupAndroidStudio","name":"EMDK For Android Setup (Android Studio1.0.x)","md":"#EMDK For Android Setup (Android Studio1.0.x)\n\n##Installing EMDK for Android Studio\n\n###Installing Android Studio\n1. Go to [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)\n2. Download `Android Studio 1.x`\n\n> NOTE: Android Studio should be installed on your computer before running the EMDK for Andriod installer. \n\n### Installing EMDK for Android\n\n\n1. Run the EMDK 3.1 Installer as Administrator, Then Click Next.\n\n\t![img](images/setup/emdkInstall01.png)\n\n2. Click I Agree after reading the License Agreement to continue the installation.\n\n\t![img](images/setup/emdkInstall02.png)\n\n3. Click next or select a custom install location by clicking Browse and then click next.\n\n\t![img](images/setup/emdkInstall03.png)\n \n4. Continue installing EMDK for Android in Android studio by selecting the `Use Android Studio` radio button ( As Shown ) and select Next.\n\n\t![img](images/setup/emdkInstall04.png)\n\n\n##EMDK for Android development with Android Studio\n\nIn order to enable EMDK development in your project, you must first add the EMDK library. The EMDK for Android library can be added to your project via one of the following three methods.\n\n###Specify the EMDK SDK add-on as the Minimum SDK in the New Android Studio Project wizard\n\n1. Launch Android Studio\n\n2. Select \"Start a new Android Studio project\" or File \\> New Project.\n\n3. Enter \"Application name\" and \"Company Domain\" and Click Next\n\n4. Select EMDK SDK add-on (ex: \"Symbol Technologies, Inc.: EMDK API (16)\") as the \"Minimum SDK\" under Phone and Tablet.\n\n\t![img](images/setup/as_image8.png)\n\n5. Complete the New project Wizard by Clicking Next \\> Next \\> Finish\n\t>Android Studio will display your project when Gradle build process is complete.\n\nTo verify that the EMDK has been added to your project.\n \n1. Go to File \\> Project Structure.\n\n2. Click on app under Modules in the Project Structure Window's left-pane.\n\n3. Check the value of \"Compile Sdk Version\". It should be the selected EMDK SDK add-on (see below)\n\n> Symbol Technologies, Inc.:EMDK 3.0 (API 16):16\n\n> Symbol Technologies, Inc.:EMDK 3.0 (API 19):19\n> \n>![img](images/setup/as_image12.png)\n\n\nAnother method to verifiy EMDK project integration is via the build.gradle file.\n\nOpen build.gradle (Module: app) from the left-pane. The compileSdkVersion should be assigned to EMDK SDK add-on.\n\n![img](images/setup/as_image14.png)\n\n**Your project is now ready for EMDK development (see EMDK Help for more information on creating an EMDK app).**\n\n\n\n###Import EMDK lib JAR as a Module\nStarting with a previously created Project with a minimum API level of 16 or 19\n\n1. Go to File \\> Project Structure\n\n2. Press the button marked with \"+\" at the top-left to add a new module.\n\n3. Select \"Phone and Tablet Application\".\n\n4. Select \"Import JAR or AAR Package\" from the list More Modules then Click Next\n\n5. Click Browse button and locate the EMDK jar file (com.symbol.emdk.jar) from the SDK add-on folder and click OK\n\t\n\t![img](images/setup/as_image25.png)\n\n\t>The new module will eventualy appear in the left-pane of the project structure window.\n\n6. Click on app in left-pane and select the dependencies tab\n\n\t![img](images/setup/as_image28.png)\n\n7. Press the button marked with the \"+\" at top-right to add select \"Module Dependency\".\n\n\t![img](images/setup/as_image29.png)\n\n8. Select \"com.symbol.emdk\" from the \"Choose modules\" dialog then Press OK.\n\n9. The new dependency should be listed, now Press OK\n\n\t![img](images/setup/as_image31.png)\n\n**Your project is now ready for EMDK development (see EMDK Help for more information on creating an EMDK app).**\n\n\n###Add EMDK SDK add-on name as the Compile Sdk Version in Project Structure\nStarting with a previously created Project with a minimum API level of 16 or 19.\n\n1. Go to File \\> Project Structure\n\n2. Select app in the left-pane and Properties tab.\n\n3. Manually enter one of the following add-on names in the \"Compile Sdk Version\" depending on the API version (see below):\n\n\t>SDK add-on (API 16) name: **Symbol Technologies, Inc.:EMDK 3.0 (API 16):16**\n\n\t>SDK add-on (API-19) name: **Symbol Technologies, Inc.:EMDK 3.0 (API 19):19**\n\n\t![img](images/setup/as_image35.png)\n\n4. Click OK then Select Yes in the resulting dialog.\n\n\t![img](images/setup/as_image36.png)\n\n**Your project is now ready for EMDK development (see EMDK Help for more information on creating an EMDK app).**\n\n\n##Importing EMDK Samples into Android Studio\n\nStarting at the Android Studio Welcome Screen,\nSelect \"Import Non-Android Studio project\"\n\n1. Locate the EMDK Samples path.\n>For example:  \"C:\\\\Users\\\\Public\\\\Symbol EMDK for Android\\\\v3.0\\\\Samples\\\\ADT\".\n\n2. Select the preferred sample, and press OK.\n\n\t![img](images/setup/as_image38.png)\n\n3. Click Next and then Finish to complete the import wizard.\n\n\t> When Android Studio has completed the Gradle build, your sample project will be displayed.\n\n4. From the Build menu, select Rebuild Project.\n\n\t![img](images/setup/as_image47.png)\n\n5. Connect a Symbol Android device via USB, and select Run from the Run menu.\n\t\n\t![img](images/setup/as_image48.png)\n\t"},{"key":"guide-setupAndroidStudioMac","name":"EMDK For Android Setup on Mac","md":"#EMDK For Android Setup on Mac\n\n##Installing Android Studio 1.1.x\n\n1. Go to http://developer.android.com/sdk/index.html.\n\n\t\n\t![img](images/setup/mac/image3.png)\n\n2. Click on the \"Download Android Studio for Mac\" button.\n3. Accept the License Agreement and click the \"Download Android Studio for Mac\" button.\n4. Launch the .dmg file you just downloaded (ex: android-studio-ide-135.1740770-mac.dmg).\n5. Drag and drop Android Studio into the Applications folder.\nOpen Android Studio and follow the setup wizard to install any necessary SDK tools.\n\nDepending on your security settings, when you attempt to open Android Studio, you might see a warning that says the package is damaged and should be moved to the trash.\n\nIf that error occurs:\n\n1. Go to System Preferences / Security &amp; Privacy\n2. Click the padlock icon in the bottom left corner, and login to allow changes in this screen.\n3. Under Allow applications downloaded from, select Anywhere\n4. Then open Android Studio again.\n\nIf you need to use the Android SDK tools from a command line, you can access them at:\n`/Users/<user>/Library/Android/sdk/`\n\n\n##Configuring Android Studio for EMDK development\n\nIn order to develop EMDK apps on Android Studio, API's 16 and 19 Android platforms and Android SDK Build-tools revision 21.1.x or newer must be downloaded and installed.\n\n###How to determine which API platforms are installed in Android Studio\n\n1. Launch Android Studio from Start Programs\n2. Go to Tools / Android / SDK Manager\n3. Check that the status of Android 4.1.2 (API 16) and Android 4.4.2 (API 19) SDK Platforms is \"Installed\". \n4. If either SDK platform is not installed check the SDK check mark, click Install Packages, and follow the on screen instructions. When the install is complete, restart Android Studio. \n\n\t![img](images/setup/mac/image4.png)\n\n\n###How to determine which Build-tools is installed in Android Studio\n\n1. Launch Android Studio from Start Programs\n2. Go to Tools / Android / SDK Manager\n3. Check the status of Android SDK Build-tools 21.1.x or newer is \"Installed\".\n4. If Android SDK Build-tools 21.1.x or newer is not installed check the SDK check mark, click Install Packages, and follow the on screen instructions. When the install is complete, restart Android Studio.\n\n\t![img](images/setup/mac/image5.png)\t\n\n##Setting up Android Studio for EMDK development\n\n###Prerequisites\n\n- Android Studio 1.1.x or newer\n\t- Android API 16, API 19 platforms\n\t- Android SDK Build-tools 21.1.x or newer \n\nThe following items can be found in [EMDK for Mac installation zip file](https://s3.amazonaws.com/emdk/EMDK_3.1_MAC.zip):\n\n- Latest EMDK add-ons\n\t - \\EMDK_3.1_04202015_MAC\\SDK\\addon-symbol-emdk_v3.1_API-16\n\t - \\EMDK_3.1_04202015_MAC\\SDK\\aaddon-symbol-emdk_v3.1_API-19\n- Latest EMDK Wizard core components\n\t- \\EMDK_3.1_04202015_MAC\\Symbol EMDK for Android\n- Latest EMDK Wizard plug-in for Android Studio\n\t- \\EMDK_3.1_04202015_MAC\\Android Studio\\com.symbol.emdk.wizard.intellijIdea_3.1.18\n- Latest EMDK device runtime\n\t- \\EMDK_3.1_04202015_MAC\\Device Runtime\\EmdkOSUpdateApp_v3.1.24.apk\n\n###EMDK SDK add-on Integration\nTo add the EMDK 3.1 APIs to the Android SDK please refer the following instructions:\n\n1. Navigate to the /Users/**username**/Library/Android/sdk/add-ons directory. \n\n\t![img](images/setup/mac/image6.png)\n\n2. Copy the addon-symbol-emdk_v3.1_API-16 and addon-symbol-emdk_v3.1_API-19 folders into the add-ons directory.\n\n\t![img](images/setup/mac/image7.png)\n\n3. Exit & Launch Android Studio\n4. Go to Tools > Android > SDK Manager\n\nNow the integrated EMDK add-ons should appear in the SDK Manager\n\t![img](images/setup/mac/image8.png)\n\n###EMDK Wizard plug-in Integration\n\nConfiguring Mac OS X with EMDK Wizard core components\n\n1. Locate the /Users/Shared folder.\n\n\t![img](images/setup/mac/image10.png)\n\n2. Copy Symbol EMDK for Android folder into the /Users/Shared folder.\n\n\t![img](images/setup/mac/image11.png)\n\nEMDK Wizard plug-in integration into Android Studio\n\n1. Launch Finder and go to Applications (on the left side panel) \n\n\t![img](images/setup/mac/image12.png)\n\n2. Locate Android Studio.app, right click and select Show Package Contents.\n\n\t![img](images/setup/mac/image13.png)\n\n3. Locate the Contents\\plugins directory.\n\n\t![img](images/setup/mac/image14.png)\n\n5. Copy the com.symbol.emdk.wizard.intellijIdea_3.1.xx folder into the plugins directory.\n\n\t![img](images/setup/mac/image15.png)\n\n6. Exit & Launch Android Studio.\n\nNow the EMDK menu should appear in the Android Studio menu bar:\n\n![img](images/setup/mac/image16.png)\n\n\n##Resolving JDK version conflict \n\nThis section will provide the required steps to modify the Info.plist of the Android Studio.app, in order to enable the support for plug-ins built using **JDK 7**.\n\nAndroid Studio 1.1.0 is configured with **JDK 6**. Once the EMDK Wizard plug-in has been installed on Android Studio, if there is a JDK version conflict the following symptoms can be observed. \n\nNotification stating an internal IDE error.\n\n![img](images/setup/mac/image18.png)\n\nEmpty EMDK Wizard menu\n\n![img](images/setup/mac/image19.png)\n\n\n\nIf these symptoms are observed check the JRE version used by the Android studio. Please refer the following steps:\n\n1. Click on Android Studio > About Android Studio\n\n\t![img](images/setup/mac/image20.png)\n\n2. Check the JRE version\n\n\t![img](images/setup/mac/image21.png)\n\n\n\nIf the JRE version is 1.6.x the EMDK Wizard plug-in for Android studio will fail. Hence, to solve this issue the info.plist of the Android Studio app will have to be configured. The configuration change will set the JRE version used by Android Studio as 1.7.x. Please refer the following steps:\n\n1. Launch Finder > click on Applications on the left side pane > locate the Android Studio.app\n\n\t![img](images/setup/mac/image22.png)\n \n\n2. Right click on the Android Studio.app > select Show Package Contents\n\n\t![img](images/setup/mac/image23.png)\n\n3. Expand the Contents directory > create a backup copy of the Info.plist > open the Info.plist using a text editor\n\n\t![img](images/setup/mac/image24.png)\n\n\t![img](images/setup/mac/image25.png)\n\n\n4. Search and locate the <key>JVMVersion</key> entry > change the 1.6* to 1.6+ > Save the file and exit the editor.\n\n\t![img](images/setup/mac/image26.png)\n\n\n5. Exit and launch the Android Studio IDE and check the EMDK Wizard menu item, it should be visible now.\n\n\t![img](images/setup/mac/image27.png)\n\n6. Additionally check the JRE version of the Android Studio; it should now be 1.7.x.\n\n\t![img](images/setup/mac/image28.png)\n\n\n\n##Configuring ADB connectivity with Symbol Android devices on Mac OSX\nThe ADB connectivity on Mac OS X for Symbol Android devices will not be successful by default. Therefore the Symbol Vendor ID needs to be specified under third party USB Vendor ID list to get the device connected on Mac OS X.\n\n>NOTE: The Google Mobile Service (GMS) devices (ex: TC 55 GMS) will be connected without any change to the USB Vendor ID list.\n\nTo add the Symbol Vendor ID to ADB:\n\n1. Enter the following command using a terminal: `echo 0x05e0 >> ~/.android/adb_usb.ini`\n2. Next, navigate to the ADB directory: `cd /Users/<user>/Library/Android/sdk/platform-tools/` \n3. Stop the the adb service if it is running: `./adb kill-server`\n3. Connect a Symbol Android device and enter the following command verify the list of attached devices: \n\t`./adb devices`"},{"key":"guide-setupDevice","name":" Configuring A Device","md":"# Configuring A Device\n\n>NOTE: Devices will need to be updated with the EMDK for Android Device Runtime v3.1.18\n\n##\tInstalling EMDK for Android Device Runtime using Deployment utility\n\n###Windows\n1.\tConnect the device to PC.\n2.\tLaunch the Start menu program shortcut `Device Runtime Deployment`. This will open the command prompt window.\n3.\tClick any key to continue.\n4.\tThis process will deploy the device runtime and reboot automatically to finish the OS update.\n\n###MAC\n1. Open finder and copy EmdkOSUpdateApp_v3.1.xx.apk into the ADB directory.\n\n\t`/Users/<user>/Library/Android/sdk/platform-tools/`\n\n2. Open terminal and navigate to the ADB directory.\n\n\t`cd /Users/<user>/Library/Android/sdk/platform-tools/` \n\n3. Connect a Symbol Android device and enter the following commands to restart the ADB and verify the list of attached devices.\n\t\n\t`./adb kill-server`\n\n\t`./adb devices`\n\n4. Install EMDK OS Update App.\n\n\t`./adb install EmdkOSUpdateApp_v3.1.xx.apk`\n\n5. Run EMDK OS Update App.\n\n\t`./adb shell am start -n com.symbol.emdkosupdater/.MainActivity`\n\n\nThe device will be reboot after the device update completes.\n\n\n\n\n## Installing the EMDK device runtime when the AppLock Manager is On:\n\n* Option 1: Turn Off the AppLock Manager before EMDK device runtime deployment and the AppLock Manager can be turned On after device reboot.\n* Option 2: The customer can add the EMDK OS update app name to the AppLock Manager Applications white list before the EMDK device runtime deployment.\n\n## Installing the EMDK device runtime on Google Mobile Service (GMS) devices:\nBefore installing EMDK device runtime on GMS devices, you must enable the enterprise-grade features like Mobility Extensions (MX). To download enterprise enabler for your device, go to [https://portal.motorolasolutions.com/Support/US-EN](https://portal.motorolasolutions.com/Support/US-EN) and search for \"Enterprise Enabler\" along with the device name.\n\n## Modify Device Runtime Installation Behavior\nThe EMDK device runtime update application will skip the EMDK runtime install if a device has an EMDK runtime version higher than the install version. The EMDK device runtime installation behavior can be modified by pushing an EMDK install mode configuration (emdkosupdateconfig.xml) to the \"/enterprise/usr/\" folder on a devices internal storage. This overrides the default settings of the application. This XML will be removed automatically once the update is successful.\n\n>NOTE: **This process is not required to use the default installation behavior.**\n\n**Example emdkosupdateconfig.xml**\n\n\t\t:::xml\n\t\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t\t<wap-provisioningdoc>\n\t\t        <parm name=\"InstallMode\" value=\"skip\"/>          \n\t\t    </characteristic>\n\t\t</wap-provisioningdoc>\n\n\n**InstallMode Parm Value Options:**\n\n* **auto** - Displays alert box during installation and waits for the user input\n* **overwrite** - Overwrite and continue installation\n* **skip** - Skip and continue installation. This is the default\n* **cancel** - Exit the installation\n\n\n**EMDK Device Runtime Installation Steps**\n\n1. Create emdkosupdateconfig.xml and push into /enterprise/usr/ to modify the default behavior.\n2. Push the EmdkOSUpdateApp_[version].apk to a supported Symbol device.\n3. Install EmdkOSUpdateApp application.\n4. Launch installed EmdkOSUpdateApp application.\n\n>NOTE: If the update succeeds, the EmdkOSUpdateApp will be un-installed and device will be rebooted. If the update fails, the EmdkOSUpdateApp application will not be un-installed. The update results will be available at  `/enterprise/usr/emdkosupdateresults.xml`\n"},{"key":"guide-setupEclipse","name":" EMDK For Android Setup (Eclipse)","md":"# EMDK For Android Setup (Eclipse)\n\n## Install EMDK for Eclipse\n\n### Installing Eclipse \n1.\tGo to [http://eclipse.org/downloads/](http://eclipse.org/downloads/).\n2.\tDownload `Eclipse IDE for Java Developers` 3.7.2 (Indigo) or greater.\n3.\tMake a note of the name and location where you save the Eclipse on your system-you will need to refer to the standalone Eclipse directory later when installing EMDK for Android. \n\n> NOTE: Eclipse 3.6 (Helios) is no longer supported with the latest version of ADT.\n\n### Installing ADT Plugin to Eclipse\n>NOTE: Since Google has released Android Studio, the ADT **Bundle** is no longer available for download. You will need to install Eclipse with the ADT **Plug-In** instead.\n\n1.\tStart Eclipse, then select `Help : Install New Software`.\n2.\tClick `Add`, in the top-right corner.\n3.\tIn the Add Repository dialog that appears, enter `ADT Plugin` for the Name and the following URL for the Location: `https://dl-ssl.google.com/android/eclipse/`\n\t\n\t> NOTE: The Android Developer Tools update site requires a secure connection. Make sure the update site URL you enter starts with HTTPS.\n4.\tClick `OK`.\n5.\tIn the Available Software dialog, select the check box next to Developer Tools and click Next.\n6.\tIn the next window, you'll see a list of the tools to be downloaded. `Click Next`.\n7.\tRead and accept the license agreements, then click `Finish`.\n\t\n\t> NOTE: If you get a security warning saying that the authenticity or validity of the software can't be established, click OK.\n8.\tWhen the installation completes, restart Eclipse.\n\n>NOTE: EMDK for Android requires ADT v22.3.0-887826 or higher version.\n\n### Installing Android SDK \n1.\tGo to [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).\n2.\tClick on the hyperlink [Other Download Options](http://developer.android.com/sdk/index.html#Other) or scroll down towards the section `Other Download Options`.\n3.\tLook for the table under sub section `SDK Tools Only`.\n4.\tClick on the Package [installer_r24-windows.exe](http://dl.google.com/android/installer_r24-windows.exe) under Platform `Windows`.\n5.\tAccept the License Agreement.\n6.\tClick on the button `Download installer_r24-windows.exe`.\n7.\tDouble-click the downloaded executable to start the installation.\n8.\tMake a note of the name and location where you save the Android SDK on your system, as you will need to refer to the standalone Android SDK directory later when installing EMDK for Android. \n\n\n### Configuring the Android Developer Tools (ADT) for EMDK\nThe EMDK requires Android API's 16 and 19 to be Installed.\n\nTo check which API's you have installed:\n\n1. In Eclipse go to `Window` then `Android SDK Manager`\n2. Check that the status of `Android 1.1.2 (API 16)` and `Android  4.4.2 (API 19)` SDK Platforms status is `Installed`. \n3. If either SDK platform is not installed check the SDK check mark, click `Install Packages`, and follow the on screen instructions. When the install is complete restart Eclipse. \n\n\n### Installing EMDK for Android\n\n1. Run the EMDK 3.1 Installer as Administrator, Then Click Next.\n\n\t![img](images/setup/emdkInstall01.png)\n\n2. Click I Agree after reading the License Agreement to continue the installation.\n\n\t![img](images/setup/emdkInstall02.png)\n\n3. Click next or select a custom install location by clicking Browse and then click next.\n\n\t![img](images/setup/emdkInstall03.png)\n \n4. Continue installing EMDK for Android in Eclipse by selecting the \"Use Eclipse/ADT\" radio button and then Click Next.\n>NOTE: If Android Studio is not installed on your computer this screen will look slightly different. Stating that you should exit the installer and install Android studio. Ignore those instructions if you are not installing the EMDK in Android studio at this time.\n\n\t![img](images/setup/emdkInstall08.png)\n\n5. If you are installing the EMDK into a ADT Bundle select the first radio button ( As Shown ), then click next.\n> NOTE: If you are installing the EMDK into a standalone version of Eclipse that has the ADT plugin installed Skip to STEP #7\n\n\t![img](images/setup/emdkInstall09.png)\n6. Select the root folder of your ADT Bundle installation buy clicking Browse, then Click Install.\n\n\t![img](images/setup/emdkInstall10.png)\n\n7. If you are installing the EMDK into a standalone version of Eclipse that has the ADT plugin installed, select the second radio button ( As Shown ), then click next.\n\n\t![img](images/setup/emdkInstall11.png)\n\n8. Browse for or manually enter paths to the root of both your Eclipse folder and Android SDK folder, then Click Install.\n\n\t![img](images/setup/emdkInstall12.png)\n\n## Verifying EMDK for Android Development Environment\n\n###\tVerifying the EMDK Wizard plug-in integration into the ADT/Eclipse IDE  \n1.\tRun `eclipse.exe` available under `[adt-bundle]\\eclipse` (ex. \\adt-bundle-windows-x86-20140321\\eclipse\\eclipse.exe) or `[eclipse-root]` (ex. \\eclipse-standard-kepler-SR2-win32\\eclipse\\eclipse.exe).\n2.\tThe menu bar should contain a new menu called \"EMDK\" (see below)\n\n\t![img](images/setup/image009.jpg)\n\n### Verifying the SDK add-on integration into the ADT/Eclipse IDE\n1.\tSelect any existing Android application project.\n2.\tGo to `File` -> `Properties`\n\n\t![img](images/setup/image011.jpg)\n3.\tSelect `Android` from left pane.\n\n\t![img](images/setup/image015.jpg)\n4.\tCheck the availability of `EMDK APIs` in the list of Project Build Targets.\n\n\t![img](images/setup/image039.jpg)\n\n### Verifying EMDK for Android Runtime Environment\n\nTo check whether the EMDK runtime is installed on the device or not, check for the existence of `/system/framework/com.symbol.emdk.jar` on the device.\n\n\n![img](images/setup/image097.jpg)\n\n\n##Manually Remove EMDK for Android\nIn most cases running the uninstall program will cleanly remove EMDK For Android from your PC. If the uninstall fails for whatever reason, you may not be able to reinstall. The following directions will allow you to cleanly uninstall all components of the EMDK For Android. Follow the step by step instructions below:\n\n###1. Removing installed EMDK directory\n1. Open command prompt, type `regedt32` and press Enter.\n2. In Registry Editor, locate the following registry key:\n* On 32-Bit OS `[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall]`\n* On 64-Bit OS `[HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion \\Uninstall]`\n\n3. Each key listed under Uninstall in the left pane of Registry Editor represents a program that is currently installed. Scroll through and identify the registry key that has the name EMDK for Android (See Fig.01 or Fig.02).\n* Fig.01\n\t![img](images/setup/uninstallfig1.png)\n* Fig.02\n\t![img](images/setup/uninstallfig2.png)\n\n4. Under key EMDK for Android look for the value UninstallString in the details pane on the right and identify the EMDK for Android installation path (i.e. the parent directory where uninstall.exe resides. See Fig.01 or Fig.02).\n\n5. Locate and delete the Symbol EMDK for Android folder, subfolders and files.\n\n###2. Removing installed EMDK samples directory\n\n1. Locate and delete the Symbol EMDK for Android folder available at `Users\\Public`.\n\n###3. Removing installed EMDK short cuts under Start Programs\n\n1. Locate and delete the following folder available at `<Profile folder>All Users\\Start Menu\\Programs`:\n* `Symbol EMDK for Android vX.X` where vX.X = Base version of the Installation.\n\t* Example: `v3.0` when you have installed `EMDK for Android v3.0`\n\n2. Additionally on Windows 8 and Windows 8.1, locate and delete the following .lnk file available at `<Profile folder>All Users\\Start Menu\\Programs`:\n* `Symbol EMDK for Android vX.X.lnk` where vX.X = Base version of the Installation.\n\t* Example: `v3.0` when you have installed `EMDK for Android v3.0`\n\n###4. Removing installed EMDK plug-in and add-on from ADT/ Eclipse IDE and Android SDK\n\n>Note: Make sure to close all the Android Developer Tools (ADT)/ Eclipse IDE windows before proceeding.\n\n1. For ADT Bundle users, under key EMDK for Android look for the value ADTRootFolder in the details pane on the right and identify the ADT Bundle root folder (see Fig.01).\n2. Locate and remove the Eclipse plug-in and SDK add-on installed by EMDK as below:\n* Go to `\\<adt-bundle>\\eclipse\\plugins` and delete `com.symbol.emdkwizard_x.x.x.jar` file and `EMDK` folder.\n* Go to `\\<adt-bundle>\\sdk\\add-ons` and delete `addon-symbol-emdk_vX.X_API-16` and `addon-symbol-emdk_vX.X_API-19` folders.\n\n3. For Non ADT Bundle users, under key EMDK for Android look for the values EclipseRootFolder and SDKRootFolder in the details pane on the right and identify the Eclipse and SDK root folders installed separately (see Fig.02).\n\n4. Locate and remove the Eclipse plug-in and SDK add-on installed by EMDK as below:\n* Go to `\\<eclipse-root>\\plugins` and delete `com.symbol.emdkwizard_x.x.x.jar` file and `EMDK` folder.\n* Go to `\\<sdk-root>\\sdk\\add-ons` and delete `addon-symbol-emdk_vX.X_API-16` and `addon-symbol-emdk_vX.X_API-19` folders.\n\n###5. Removing installed EMDK registry settings\n\n1. In Registry Editor, locate the following registry key:\n* On 32-Bit OS `[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall]`\n* On 64-Bit OS `[HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall]`\n\n2. Right-click on the EMDK for Android key in the left pane and then click Delete. Click Yes to the prompt `Are you sure you want to delete this key and all of its subkeys?`.\n\n3. If you have installed EMDK updates, scroll through and identify the following registry key:\n* `EMDK for Android vX.X Update(X)` where vX.X = Base version of the Installation.\n\t* Example: `v3.0` when you have installed `EMDK for Android v3.0`\n* Update(X) Update version only if an update is installed. \n\t* Example: `Update1` when you have installed `EMDK for Android v3.0 Update1`.\n\n4. Right-click on the above key and then click Delete. Click Yes to the prompt `Are you sure you want to delete this key and all of its subkeys?`.\n\n\n##Using EMDK as an external library in Eclipse\n\n###Adding EMDK library as an external jar\n\n\n1. Go to `File` menu and select `Properties`.\n\n2. Select `Android` from left-pane.\n\n\t![img](images/setup/emdkJarAsLib01.png)\n\n3. Specify the intended target (except EMDK) under `Project Build Target` and click `Apply`.\n\n4. Select `Java Build Path` from left-pane.\n\n5. Select `Libraries` (tab) from right-pane.\n\n6. Click `Add External JARs`.\n\n7. Browse and specify the `com.symbol.emdk.jar` available under integrated EMDK sdk add-on (ex: `<adt-bundle>\\sdk\\add-ons\\addon-symbol-emdk_v3.1_API-16\\libs\\com.symbol.emdk.jar`).\n\n\t![img](images/setup/emdkJarAsLib02.png)\n\n\n\n##Enabling intellisense for EMDK\n\n1. Click on the arrow and expand the options of `com.symbol.emdk.jar` (above screen).\n\n\t![img](images/setup/emdkJarAsLib03.png)\n\n\n\n\n2. Select `Javadoc location` from the drop down list.\n\n3. Click `Edit`\n\n4. Click `Browse` and specify the `Javadoc` available under EMDK sdk add-on (ex: `<adt-bundle>\\sdk\\add-ons\\addon-symbol-emdk_v3.1_API-16\\docs\\reference\\`).\n\n\t![img](images/setup/emdkJarAsLib04.png)\n\n\n\n5. Click `Validate`\n\n6. The specified Javadoc path will be validated and shows the following message if successful.\n\n\t![img](images/setup/emdkJarAsLib05.png)\n\n7. Click `Apply` and `OK`.\n\n8. Now the intellisense for EMDK is enabled.\n\n9. To verify, type any EMDK class/interface/method name (ex: EMDKListener) and press `F2`.\n\n\t![img](images/setup/emdkJarAsLib06.png)\n\n\n"},{"key":"guide-simulscan_guide","name":"EMDK for Android SimulScan API programmers guide","md":"#EMDK for Android SimulScan API programmers guide\n\n##Introduction\nSimulScan is an end-to-end data capture solution for extracting critical data from documents. A differentiating data capture value-add, it involves capturing fields of interest in a given document and converting it into data that an end-user application can use immediately at the point of transaction. \n\nSimulScan customers benefit from:\n\n- Productivity gain by decoding multiple bar codes read with a single trigger pull\n- Automated data entry with character recognition [OCR]\n- Simplified workflow exceptions with checked mark recognition [OMR] and Signature presence detection\n\nCustomers can interactively capture documents and obtain meaningful data present in the document.  Barcodes are identified and decoded; strings are recognized from fields containing text; images are refined from fields containing pictures and so forth. Based on a \"template\", an image of the entire document is processed by various engines to extract the relevant data.\n\n##Determining device support\n\n- Supported devices : TC55, TC75\n- SimulScan v1.8 \n- EMDK v3.1.x\n\n\n###Our licensing procedure\n\n- Obtain a device license from [https://softwarelicensing.zebra.com/](https://softwarelicensing.zebra.com/)\n\t- Further information on the licensing process can be found [here](https://softwarelicensing.motorolasolutions.com/documentation/index.html).\n- Copy the received XML to the device\n\n- Setup the license on the device (**TC55 2.42 and later devices**)\n\n\t- Go to Settings -> About phone -> Legal information -> Symbol licenses (this will only be available on a 2.42+ BSP device)\n\t- Click on the Android menu button -> Install license\n\t- Navigate to the XML you copied\n\t- Once this is complete, the License Information should be updated to reflect the fact that a license is installed\n\n\n##Getting started with EMDKs SimulScan APIs\n\n###Initialize EMDK manager\n\nFollow the [Basic Scanning Tutorial using Barcode API](#guide-tutorial-tutBasicScanningAPI) to \nset up your project for the EMDK.\n\n>Note: It is recommended to release EMDKManager in onDestroy() and onClose() (Service disconnected unexpectedly)\n\n###Get SimulScanManager\n\n\t:::java\n\tSimulScanManager simulscanManager = (SimulScanManager) emdkManager.getInstance(FEATURE_TYPE.SimulScan);\n\n>Note: Release() must be called on SimulScanManager before switching to another EMDK or DataWedge application\n\n###Get SimulScanReader\n\nThere are two options here:\n\n1. Use the SimulScanManager.getDevice(SimulScanDeviceIdentifier deviceIdentifier) API\n\n\tThe valid SimulScanDeviceIdentifiers are:\n\t- INTERNAL_CAMERA1 : Use the internal camera\n\t- INTERNAL_IMAGER1 : Use the internal imager\n\t- TEMPLATE_DRIVEN : Use the device defined in the template\n\n\tIf the SimulScanDeviceIdentifier is not valid in the target platform an exception will be thrown from the call to getDevice\n\n\t\t:::java\n\t\ttry {\n\t\t\tsimulscanManager.getDevice(SimulScanDeviceIdentifier.INTERNAL_CAMERA1);\n\t\t} catch (SimulScanException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n2. Use the SimulScanManager.getSupportedDevicesInfo() first and then pass one the received SimulScanReaderInfo objects to SimulScanManager.getDevice(SimulScanReaderInfo simulscanReaderInfo)\n\n\t\t:::java\n\t\tList<SimulScanReaderInfo> readerInfoList = simulscanManager.getSupportedDevicesInfo();\n\t\ttry {\n\t\t\tsimulscanManager.getDevice(readerInfoList.get(0));\n\t\t} catch (SimulScanException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n###Using SimulScanReader\n\nFirst register data and status listener to the SimulScanReader object. The listeners must implement the SimulScanDataEventListerner & SimulScanStatusEventListerne interfaces.\n\n\t:::java\n\tpublic class SimulScanTestApp implements SimulScanStatusEventListerner, SimulScanDataEventListerner{\n\t\t@Override\n\t\tpublic void onSimulScanData(SimulScanData form) {\n\t\t\t// TODO Auto-generated method stub\n\t\t}\n\t\t@Override\n\t\tpublic void onSimulScanStatus(SimulScanStatusData status) {\n\t\t\t// TODO Auto-generated method stub\n\t\t}\n\t}\n\t\n\t....\n\n\tSimulScanTestApp m_ SimulScanTestApp = new SimulScanTestApp();\n\ttry {\n\t\tselectedSimulScanReader.addSimulScanStatusListener(m_ SimulScanTestApp);\tselectedSimulScanReader.addSimulScanDataListener(m_ SimulScanTestApp); \n\t} catch (SimulScanException e) {\n\t\te.printStackTrace();\n\t}\n\n**SimulScanReader.enable()** enables the reader hardware. This method does not make the reader to scan. Basically it will make the scanner device available for your application. If another reader is already enabled by you or other applications, this will throw a SimulScanException. You must call disable() when you are done, otherwise all readers will remain locked and will be unavailable for this and any other application that uses SimulScan.\n\n\t:::java\n\ttry {\n\t\tselectedSimulScanReader.enable();\n\t} catch (SimulScanException e) {\n\t\te.printStackTrace();\n\t}\n\nOnce the barcode is enabled, we will must set a valid template for the reader. The template and other configurations can be changed via the SimulScanReaders SimulScanConfig. The templates can be loaded via the SimulScanMultiTemplate class.\n\n\t:::java\n\tSimulScanConfig config = selectedSimulScanReader.getConfig();\n\n\tSimulScanMultiTemplate multiTemplate = new SimulScanMultiTemplate(Uri.fromFile(\"/file/path\"));\n\tif(multiTemplate != null)\n\t\tconfig.multiTemplate = multiTemplate;\t\t\t\t\n\t//optionally set other configs\n\tconfig.enableAutoCapture = true;\n\t config.enableResultConfirmation = true;\n\t config.processingTimeout = 10000;\n\n\t// Apply config\n\t selectedSimulScanReader.setConfig(config);\n\nTo create SimulScan templates use the Template Builder\" graphical tool web tool at https://simulscan.zebra.com/.\n Template builder help can be found there at https://simulscan.zebra.com/Content/Help/WebHelp/index.htm. \n After creating the templates, copy the template XML to your device and use the new SimulScanMultiTemplate() API to open the created template.\n\nAfter setting a template we can start a scan using the SimulScanReader.read() API. The read request can be canceled by issuing a cancelRead(). If a read() is submitted while another read is pending, the method call will fail. It is recommended to check whether a read is pending by calling isReadPending() before submitting a read().\n\n\t:::java\n\ttry {\n\t\tif(!selectedSimulScanReader.isEnabled())\n\t\t\tselectedSimulScanReader.enable();\n\t} catch (SimulScanException e) {\n\t\te.printStackTrace();\n\t}\n\nWhen we are done with scanning, we must release the scanner hardware resources for other applications to use. So it is recommended to override onStop() method disable any enabled SimulScanReaders.\n\n\t:::java\n\t@Override\n\tpublic void onStop(){\n\t\tif(selectedSimulScanReader.isReadPending()){\n\t\t\ttry {\n\t\t\t\tselectedSimulScanReader.cancelRead();\n\t\t\t} catch (SimulScanException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tif(selectedSimulScanReader.isEnabled()){\n\t\t\t\tselectedSimulScanReader.disable();\n\t\t\t}\n\t\t} catch (SimulScanException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t\tsuper.onStop();\n\t}\n\n###SimulScanConfig in detail\n\nThe SimulScanConfig APIs can be used to set various SimulScan configuration parameters for each SimulScan reader. To get the current configuration of a SimulScanReader via a SimulScanConfig object, use the SimulScanReader.getConfig() API. Use the SimulScanConfig objects public parameters to change the configuration and then call SimulScanReader.setConfig(SimulScanConfig config) to apply the changes.\n\nThe valid configuration parameters are as follows:\n\n- enableAutoCapture : If true, form will be captured automatically when detected.\n- enableDebugMode : If enabled, allows a session to write form capture, region images, region values, and other data to storage.\n- enableFeedbackAudio : Turn on/off audio feedback.\n- enableHaptic : Turn on/off haptic feedback.\n- enableLED : Turn on/off LED feedback.\n- enableResultConfirmation : If enabled, shows a UI confirmation with results in SimulScanView before sending results back to application.\n- identificationTimeout : Amount of time in milliseconds to wait before timing out identification.\n- multiTemplate : The SimulScanMultiTemplate to scan\n- processingTimeout : Amount of time in milliseconds to wait before timing out processing\n\n\t:::java\n\tSimulScanConfig config = selectedSimulScanReader.getConfig();\t\t\t\n\n\tconfig.enableAutoCapture = true;\n\t config.enableResultConfirmation = true;\n\t config.processingTimeout = 10000;\n\n\t// Apply config\n\t selectedSimulScanReader.setConfig(config);\n\n###Handling onSimulScanStatus events\n\nEMDK will generate onSimulSCanStatus events when there is a change in state in a particular SimulScanReader. Use the SimulScanStatusData object in the onSimulScanScanStatus callback method to get information on the status. \n\n\t:::java\n\t@Override\n\tpublic void onSimulScanStatus(SimulScanStatusData statusData) {\n\n\t\t// Print the friendly name of the Reader that originated the status update\n\t\tLog.v(TAG, \"Reader: \"+ statusData.getFriendlyName());\t\n\t\t// Handle the various state changes\n\t\tswitch (statusData.getState()) {\n\t\t\tcase DISABLED:\n\t\t\t\tLog.v(TAG, \"onDisabled\");\n\t\t\t\tbreak;\n\t\t\tcase ENABLED: \n\t\t\t\tLog.v(TAG, \"onEnabled\");\n\t\t\t\tbreak; \n\t\t\tcase SCANNING: \n\t\t\t\tLog.v(TAG, \"Scanning\");\n\t\t\t\tbreak; \n\t\t\tcase IDLE: \n\t\t\t\tLog.v(TAG, \"Idle\");\n\t\t\t\tbreak; \n\t\t\tcase ERROR: \n\t\t\tLog.e(TAG, \"ERROR: \" + statusData.extendedInfo. getExtendedStatusDescription ());\n\t\t\t\tbreak; \n\t\t\tcase UNKNOWN: \n\t\t\tdefault: \n\t\t\t\tbreak; \n\t\t}\n\t}\n\n\nUse the SimulScanStatusDatas getFriendlyName() API to get the friendly name of the SimulScanReader that has generated the Status event and use the getState() API to get the SimulScanStatus object with the status change information. \n\nThe list of valid states are as follows:\n\n- DISABLED : Disabled called successfully on reader\n- ENABLED : Enabled reader successfully\n- ERROR : Error occurred\n- IDLE : Finished scanning\n- SCANNING : Successfully started scanning\n- UNKNOWN : Known status\n\nFor additional error information use the Extended info parameter of the SimulScanStatusData object. \n\n>Note: If you plan to do any significant processing during the onSimulScanStatus callback, you should do so in a background thread so that it does not block the UI thread.\n\n###Handling onSimulScanData events\n\nEMDK will generate onSimulScanData events after a successful scan. Use the SimulScanData object that is passed to this callback routine to get the extracted scanned information.  \n\n>Note: The SimulScanData should be processed on a background thread so that it does not block the UI thread.\n\n\t:::java\n\tpublic void onSimulScanData(SimulScanData simulscanData) {\n\t\t\tDate timestamp = new Date(simulscanData.getTimestamp());\n\t\t\tList<SimulScanElement> simulscanDataElements = simulscanData.getElements();\n\t\t\tList<SimulScanRegion> simulscanDataRegions = new ArrayList<SimulScanRegion>(); \n\t\t\tfor (SimulScanElement curElement : simulscanDataElements) \n\t\t\t{\n\t\t\t\tif (curElement instanceof SimulScanRegion) {\n\t\t\t\t\tLog.d(TAG, ((SimulScanRegion) curElement).getName());\n\t\t\t\t} else if (curElement instanceof SimulScanGroup) {\t\n\t\t\t\t\tList<SimulScanRegion> regionsInGroup = ((SimulScanGroup)curElement).getRegions();\n\t\t\t\t\tfor (SimulScanRegion curRegion : regionsInGroup){ \n\t\t\t\t\t\tLog.d(TAG, Group:+ ((SimulScanGroup)curElement).getName() + Region:+ ((SimulScanRegion) curRegion).getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t }\n\n\n**SimulScanData.getTemplate()** returns the extracted template. This template information can be used to reconstruct the original scanned image from the extracted data.\nThe **SimulScanElements** returned from **SimulScanData.getElements()** API are either instances of SimulScanRegion for SimulScanGroup. Use the **SimulScanRegions getData()** API to get the actual OCR, OMR, Barcode or image data. The type of the returned object from getData() will depend on the SimulScanRegion.\n\nRegionType as shown in the table below:\n\n<table class=\"table\">\n<tr>\n<td>RegionType</td><td>Data type</td>\n</tr>\n<tr>\n<td>OCR</td><td>String</td>\n</tr>\n<tr>\n<td>OMR</td><td>Integer</td>\n</tr>\n<tr>\n<td>Barcode</td><td>String</td>\n</tr>\n<tr>\n<td>Picture</td><td>Byte[] (binary image data)</td>\n</tr>\n</table>\n\n###Important considerations\n\nDue to a known issue with the Symbol SimulScan framework version 1.8, the orientation of your application must be fixed preferably using the AndroidManifest.xml. Failing to do so may cause your application to hang if the orientation changes during a scan.\n"},{"key":"guide-tutorial-tutAddProfileManagerFeature","name":" Adding features to Profile Manager","md":"# Adding features to Profile Manager\n\n## Overview\nThis tutorial helps you adding different features using Profile Manager to your newly created or existing Profile for any [EMDK for Android](https://developer.motorolasolutions.com/community/android/emdk) application. Creation of Profile is going to be a common step for all the tutorials that use [EMDK for Android](https://developer.motorolasolutions.com/community/android/emdk) API except their \"targeted features\" for the respective tutorials.\n\n\n## Creating Profile \n1. Select the project from Package Explorer.\n    \n2. Click \"EMDK\" menu present on the top-bar and select \"Profile Manager\" option.\n  \n3. The EMDK Profile Manager Window will appear.\n  \n    ![img](images/AddProfileManagerFeatureImage/emdk_profile_manager.jpg)\n\n4. Click \"Create\" and assign a name for the profile (Ex: MyEMDKProfile).\n  \n    ![img](images/AddProfileManagerFeatureImage/create_new_profile.jpg)\n  \n5. EMDK 3.1 provides a set of new features along with the existing features of EMDK 3.0\n\n6. Click \"Create\" and the Profile Editor window will appear with a set of features on its left hand side.\n\n\t![img](images/AddProfileManagerFeatureImage/profile_editor_4.3.jpg) \n\n7. The Profile Manager wizard provides various features, one of them being Data Capture for capturing Barcode, MSR data in your application and many Mx features (Ex. Wireless Manager, Clock Manager, Access Manager, Browser Manager, Encrypt Manager etc.) for configuring your Symbol device based on requirements.\n"},{"key":"guide-tutorial-tutAdvancedScanningAPI","name":" Advanced Scanning Tutorial using Barcode API","md":"# Advanced Scanning Tutorial using Barcode API\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use [Barcode/Scanning APIs](#guide-reference-EMDKList) introduced in EMDK V 3.0, to perform some of the additional options along with Scanning operations on your Symbol Android devices without using Profile Wizard. The API uses [Barcode Manager](#api-BarcodeManager), which is the primary object to access barcode scanning feature. \n\nIn this tutorial, we will explore the [Barcode/Scanning API](#guide-reference-EMDKList) by using some of its features for developing an advanced application that will scan barcodes. The application focuses on scanning the barcodes using soft scan trigger, which would be a button that we are going to use in the application itself and not the hard scan trigger on the device.\n\n> Note: You don't need the Profile Wizard while using the Barcode/Scanning APIs as everything could be configured programmatically through code.\n\nWe will be configuring following features:\n\n* **Device Types:**\nUsing this feature, we will get the scanning devices supported by a specific Symbol device (Ex. Serial SSI Scanner, Camera Scanner etc.)\n\n* **[Decoder Params](#api-ScannerConfig-DecoderParams):**\nThis feature will be used to configure various types of decoders through our applications for scanning specific type of decoder scanner. (Ex. Code 11, Code 39, UPCA etc.)\n\n* **[Reader Params](#api-ScannerConfig-ReaderParams):**\nReader params are used to configure reader specific options of a particular scanning device. In this tutorial, we will configure Illumination Mode for \"Camera Scanner\".\n\n> Note: \"Illumination Mode\" is available only for Camera Scanner device.\n\n* **[Scan Params](#api-ScannerConfig-ScanParams):**\nScanParams class provides access to scanning parameters that are available for all decoders.\nIn this tutorial we will configure following Scanning Params:\n  1. Vibration: This Scan Param is used to configure Vibration of the scanner device when scanning barcodes.\n  2. Scan Tone: This Scan Param is used to set Scan tone while scanning barcodes. We can apply various media, notification or alarm tones to the device while scanning barcodes. We can also keep a silent tone by not passing any parameter to this attribute. In this tutorial, we will provide a list of Scan Tones for the user to select including silent mode where we won't pass any parameter to Scan Tone attribute.      \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"AdvancedScanningTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).   \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK to scan the barcodes.\n  \n    ![img](images/AdvancedScanningTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK': \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\" /> \n\n    Then you must enable the library for EMDK:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/AdvancedScanningTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.EMDKManager;\n\t\timport com.symbol.emdk.EMDKManager.EMDKListener;\n\t\timport com.symbol.emdk.barcode.ScanDataCollection;\n\t\timport com.symbol.emdk.barcode.Scanner.DataListener;\n\t\timport com.symbol.emdk.barcode.Scanner.StatusListener;\n\t\timport com.symbol.emdk.barcode.StatusData;   \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.\n\n    After that you also need to implement `StatusListener` for notifying client applications to notify scan events. Override its `onStatus` function.\n\n     Implement `DataListener` for notifying client applications when the scan data is available. Override its `onData` function.\n\n\tFinally, we will implement `OnCheckedChangeListener` that has an overriden method `onCheckedChanged`, which gets called whenever the user checks or unchecks any checkbox. We will be using checkboxes for various decoders that user can check or uncheck based on the requirement.  \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener,\n\t\tStatusListener, DataListener, OnCheckedChangeListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n         @Override\n\t     public void onClosed() {\n\t\t  // TODO Auto-generated method stub\n\n\t     }\n\n\t     @Override\n\t     public void onOpened(EMDKManager arg0) {\n\t\t  // TODO Auto-generated method stub\n\n\t     }\n\n\t     @Override\n\t     public void onData(ScanDataCollection scanDataCollection) {\n\t\t  // TODO Auto-generated method stub\n\n\t     }\n\n\t     @Override\n\t     public void onStatus(StatusData statusData) {\n\t\t  // TODO Auto-generated method stub\n\n\t     }\n\n\t     @Override\n\t     public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t  // TODO Auto-generated method stub\n\n\t     }  \n          \n        }\n\n\t> Note: If you are using Android Studio, press CTRL+ALT+O or CMD+ALT+O to organize imports.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+O or CMD+SHFT+O to organize imports.      \n\n    We will now create some global variables to hold the instance objects of EMDKManager, [BarcodeManager](#api-BarcodeManager) and [Scanner](#api-Scanner). These variables would be used throughout the code.\n\n    It will have some UI elements such as [Checkboxes](http://developer.android.com/reference/android/widget/CheckBox.html) to  \n\n    We will then add some UI elements starting with a [TextView](http://developer.android.com/reference/android/widget/TextView.html) to display the status of scanning operation and then [EditText](http://developer.android.com/reference/android/widget/EditText.html) to populate scanned barcode data.\n\n    We will also declare a boolean variable to call setProfile() method only when required avoiding scanner exceptions while setting profile.\n    \n        :::java\n        // Declare a variable to store EMDKManager object\n\t\tprivate EMDKManager emdkManager = null;\n\t\n\t\t// Declare a variable to store Barcode Manager object\n\t\tprivate BarcodeManager barcodeManager = null;\n\t\n\t\t// Declare a variable to hold scanner device to scan\n\t\tprivate Scanner scanner = null;\n\t\n\t\t// Button to scan barcodes through the app using soft trigger\n\t\tprivate Button scanButton;\n\t\n\t\t// Text view to display status of EMDK and Barcode Scanning Operations\n\t\tprivate TextView statusTextView = null;\n\t\n\t\t// Edit Text that is used to display scanned barcode data\n\t\tprivate EditText dataView = null;\n\t\n\t\t// CheckBox to set Decoder Param Code 11;\n\t\tprivate CheckBox checkBoxCode11;\n\t\n\t\t// CheckBox to set Decoder Param Code 39;\n\t\tprivate CheckBox checkBoxCode39;\n\t\n\t\t// CheckBox to set Decoder Param Code 128;\n\t\tprivate CheckBox checkBoxCode128;\n\t\n\t\t// CheckBox to set Decoder Param Code UPCA;\n\t\tprivate CheckBox checkBoxCodeUPCA;\n\t\n\t\t// CheckBox to set Decoder Param EAN 8;\n\t\tprivate CheckBox checkBoxEAN8;\n\t\n\t\t// CheckBox to set Decoder Param EAN 13;\n\t\tprivate CheckBox checkBoxEAN13;\n\t\n\t\t// CheckBox to set Reader Param Illumination Mode;\n\t\tprivate CheckBox checkBoxIlluminationMode;\n\t\n\t\t// CheckBox to set Scan Param Vibration Mode (decodeHapticFeedback);\n\t\tprivate CheckBox checkBoxVibrationMode;\n\t\n\t\t// Drop Down for selecting scanner devices\n\t\tprivate Spinner deviceSelectionSpinner;\n\t\n\t\t// Drop Down for selecting the type of streaming on which the scan beep\n\t\t// should\n\t\t// be played\n\t\tprivate Spinner scanToneSpinner;\n\t\n\t\t// Array Adapter to hold arrays that are used in various drop downs\n\t\tprivate ArrayAdapter<String> spinnerDataAdapter;\n\t\n\t\t// List of supported scanner devices\n\t\tprivate List<ScannerInfo> deviceList;\n\t\n\t\t// Provides current scanner index in the device Selection Spinner\n\t\tprivate int scannerIndex = 0;\n\t\n\t\t// Boolean to avoid calling setProfile() method again in the scan tone\n\t\t// listener\n\t\tprivate boolean isScanToneFirstTime;\n\n    The code till here looks like:\n\n    ![img](images/AdvancedScanningTutorialImages/variables_added.jpg)\n\n\tand the remaining part looks like:\n\n\t![img](images/AdvancedScanningTutorialImages/variables_added_remaining.jpg)\n\n\t> Note: Due to more variables, it has been divided into multiple screen captures. \n\n2. Now, let us design the simple UI that has fields for each of the features mentioned above starting with [Spinner](http://developer.android.com/guide/topics/ui/controls/spinner.html) to display list of scanner devices and scan tones at the bottom. It will then have some [Checkboxes](http://developer.android.com/reference/android/widget/CheckBox.html) to display decoder params, reader params and scan params for scanner. We then have a [Button](http://developer.android.com/reference/android/widget/Button.html) that would be set as a soft trigger in the app to scan barcodes later in this tutorial as we are not using the hard scan trigger of the device. Finally the screen has a [TextView](http://developer.android.com/reference/android/widget/TextView.html) to display the status of scanning operation and above that an [EditText](http://developer.android.com/reference/android/widget/EditText.html) to populate scanned barcode data. Since the UI has lots of elements, we need to embed it in a [ScrollView](http://developer.android.com/reference/android/widget/ScrollView.html) to view all the UI elements.\n\n    So, remove all the code, inside \"res/layout/activity_main.xml\" and add following XML layout code for UI.\n\n        :::xml\n\t    <ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"fill_parent\"\n\t    android:layout_height=\"fill_parent\"\n\t    android:paddingBottom=\"5dip\" >\n\t\n\t\t    <RelativeLayout\n\t\t        android:layout_width=\"match_parent\"\n\t\t        android:layout_height=\"wrap_content\" >\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/device_Selection\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_margin=\"5dip\"\n\t\t            android:text=\"Select Scanner Device Type:\"\n\t\t            android:textSize=\"16sp\"\n\t\t            android:textStyle=\"bold\" />\n\t\t\n\t\t        <Spinner\n\t\t            android:id=\"@+id/device_selection_spinner\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/device_Selection\"\n\t\t            android:layout_margin=\"5dip\" />\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/decoder_selection\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/device_selection_spinner\"\n\t\t            android:layout_margin=\"5dip\"\n\t\t            android:text=\"Select Decoder Params:\"\n\t\t            android:textSize=\"16sp\"\n\t\t            android:textStyle=\"bold\" />\n\t\t\n\t\t        <RelativeLayout\n\t\t            android:id=\"@+id/decoder_layout\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/decoder_selection\"\n\t\t            android:layout_margin=\"5dip\" >\n\t\t\n\t\t            <CheckBox\n\t\t                android:id=\"@+id/checkBoxCode39\"\n\t\t                android:layout_width=\"wrap_content\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_alignParentLeft=\"true\"\n\t\t                android:layout_margin=\"3dip\"\n\t\t                android:checked=\"true\"\n\t\t                android:text=\"Code 39\"\n\t\t                android:textSize=\"14sp\" />\n\t\t\n\t\t            <CheckBox\n\t\t                android:id=\"@+id/checkBoxCode128\"\n\t\t                android:layout_width=\"wrap_content\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_margin=\"3dip\"\n\t\t                android:layout_toRightOf=\"@+id/checkBoxCode39\"\n\t\t                android:checked=\"true\"\n\t\t                android:text=\"Code 128\"\n\t\t                android:textSize=\"14sp\" />\n\t\t\n\t\t            <CheckBox\n\t\t                android:id=\"@+id/checkBoxUPCA\"\n\t\t                android:layout_width=\"wrap_content\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_margin=\"3dip\"\n\t\t                android:layout_toRightOf=\"@+id/checkBoxCode128\"\n\t\t                android:checked=\"true\"\n\t\t                android:text=\"UPCA\"\n\t\t                android:textSize=\"14sp\" />\n\t\t\n\t\t            <CheckBox\n\t\t                android:id=\"@+id/checkBoxCode11\"\n\t\t                android:layout_width=\"wrap_content\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_alignParentLeft=\"true\"\n\t\t                android:layout_below=\"@+id/checkBoxCode39\"\n\t\t                android:layout_margin=\"3dip\"\n\t\t                android:checked=\"true\"\n\t\t                android:text=\"Code 11\"\n\t\t                android:textSize=\"14sp\" />\n\t\t\n\t\t            <CheckBox\n\t\t                android:id=\"@+id/checkBoxEan8\"\n\t\t                android:layout_width=\"wrap_content\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_below=\"@+id/checkBoxCode128\"\n\t\t                android:layout_margin=\"3dip\"\n\t\t                android:layout_toRightOf=\"@+id/checkBoxCode11\"\n\t\t                android:checked=\"true\"\n\t\t                android:text=\"EAN 8\"\n\t\t                android:textSize=\"14sp\" />\n\t\t\n\t\t            <CheckBox\n\t\t                android:id=\"@+id/checkBoxEan13\"\n\t\t                android:layout_width=\"wrap_content\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_below=\"@+id/checkBoxUPCA\"\n\t\t                android:layout_marginLeft=\"25dip\"\n\t\t                android:layout_marginTop=\"3dip\"\n\t\t                android:layout_toRightOf=\"@+id/checkBoxEan8\"\n\t\t                android:checked=\"true\"\n\t\t                android:text=\"EAN 13\"\n\t\t                android:textSize=\"14sp\" />\n\t\t        </RelativeLayout>\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/reader_selection\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/decoder_layout\"\n\t\t            android:layout_margin=\"5dip\"\n\t\t            android:text=\"Select Reader Params:\"\n\t\t            android:textSize=\"16sp\"\n\t\t            android:textStyle=\"bold\" />\n\t\t\n\t\t        <CheckBox\n\t\t            android:id=\"@+id/illumination\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_alignParentLeft=\"true\"\n\t\t            android:layout_below=\"@+id/reader_selection\"\n\t\t            android:layout_margin=\"3dip\"\n\t\t            android:checked=\"false\"\n\t\t            android:text=\"Illumination Mode\"\n\t\t            android:textSize=\"14sp\" />\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/scan_selection\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/illumination\"\n\t\t            android:layout_margin=\"5dip\"\n\t\t            android:text=\"Select Scan Params:\"\n\t\t            android:textSize=\"16sp\"\n\t\t            android:textStyle=\"bold\" />\n\t\t\n\t\t        <RelativeLayout\n\t\t            android:id=\"@+id/scan_layout\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/scan_selection\"\n\t\t            android:layout_margin=\"5dip\" >\n\t\t\n\t\t            <CheckBox\n\t\t                android:id=\"@+id/vibration\"\n\t\t                android:layout_width=\"wrap_content\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_alignParentLeft=\"true\"\n\t\t                android:layout_margin=\"3dip\"\n\t\t                android:checked=\"false\"\n\t\t                android:text=\"Vibration\"\n\t\t                android:textSize=\"14sp\" />\n\t\t\n\t\t            <TextView\n\t\t                android:id=\"@+id/scan_tone\"\n\t\t                android:layout_width=\"match_parent\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_below=\"@+id/vibration\"\n\t\t                android:layout_margin=\"5dip\"\n\t\t                android:text=\"Select Scan Tone:\"\n\t\t                android:textSize=\"14sp\" />\n\t\t\n\t\t            <Spinner\n\t\t                android:id=\"@+id/scan_tone_spinner\"\n\t\t                android:layout_width=\"match_parent\"\n\t\t                android:layout_height=\"wrap_content\"\n\t\t                android:layout_below=\"@+id/scan_tone\"\n\t\t                android:layout_margin=\"5dip\" />\n\t\t        </RelativeLayout>\n\t\t\n\t\t        <Button\n\t\t            android:id=\"@+id/btn_scan\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/scan_layout\"\n\t\t            android:layout_centerHorizontal=\"true\"\n\t\t            android:layout_margin=\"5dip\"\n\t\t            android:text=\"Scan\" />\n\t\t\n\t\t        <EditText\n\t\t            android:id=\"@+id/editText1\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/btn_scan\"\n\t\t            android:layout_centerHorizontal=\"true\"\n\t\t            android:ems=\"10\"\n\t\t            android:fadeScrollbars=\"true\"\n\t\t            android:focusableInTouchMode=\"false\"\n\t\t            android:inputType=\"none|textMultiLine\" />\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/textViewStatusTitle\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/editText1\"\n\t\t            android:layout_centerHorizontal=\"true\"\n\t\t            android:text=\"Status:\" />\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/textViewStatus\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_below=\"@+id/textViewStatusTitle\"\n\t\t            android:layout_centerHorizontal=\"true\"\n\t\t            android:layout_marginBottom=\"10dip\"\n\t\t            android:text=\"\" />\n\t\t    </RelativeLayout>\n\t\t\n\t\t</ScrollView>\n\n    > Note: If you are using Eclipse with ADT, press CTRL+SHFT+F or CMD+SHFT+F for indentation.\n    > \n    > OR\n    > \n    > If you are using Android Studio, press CTRL+ALT+I or CMD+ALT+I for indentation.\n\n    The code till here looks like:\n\n    ![img](images/AdvancedScanningTutorialImages/ui_layout.jpg)      \n \n3. In the `onCreate` method, we take reference of UI elements that are declared in `res/layout/activity_main.xml` in order to use them in our [Activity](http://developer.android.com/reference/android/app/Activity.html). We would then set `OnCheckedChangeListener` for all the checkboxes followed by `setOnTouchListener` for the \"Scan\" button that we have declared in UI.\n\n    We will also set the Spinner Adapter to hold the list of Scanner devices and Scan Tones followed by the listener calls for both spinners.    \n\n    We then call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        // Reference to UI elements\n\t\tstatusTextView = (TextView) findViewById(R.id.textViewStatus);\n\t\tdataView = (EditText) findViewById(R.id.editText1);\n\t\tcheckBoxCode11 = (CheckBox) findViewById(R.id.checkBoxCode11);\n\t\tcheckBoxCode39 = (CheckBox) findViewById(R.id.checkBoxCode39);\n\t\tcheckBoxCode128 = (CheckBox) findViewById(R.id.checkBoxCode128);\n\t\tcheckBoxCodeUPCA = (CheckBox) findViewById(R.id.checkBoxUPCA);\n\t\tcheckBoxEAN8 = (CheckBox) findViewById(R.id.checkBoxEan8);\n\t\tcheckBoxEAN13 = (CheckBox) findViewById(R.id.checkBoxEan13);\n\n\t\tcheckBoxIlluminationMode = (CheckBox) findViewById(R.id.illumination);\n\t\tcheckBoxVibrationMode = (CheckBox) findViewById(R.id.vibration);\n\n\t\tcheckBoxCode11.setOnCheckedChangeListener(this);\n\t\tcheckBoxCode39.setOnCheckedChangeListener(this);\n\t\tcheckBoxCode128.setOnCheckedChangeListener(this);\n\t\tcheckBoxCodeUPCA.setOnCheckedChangeListener(this);\n\t\tcheckBoxEAN8.setOnCheckedChangeListener(this);\n\t\tcheckBoxEAN13.setOnCheckedChangeListener(this);\n\t\tcheckBoxIlluminationMode.setOnCheckedChangeListener(this);\n\t\tcheckBoxVibrationMode.setOnCheckedChangeListener(this);\n\n\t\tdeviceSelectionSpinner = (Spinner) findViewById(R.id.device_selection_spinner);\n\t\tscanToneSpinner = (Spinner) findViewById(R.id.scan_tone_spinner);\n\n\t\t// Adapter to hold the list of scan tone options\n\t\tspinnerDataAdapter = new ArrayAdapter<String>(this,\n\t\t\t\tandroid.R.layout.simple_spinner_item, getResources()\n\t\t\t\t\t\t.getStringArray(R.array.scan_tone_array));\n\t\tspinnerDataAdapter\n\t\t\t\t.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\t// Set adapter to scan tone drop down\n\t\tscanToneSpinner.setAdapter(spinnerDataAdapter);\n\n\t\t// Add onClick listener for scan button to enable soft scan through app\n\t\taddScanButtonListener();\n\n\t\t// On Item Click Listener of Scanner Devices Spinner\n\t\taddSpinnerScannerDevicesListener();\n\n\t\t// On Item Click Listener of Scan Tone Spinner\n\t\taddSpinnerScanToneListener();\n\n\t\t// The EMDKManager object will be created and returned in the callback.\n\t\tEMDKResults results = EMDKManager.getEMDKManager(\n\t\t\t\tgetApplicationContext(), this);\n\t\t// Check the return status of getEMDKManager and update the status Text\n\t\t// View accordingly\n\t\tif (results.statusCode != EMDKResults.STATUS_CODE.SUCCESS) {\n\t\t\tstatusTextView.setText(\"EMDKManager Request Failed\");\n\t\t}\n\n    So the complete `onCreate` method looks like:\n     \n     ![img](images/AdvancedScanningTutorialImages/on_create_added.jpg)\n\n4. You will see some errors, which we need to get rid of. So first, we need to provide `scan_tone_array` to the spinner data adapter. So create `arrays.xml` file under `res/values` folder and write following code of array in `<resources>` tag. This will remove the adapter error.\n\n        :::xml\n\t\t<!-- Array of type of streaming on which the scan beep should be played -->\n        <string-array name=\"scan_tone_array\">\n          <item>NONE (Silent Mode)</item>\n          <item>Adara.ogg</item>\n          <item>Antimony.ogg</item>\n          <item>Xenon.ogg</item>\n          <item>Vega.ogg</item>\n          <item>decode-short.wav</item>\n          <item>decode.wav</item>\n        </string-array>\n\n    So the complete `arrays.xml` code looks like:\n     \n     ![img](images/AdvancedScanningTutorialImages/arrays_code.jpg)\n\n5. Next, We need to add listeners for `Scanner Devices` and `Scan Tone` spinners. The listener for scanner devices spinner will disable the scanner if there is any using `deInitScanner` method and create new scanner instance of scanner device selected from this spinner with the help of index stored in `scannerIndex` using `initializeScanner` method. It will then call `setProfile` method which will set whatever the parameters are enabled in the User interface for various features.\n\n    > Note: We need to re-initialize the scanner and set the properties as we change the device type.\n\n    The listener for scan tone will simply call `setProfile` method, which will set the parameters selected by user on the User Interface.\n\n    > Note: For scan tone spinner listener, we don't need to re-initialize scanner as we are not changing scanner device.\n\n\n        :::java\n        // Listener for Scanner Device Spinner\n\t\tprivate void addSpinnerScannerDevicesListener() {\n\t\n\t\t deviceSelectionSpinner\n\t\t\t\t\t.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onItemSelected(AdapterView<?> parent,\n\t\t\t\t\t\t\t\tView arg1, int position, long arg3) {\n\t\n\t\t\t\t\tscannerIndex = position;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdeInitScanner();\n\t\t\t\t\t\tinitializeScanner();\n\t\t\t\t\t\tsetProfile();\n\t\t\t\t\t} catch (ScannerException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\t// Listener for Scan Tone Spinner\n\t\tprivate void addSpinnerScanToneListener() {\n\t\n\t\t\tscanToneSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onItemSelected(AdapterView<?> parent, View arg1,\n\t\t\t\t\t\tint position, long arg3) {\n\t\n\t\t\t\t\t// Ignore Scan Tone spinner firing of for the first time, which\n\t\t\t\t\t// is not required\n\t\t\t\t\tif (isScanToneFirstTime)\n\t\t\t\t\t\tsetProfile();\n\t\t\t\t\telse\n\t\t\t\t\t\tisScanToneFirstTime = true;\n\t\t\t\t}\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t> Note: The purpose of `isScanToneFirstTime` boolean is to simply avoid calling `setProfile` again in the scan tone spinner initially, as it has already been set in the device spinner.  \n\n    This is how it looks like:\n     \n\t![img](images/AdvancedScanningTutorialImages/device_and_tone_listeners.jpg)\n\n\t![img](images/AdvancedScanningTutorialImages/device_and_tone_listeners_1.jpg)\n\n6. We will now add the `setOnTouchListener` for Scan button. The purpose behind this is to scan barcodes by calling `read` method when user presses the Scan button and stop scanning by canceling any pending asynchronous read calls using `cancelRead` method when user releases the Scan button. The `read` method will not turn ON the scanner. It will, however, put the scanner in a state in which the scanner can be turned ON either by pressing a hardware trigger or can be turned ON automatically. This is determined by the `Scanner.TriggerType`. In order to scan barcodes using button through our application, we need to set the trigger type to `TriggerType.SOFT_ONCE` where the scan beam will come up automatically without having to press the hard scan trigger on the device after issuing the read call.\n\n\t\t:::java\n\t\t// Listener for scan button that uses soft scan to scan barcodes through app\n\t\tprivate void addScanButtonListener() {\n\t\t\tButton scanButton = (Button) findViewById(R.id.btn_scan);\n\t\t\t// On Touch listener for scan button that scans barcodes when pressed\n\t\t\t// and stops\n\t\t\t// scanning when the button is released\n\t\t\tscanButton.setOnTouchListener(new OnTouchListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t// Scan Button Press Event\n\t\t\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Enable Soft scan\n\t\t\t\t\t\t\tscanner.triggerType = TriggerType.SOFT_ONCE;\n\t\t\t\t\t\t\t// cancel any pending reads before reading barcodes\n\t\t\t\t\t\t\tif (scanner.isReadPending())\n\t\t\t\t\t\t\t\tscanner.cancelRead();\n\t\t\t\t\t\t\t// Puts the device in a state where it can scan barcodes\n\t\t\t\t\t\t\tscanner.read();\n\t\t\t\t\t\t} catch (ScannerException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Scan Button Release Event\n\t\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// cancel any pending reads before reading barcodes\n\t\t\t\t\t\t\tif (scanner.isReadPending())\n\t\t\t\t\t\t\t\tscanner.cancelRead();\n\t\t\t\t\t\t} catch (ScannerException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t![img](images/AdvancedScanningTutorialImages/scan_touch_listener.jpg) \n\n7. It will still show few errors as we have not specified the required methods yet. So first we will add `deInitScanner()` method that cancels any pending read operations, removes all status and data listeners, disables the existing scanner instance and sets the scanner instance to `NULL`.\n\n        :::java\n\t    // Disable the scanner instance\n\t\tprivate void deInitScanner() {\n\t\n\t\t\tif (scanner != null) {\n\t\t\t\ttry {\n\t\t\t\t\tscanner.cancelRead();\n\t\n\t\t\t\t\tscanner.removeDataListener(this);\n\t\t\t\t\tscanner.removeStatusListener(this);\n\t\t\t\t\tscanner.disable();\n\t\n\t\t\t\t} catch (ScannerException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\tstatusTextView.setText(\"Status: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t\tscanner = null;\n\t\t\t}\n\t\t}\n\n    This is how `deInitScanner` method looks like:\n     \n    ![img](images/AdvancedScanningTutorialImages/de_init_method.jpg)\n\n7. Next, we will write a method `initializeScanner` to initialize and enable the scanner and its listeners such as status, data etc. by using [Barcode Manager](#api-BarcodeManager) object. The `enable` method enables the scanner hardware. This method does not make the scanner to scan or turn on the laser. Basically it will make the scanner device available for your application. If the same of scanner is enabled by other applications, this will throws ScannerExceptions. You must call `disable()` when you are done the scanning, otherwise it will remain locked and be unavailable to other applications.\n\n\tIn case of any errors, the `statusTextView` will display a failure message to notify user.\n\n\t\t:::java\n\t\t// Method to initialize and enable Scanner and its listeners\n\t\tprivate void initializeScanner() throws ScannerException {\n\t\n\t\t\tif (deviceList.size() != 0) {\n\t\t\t\tscanner = barcodeManager.getDevice(deviceList.get(scannerIndex));\n\t\t\t} else {\n\t\t\t\tstatusTextView\n\t\t\t\t\t\t.setText(\"Status: \"\n\t\t\t\t\t\t\t\t+ \"Failed to get the specified scanner device! Please close and restart the application.\");\n\t\t\t}\n\t\n\t\t\tif (scanner != null) {\n\t\n\t\t\t\t// Add data and status listeners\n\t\t\t\tscanner.addDataListener(this);\n\t\t\t\tscanner.addStatusListener(this);\n\t\n\t\t\t\ttry {\n\t\t\t\t\t// Enable the scanner\n\t\t\t\t\tscanner.enable();\n\t\n\t\t\t\t} catch (ScannerException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\tstatusTextView.setText(\"Status: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n    This is how `initializeScanner` method looks like:\n     \n    ![img](images/AdvancedScanningTutorialImages/initialize_scanner_method.jpg)\n\n8. Now, we will add `setProfile` method. This method will create an instance of [ScannerConfig](#api-ScannerConfig), which will allow us to modify scanner properties (Ex. [Decoder Params](#api-ScannerConfig-DecoderParams), [Reader Params](#api-ScannerConfig-ReaderParams), [Scan Params](#api-ScannerConfig-ScanParams) etc.) and set the changes back to the scanner instance. Here, we will read the checkboxes and spinner values and set them accordingly to the scanner instance through [ScannerConfig](#api-ScannerConfig). `config` is name of [ScannerConfig](#api-ScannerConfig) instance.\n\n\tInitially we will cancel any pending asynchronous read calls before applying profile and reading barcodes using `cancelRead` method on the `scanner` instance.  \n\n    `config.decoderParams` allows us to set all the decoder params such as `code11`,`code39` etc. `readerParams.readerSpecific.cameraSpecific.illuminationMode` enables user to set [Illumination Mode](ScannerConfig#ScannerConfig.IlluminationMode), which is available only for CameraSpecific devices. `config.scanParams.decodeHapticFeedback` lets you set [Vibration Mode](ScannerConfig-ScanParams#ScannerConfig-ScanParams.decodeHapticFeedback) of the scanning device. `config.scanParams.decodeAudioFeedbackUri` will accept a URI for the [Audio Tone](ScanParams#ScannerConfig-ScanParams.decodeAudioFeedbackUri) that user needs to set while scanning a barcode.\n\n    > Note: An empty URI (Ex. `config.scanParams.decodeAudioFeedbackUri = \"\";`) indicates that there will not be any scan tone while scanning a barcode. In other words, it would be your silent mode.\n\n\t\t:::java\n\t\t// Sets the user selected Barcode scanning Profile\n\t\tpublic void setProfile() {\n\t\t\ttry {\n\t\n\t\t\t\t// cancel any pending asynchronous read calls before applying profile\n\t\t\t\t// and start reading barcodes\n\t\t\t\tif (scanner.isReadPending())\n\t\t\t\t\tscanner.cancelRead();\n\t\n\t\t\t\tScannerConfig config = scanner.getConfig();\n\t\n\t\t\t\t// Set code11\n\t\t\t\tif (checkBoxCode11.isChecked()) {\n\t\t\t\t\tconfig.decoderParams.code11.enabled = true;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.decoderParams.code11.enabled = false;\n\t\t\t\t}\n\t\n\t\t\t\t// Set code39\n\t\t\t\tif (checkBoxCode39.isChecked()) {\n\t\t\t\t\tconfig.decoderParams.code39.enabled = true;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.decoderParams.code39.enabled = false;\n\t\t\t\t}\n\t\n\t\t\t\t// Set code128\n\t\t\t\tif (checkBoxCode128.isChecked()) {\n\t\t\t\t\tconfig.decoderParams.code128.enabled = true;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.decoderParams.code128.enabled = false;\n\t\t\t\t}\n\t\n\t\t\t\t// set codeUPCA\n\t\t\t\tif (checkBoxCodeUPCA.isChecked()) {\n\t\t\t\t\tconfig.decoderParams.upca.enabled = true;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.decoderParams.upca.enabled = false;\n\t\t\t\t}\n\t\n\t\t\t\t// set EAN8\n\t\t\t\tif (checkBoxEAN8.isChecked()) {\n\t\t\t\t\tconfig.decoderParams.ean8.enabled = true;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.decoderParams.ean8.enabled = false;\n\t\t\t\t}\n\t\n\t\t\t\t// set EAN13\n\t\t\t\tif (checkBoxEAN13.isChecked()) {\n\t\t\t\t\tconfig.decoderParams.ean13.enabled = true;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.decoderParams.ean13.enabled = false;\n\t\t\t\t}\n\t\n\t\t\t\t// set Illumination Mode, which is available only for\n\t\t\t\t// INTERNAL_CAMERA1 device type\n\t\t\t\tif (checkBoxIlluminationMode.isChecked()\n\t\t\t\t\t\t&& deviceSelectionSpinner.getSelectedItem().toString()\n\t\t\t\t\t\t\t\t.contains(\"Camera\")) {\n\t\t\t\t\tconfig.readerParams.readerSpecific.cameraSpecific.illuminationMode = IlluminationMode.ON;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.readerParams.readerSpecific.cameraSpecific.illuminationMode = IlluminationMode.OFF;\n\t\t\t\t}\n\t\n\t\t\t\t// set Vibration Mode (decodeHapticFeedback)\n\t\t\t\tif (checkBoxVibrationMode.isChecked()) {\n\t\t\t\t\tconfig.scanParams.decodeHapticFeedback = true;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.scanParams.decodeHapticFeedback = false;\n\t\t\t\t}\n\t\n\t\t\t\t// Set the Scan Tone selected from the Scan Tone Spinner\n\t\t\t\tconfig.scanParams.audioStreamType = AudioStreamType.RINGER;\n\t\t\t\tString scanTone = scanToneSpinner.getSelectedItem().toString();\n\t\t\t\tif (scanTone.contains(\"NONE\"))\n\t\t\t\t\t// Silent Mode (No scan tone will be played)\n\t\t\t\t\tconfig.scanParams.decodeAudioFeedbackUri = \"\";\n\t\t\t\telse\n\t\t\t\t\t// Other selected scan tones from the drop-down\n\t\t\t\t\tconfig.scanParams.decodeAudioFeedbackUri = \"system/media/audio/notifications/\"\n\t\t\t\t\t\t\t+ scanTone;\n\t\n\t\t\t\tscanner.setConfig(config);\n\t\n\t\t\t\t// Starts an asynchronous Scan. The method will not turn\n\t\t\t\t// ON the\n\t\t\t\t// scanner. It will, however, put the scanner in a state\n\t\t\t\t// in which\n\t\t\t\t// the scanner can be turned ON either by pressing a\n\t\t\t\t// hardware\n\t\t\t\t// trigger or can be turned ON automatically.\n\t\t\t\tscanner.read();\n\t\n\t\t\t\tToast.makeText(MainActivity.this,\n\t\t\t\t\t\t\"Changes Appplied. Press Scan Button to start scanning...\",\n\t\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\n\t\t\t} catch (ScannerException e) {\n\t\t\t\tstatusTextView.setText(e.toString());\n\t\t\t}\n\t\t}  \n\n    The `setProfile` method looks like:\n     \n    ![img](images/AdvancedScanningTutorialImages/set_profile_method.jpg)  \n    \n9. Whenever the user checks or unchecks any checkbox, we update the settings to the scanner instance at runtime by calling `setProfile()` method through `onCheckedChanged` method of the `OnCheckedChangeListener` that we implemented earlier. So add the method call in `onCheckedChanged()` method.\n\n\t\t:::java\n\t\tsetProfile();\n\n    This looks like:\n     \n    ![img](images/AdvancedScanningTutorialImages/on_checked_change_method.jpg)\n\n10. Now we need to use the `onOpened` method to get a reference to the [EMDKManager](#api-EMDKManager). The [EMDKListener](#api-EMDKManager-EMDKListener) interface will trigger this event when the EMDK is ready to be used. The [EMDKListener](#api-EMDKManager-EMDKListener) interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the earlier steps. We have used that instance to get an instance of [Barcode Manager](#api-BarcodeManager) to enable scanning.\n\n    Once that is done, we need to get all the scanner devices that a Symbol Android device supports with the default one selected first using `enumerateScannerDevices()` that we will declare in the next step. We are not calling `initializeScanner()` and `setProfile` methods here as we have already called them in the device selection spinner listener.\n\n\t> Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager` \n\n\t\t:::java\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the Barcode Manager object\n\t\tbarcodeManager = (BarcodeManager) this.emdkManager\n\t\t\t\t.getInstance(FEATURE_TYPE.BARCODE);\n\n\t\t// Get the supported scanner devices\n\t\tenumerateScannerDevices();  \n\n    Your complete `onOpened` method should now look like this:\n    \n    ![img](images/AdvancedScanningTutorialImages/on_opened_method.jpg)\n    \t                        \n11. To get rid of error, we will create `enumerateScannerDevices` that will get all the scanner devices that a Symbol Android device supports with the default one selected first. It uses `getSupportedDevicesInfo` method on `barcodeManager` instance that returns a list of supported scanner devices for that particular Symbol device. We will then iterate through this list, get the friendly names of each scanner device and add them to our list with those names to show user in Device Spinner.\n\n\t\t:::java\n\t\t// Go through and get the available scanner devices\n\t\tprivate void enumerateScannerDevices() {\n\t\n\t\t\tif (barcodeManager != null) {\n\t\n\t\t\t\tList<String> friendlyNameList = new ArrayList<String>();\n\t\t\t\tint spinnerIndex = 0;\n\t\t\t\t// Set the default selection in the spinner\n\t\t\t\tint defaultIndex = 0;\n\t\n\t\t\t\tdeviceList = barcodeManager.getSupportedDevicesInfo();\n\t\n\t\t\t\tif (deviceList.size() != 0) {\n\t\n\t\t\t\t\tIterator<ScannerInfo> it = deviceList.iterator();\n\t\t\t\t\twhile (it.hasNext()) {\n\t\t\t\t\t\tScannerInfo scnInfo = it.next();\n\t\t\t\t\t\tfriendlyNameList.add(scnInfo.getFriendlyName());\n\t\t\t\t\t\tif (scnInfo.isDefaultScanner()) {\n\t\t\t\t\t\t\tdefaultIndex = spinnerIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++spinnerIndex;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstatusTextView\n\t\t\t\t\t\t\t.setText(\"Status: \"\n\t\t\t\t\t\t\t\t\t+ \"Failed to get the list of supported scanner devices! Please close and restart the application.\");\n\t\t\t\t}\n\t\n\t\t\t\tspinnerDataAdapter = new ArrayAdapter<String>(MainActivity.this,\n\t\t\t\t\t\tandroid.R.layout.simple_spinner_item, friendlyNameList);\n\t\t\t\tspinnerDataAdapter\n\t\t\t\t\t\t.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\n\t\t\t\tdeviceSelectionSpinner.setAdapter(spinnerDataAdapter);\n\t\t\t\tdeviceSelectionSpinner.setSelection(defaultIndex);\n\t\n\t\t\t}\n\t\t}\n\n\tYour complete `enumerateScannerDevices` method should now look like this:\n    \n    ![img](images/AdvancedScanningTutorialImages/enumerate_scanner_method.jpg)\n\n9. As mentioned earlier that whenever a barcode is scanned, its data will be received in a callback `onData` method upon data availability. So we need to get that data, process it in the format we want and populate in the [EditText](http://developer.android.com/reference/android/widget/EditText.html) of UI.\n\n    The received data should be processed on a background thread not to block the UI thread. Hence we will use Android's own [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) to process the scanned data on background thread. So we create AsyncTask `AsyncDataUpdate` that takes [ScanDataCollection](#api-ScanDataCollection), which has the scanned data. It then processes this object in `doInBackground` method to filter the barcode data and label type in strings, which is then passed to the UI thread in `onPostExecute` method of AsyncTask to Populate.\n\n        :::java\n        // Update the scan data on UI\n\t    int dataLength = 0;\n\n\t    // AsyncTask that configures the scanned data on background\n\t    // thread and updated the result on UI thread with scanned data and type of\n\t    // label\n\t    private class AsyncDataUpdate extends\n\t\t\tAsyncTask<ScanDataCollection, Void, String> {\n\n\t\t  @Override\n\t\t  protected String doInBackground(ScanDataCollection... params) {\n\t\t\tScanDataCollection scanDataCollection = params[0];\n\n\t\t\t// Status string that contains both barcode data and type of barcode\n\t\t\t// that is being scanned\n\t\t\tString statusStr = \"\";\n\n\t\t\t// The ScanDataCollection object gives scanning result and the\n\t\t\t// collection of ScanData. So check the data and its status\n\t\t\tif (scanDataCollection != null\n\t\t\t\t\t&& scanDataCollection.getResult() == ScannerResults.SUCCESS) {\n\n\t\t\t\tArrayList<ScanData> scanData = scanDataCollection.getScanData();\n\n\t\t\t\t// Iterate through scanned data and prepare the statusStr\n\t\t\t\tfor (ScanData data : scanData) {\n\t\t\t\t\t// Get the scanned data\n\t\t\t\t\tString barcodeDate = data.getData();\n\t\t\t\t\t// Get the type of label being scanned\n\t\t\t\t\tLabelType labelType = data.getLabelType();\n\t\t\t\t\t// Concatenate barcode data and label type\n\t\t\t\t\tstatusStr = barcodeDate + \" \" + labelType;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return result to populate on UI thread\n\t\t\treturn statusStr;\n\t\t  }\n\n\t\t  @Override\n\t\t  protected void onPostExecute(String result) {\n\t\t\t// Update the dataView EditText on UI thread with barcode data and\n\t\t\t// its label type\n\t\t\tif (dataLength++ > 50) {\n\t\t\t\t// Clear the cache after 50 scans\n\t\t\t\tdataView.getText().clear();\n\t\t\t\tdataLength = 0;\n\t\t\t}\n\t\t\tdataView.append(result + \"\\n\");\n\t\t  }\n\n\t\t  @Override\n\t\t  protected void onPreExecute() {\n\t\t  }\n\n\t\t  @Override\n\t\t  protected void onProgressUpdate(Void... values) {\n\t\t  }\n\t    }\n\n    We call this AsyncTask in overridden `onData` method, by creating an instance of `AsyncDataUpdate` and passing the `scanDataCollection` for further processing.\n\n        :::java\n        // Use the scanned data, process it on background thread using AsyncTask\n\t\t// and update the UI thread with the scanned results\n\t\tnew AsyncDataUpdate().execute(scanDataCollection);\n\n    So the `onData` method and `AsyncDataUpdate` looks like:\n    ![img](images/AdvancedScanningTutorialImages/async_data_update.jpg)\n  \n10. Whether we scan the barcode by pressing the hard scan key or keep it idle, it returns the status of the scanner at specific point of time in the overridden `onStatus` method of implemented `StatusListener` interface. Since we are also displaying the status along with barcode data, we will make use of this method and populate the status.\n\n    Just like scanned data, we are also processing the scanner status on a background thread. Hence we will create another [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) named `AsyncStatusUpdate` that takes [StatusData](#api-StatusData) and processes it in `doInBackground` method to retrieve state in string format which is populated in status Text View on UI thread in `onPostExecute` method of the AsyncTask.              \n\n        :::java\n        // AsyncTask that configures the current state of scanner on background\n\t    // thread and updates the result on UI thread\n\t    private class AsyncStatusUpdate extends AsyncTask<StatusData, Void, String> {\n\n\t\t  @Override\n\t\t  protected String doInBackground(StatusData... params) {\n\t\t\t// Get the current state of scanner in background\n\t\t\tStatusData statusData = params[0];\n\t\t\tString statusStr = \"\";\n\t\t\tScannerStates state = statusData.getState();\n\t\t\t// Different states of Scanner\n\t\t\tswitch (state) {\n\t\t\t// Scanner is IDLE\n\t\t\tcase IDLE:\n\t\t\t\tstatusStr = \"The scanner enabled and its idle\";\n\t\t\t\tisScanning = false;\n\t\t\t\tbreak;\n\t\t\t// Scanner is SCANNING\n\t\t\tcase SCANNING:\n\t\t\t\tstatusStr = \"Scanning..\";\n\t\t\t\tisScanning = true;\n\t\t\t\tbreak;\n\t\t\t// Scanner is waiting for trigger press\n\t\t\tcase WAITING:\n\t\t\t\tstatusStr = \"Waiting for trigger press..\";\n\t\t\t\tbreak;\n\t\t\t// Scanner is not enabled\n\t\t\tcase DISABLED:\n\t\t\t\tstatusStr = \"Scanner is not enabled\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Return result to populate on UI thread\n\t\t\treturn statusStr;\n\t\t  }\n\n\t\t  @Override\n\t\t  protected void onPostExecute(String result) {\n\t\t\t// Update the status text view on UI thread with current scanner\n\t\t\t// state\n\t\t\tstatusTextView.setText(result);\n\t\t  }\n\n\t\t  @Override\n\t\t  protected void onPreExecute() {\n\t\t  }\n\n\t\t  @Override\n\t\t  protected void onProgressUpdate(Void... values) {\n\t\t  }\n\t    }\n\n    We call this AsyncTask in overridden `onStatus` method, by creating an instance of `AsyncStatusUpdate` and passing the `StatusData` for further processing.\n\n        :::java\n        // process the scan status event on the background thread using\n\t\t// AsyncTask and update the UI thread with current scanner state\n\t\tnew AsyncStatusUpdate().execute(statusData);\n\n    So the `onStatus` method and `AsyncStatusUpdate` looks like:\n    ![img](images/AdvancedScanningTutorialImages/async_status_update.jpg)\n\n11. Now let's override the `onDestroy` method so we can release the EMDKManager and BarcodeManager resources:  \n\n        :::java\n\t    @Override\n\t\tprotected void onDestroy() {\n\t\t\tsuper.onDestroy();\n\t\n\t\t\tif (barcodeManager != null)\n\t\t\t\tbarcodeManager = null;\n\t\n\t\t\tif (emdkManager != null) {\n\t\n\t\t\t\t// Clean up the objects created by EMDK manager\n\t\t\t\temdkManager.release();\n\t\t\t\temdkManager = null;\n\t\t\t}\n\t\t} \n\n    Your `onDestroy` method should now look like this:  \n\n    ![img](images/AdvancedScanningTutorialImages/on_destroy_method.jpg)\n\n12. When we are done with scanning, we must release the scanner hardware resources for other applications to use. So override `onStop` method and disable the scanner by calling `deInitScanner` method to release it.\n\n        :::java\n\t    @Override\n\t\tprotected void onStop() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tsuper.onStop();\n\t\t\tdeInitScanner();\n\t\t}\n\n    Your `onStop` method should now look like this:  \n\n    ![img](images/AdvancedScanningTutorialImages/on_stop_method.jpg) \n\n13. Finally, Clean up the objects created by EMDK manager in `onClosed` method, if EMDK closed abruptly.\n\n        :::java\n        // The EMDK closed abruptly. // Clean up the objects created by EMDK\n\t\t// manager\n\t\tif (this.emdkManager != null) {\n\n\t\t\tthis.emdkManager.release();\n\t\t\tthis.emdkManager = null;\n\t\t}\n\n    Your `onClosed` method should now look like this:  \n\n    ![img](images/AdvancedScanningTutorialImages/on_closed_method.jpg)\n\t\nThat's it!!! We are done with all the coding part that will let us perform some advanced barcode scanning operations on our Symbol Android device using [Barcode/Scanning APIs](#guide-reference-EMDKList) introduced in EMDK V 3.0. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n \n2. Run the application.\n\n    ![img](images/AdvancedScanningTutorialImages/home_screen.png)\n\n    You can see a [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html), which indicates that the Scanner has been enabled and you can start scanning by pressing hard scan button of the device.\n  \n3. Now if you press and hold the Scan button on the UI, the status listener in the code starts working and current status of Scanner is displayed in Status [TextView](http://developer.android.com/reference/android/widget/TextView.html), which is `Scanning`. The \"Scanner Device Type\" Spinner shows Serial SSI Scanner as it is the default scanner for Symbol TC55 device. All the decoders are checked, which means current configuration scan supports all of these decoder types. But Scan Tone is `NONE`, which means there won't be any tone/sound while scanning a barcode.   \n\n    ![img](images/AdvancedScanningTutorialImages/status_scanning.png)\n\n    The scanner status is always updated on the status text view below the Edit Text at the bottom.\n\n4. Lets us change some configurations starting with the device type. We will change it to Camera Scanner.\n\n\t![img](images/AdvancedScanningTutorialImages/device_list.png)\n\n\t![img](images/AdvancedScanningTutorialImages/camera_scanner.png)\n\nIt will display a success toast when the changes are applied each time you change any scanner configuration just for your knowledge.\n\n5. Next check the Vibration checkbox and select some scan tone from the Select Scan Tone spinner.\n\n\t![img](images/AdvancedScanningTutorialImages/tone_list.png)\n\n\t![img](images/AdvancedScanningTutorialImages/tone_selected.png)\n\n4. Now once again scan a barcode and this time it will open your device's camera to scan the barcode.\n\n    ![img](images/AdvancedScanningTutorialImages/camera_opened.png)\n\n\t![img](images/AdvancedScanningTutorialImages/final_scan.png)  \n\n    This is how [Barcode/Scanning APIs](#guide-reference-EMDKList) introduced in EMDK V 3.0 can be used to perform some of the Advanced Scanning operations using soft scan key through application on your Symbol devices without using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's `AndroidManifest.xml`:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/AdvancedScanningTutorial.zip)."},{"key":"guide-tutorial-tutApplyProfileSilently","name":" Apply Mx Profile Silently in a Non-Blocking way:","md":"# Apply Mx Profile Silently in a Non-Blocking way:\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. In this tutorial we would discuss on how to apply Mx configurations to the device silently without displaying any User Interface in a non blocking way.\n\n\n**Problem:**\n\nThe Mx features are used to perform device configurations through EMDK profiles as well as programmatically. When we are configuring any Mx feature through EMDK Profile wizard we may not require User Interface. Moreover, the operation of applying EMDK profile configuration to device takes place on the UI main thread. Depending on the Mx feature and complexity, it takes few seconds to apply configurations to the Symbol device. So the application's UI thread is blocked for these few seconds and user cannot interact with application's UI within that time period. Even if the user tries to interact with application's UI, the application does not respond showing \"Application Not Responding\" (ANR) message asking user to wait.\n\n**Reason:**\n\nApplying EMDK configurations is a heavy process to be performed on the main thread. The main thread has to manage UI components primarily. Hence if two heavy functionalities happen on a single main thread, it will delay response to the user actions, which may irritate user and hence stop your process, displaying \"ANR\".\n\n**Solution:**\nIn Android, it is recommended to run only UI components on the main thread. Any other operation should always be run on a different background thread without blocking the UI main thread and completing the operation smoothly without any interruptions such as ANR. \n\nYou can run the Mx configuration on background thread in a Non-Blocking way using any one of the following methods: \n\n**1. Using Android Handler:**\n\n* A [Handler](http://developer.android.com/reference/android/os/Handler.html) allows you to send and process [Message](http://developer.android.com/reference/android/os/Message.html) and Runnable objects associated with a thread's [MessageQueue](http://developer.android.com/reference/android/os/MessageQueue.html). Each Handler instance is associated with a single thread and that thread's message queue.\n* There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.\n* If you are doing multiple repeated tasks, for example downloading multiple images which are to be displayed in ImageViews (like downloading thumbnails) upon download, use a task queue with Handler.\n* When a process is created for your application, its main thread is dedicated to running a message queue that takes care of managing the top-level application objects (activities, broadcast receivers, etc) and any windows they create.\n* You can create your own threads, and communicate back with the main application thread through a Handler.\n\n**2. Using Android AsyncTask:**\n\n* [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.\n* AsyncTask is designed to be a helper class around [Thread](http://developer.android.com/reference/java/lang/Thread.html) and [Handler](http://developer.android.com/reference/android/os/Handler.html) and does not constitute a generic threading framework.\n* AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the `java.util.concurrent` pacakge such as [Executor](http://developer.android.com/reference/java/util/concurrent/Executor.html), [ThreadPoolExecutor](http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html) and [FutureTask](http://developer.android.com/reference/java/util/concurrent/FutureTask.html).\n\n\nSince configuration of any Mx feature requires only a few seconds, we can go with any of the two solutions. In this tutorial, we will configure Mx Profile using both Handler and AsyncTask by creating dedicated Activity for each.   \n\nSo far we know how to configure Profile in a Non-Blocking way. Sometimes we don't need User Interface while configuring an Mx profile. Hence, We used the word \"Silently\" to indicate that there won't be any User Interface in this tutorial. Although, we need UI thread to trigger Mx configuration on the background thread. So we will launch the application and quickly close it after triggering Mx configuration on the background thread.\n\nEven if you have User Interface in your application, you can interact with it as UI will not be blocked, because the profile will be applied on a background thread.\n\n> Note: We are closing the application immediately because we are not notifying user with any UI as well as the configuration is an independent process that we are just triggering from our application and does not require UI. \n\nSo let us create a tutorial and Configure the Mx App Manager Profile to install an application silently in a Non-Blocking way.      \n   \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above\n* Download APK file for the application to install from [here](https://s3.amazonaws.com/emdk/Tutorials/AllInstalledApps.apk)\n* Once downloaded, copy the APK file to SD Card of the device. \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"ApplyProfileSilentlyTutorial\" as the project name for this tutorial and \"HandlerActivity\" as the activity name while creating the project.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The App Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"AppManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. We want to install the downloaded APK file that is residing in the device's SD Card using App Manager. So select the \"App Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/app_manager_feature.jpg)\n\n    Provide some Name in the \"Name\" field to modify this feature programmatically (Ex. MyAppManager).\n\n    > Note: You can also keep the \"Name\" field empty.\n\n    Since we want to install an application, keep the Action in drop-down as \"Install\". \n    Provide the path and name of the Android application APK file within the device file system (Ex. /storage/sdcard1/AllInstalledApps.apk).  \n\n    ![img](images/ApplyProfileSilentlyTutorialImages/app_manager_details.jpg)   \n \n4. Click Apply to apply the settings we provided    \n  \n    ![img](images/ApplyProfileSilentlyTutorialImages/app_manager_profile_created.jpg)\n\n5. Click Finish and your App Manager profile for installing an application is created.\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/app_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" created under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/ApplyProfileSilentlyTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code\n\n###Using Handler:    \n1. Now we will start to add some code in the \"HandlerActivity\" that we created to apply the App Manager profile to the device on a background thread in a Non-Blocking way using Handler. We will see how to apply this profile silently without UI later in this tutorial.  \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;     \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"AppManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n    Since we don't want any UI in this application, remove the line `setContentView(R.layout.activity_handler);` from the `onCreate` method.  \n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/ApplyProfileSilentlyTutorialImages/on_create_added.jpg) \n          \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of `profileManager` and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);\n\n    Create a Runnable instance in `onOpened` method, which will perform App Manager's install configuration on background thread. \n\n        :::java\n        final Message msg = mHandler.obtainMessage();\n\n\t\t// Create Runnable instance to Apply Mx Profile on background thread\n\t\tThread background = new Thread(new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tmsg.obj = applyProfile(profileName);\n\t\t\t\tif (msg.obj != null)\n\t\t\t\t\t// Send the result in message from background to UI\n\t\t\t\t\t// thread for processing.\n\t\t\t\t\tmHandler.sendMessage(msg);\n\n\t\t\t}\n\t\t});\n\t\t// Start the background Thread\n\t\tbackground.start(); \n\n    Ignore the errors for the time being. You can see, the background thread calls `applyProfile` method that applies the Mx App Manager profile configuration to the device on background thread we created. The parameter `msg.obj` contains result of the background thread operation that we need to pass on UI thread. Hence we will create a Handler in next step and pass the result parameter in Handler in a Message using `msg.obj`.\n\n    Since we don't want any UI for this application, we will call the `finish()` method after sending message to Handler. This will immediately close the application as soon as `applyProfile` method is triggered on the background thread through Runnable.\n\n        :::java\n        // Closes the Activity which in turn closes the Application as the\n\t\t// application has only one Activity.\n\t\tfinish();\n\n    Your complete onOpened method should now look like this:\n    \n    ![img](images/ApplyProfileSilentlyTutorialImages/on_opened_method.jpg)\n \n\n3. Create a Handler and retrieve the Result parameter from the Message by type casting `msg.obj` to `String` in `handleMessage` method of Handler.\n\n        :::java\n        // Handler that receives messages from background thread to populate on UI\n\t    // thread.\n\t    private Handler mHandler = new Handler() {\n\t\t  public void handleMessage(Message msg) {\n\t\t\t// Retrieve the result string from message using ((String) msg.obj)\n\t\t\t// and Populate it on UI.\n\t\t\t// Since we don't have UI in this tutorial, we will not use this\n\t\t\t// result string\n\t\t  };\n\t    };\n\n    As you can see the `handleMessage` contains the Message parameter we passed from background thread. The `handleMessage` method can retrieve the `String` result parameter from Message by typecasting `msg.obj` to `String` using `((String) msg.obj)`. Now the user can display this result parameter on the main thread.\n\n    The Handler created looks like::\n    \n    ![img](images/ApplyProfileSilentlyTutorialImages/handler_created.jpg)  \n\n    > Note: We will not be using this result parameter as we don't have UI in this tutorial. But it could be helpful to display result for the applications that have UI.\n    \n4. Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier. This is done using the `processProfile` method. We will now create a method that will use `processProfile` to apply the App Manager profile that we created using EMDK Wizard (Ex. \"applyProfile\").\n\n        :::java\n        private String applyProfile(String profileName) {\n\t\ttry {\n\t\t\t// Call process profile to modify the profile of specified profile\n\t\t\t// name\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, (String[]) null);\n\n\t\t\t// Check the return status of processProfile\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\t\t\t\treturn \"Applying '\" + profileName + \"' was successful.\";\n\n\t\t\t} else {\n\t\t\t\treturn \"Applying '\" + profileName + \"' failed.\";\n\t\t\t}\n\n\t\t  } catch (Exception ex) {\n\n\t\t\treturn ex.getMessage();\n\t\t  }\n\t    }\n\n    Your `applyProfile` method should look like:\n    \n    ![img](images/ApplyProfileSilentlyTutorialImages/apply_profile.jpg)\n\n5. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override\n\t    protected void onDestroy() {\n\t\t // TODO Auto-generated method stub\n\t\t super.onDestroy();\n\t\t\n\t\t //Clean up the objects created by EMDK manager\n\t\t emdkManager.release();\n\t    } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/ApplyProfileSilentlyTutorialImages/on_destroy_method.jpg)\n\n6. Assign Null to EMDK objects in the \"onClosed\" method.\n\n        :::java\n        @Override\n\t    public void onClosed() {\n\t\t // TODO Auto-generated method stub\n\n\t\t // Assign null to the objects\n\t\t emdkManager = null;\n\t\t profileManager = null;\n\t    }\n\n7. So far we have done with the coding that will use Runnable and Handler to apply App Manager's install configuration on background thread. It will also close the application immediately using `finish()` method once background thread starts its execution to apply configurations silently. But the app will still be visible to the user for that small period of time (few milliseconds) before it is closed. We want to avoid UI as it may not require for many Mx configurations. So We will make the UI invisible (basically transparent) for those few milliseconds by applying [Android Styles](http://developer.android.com/guide/topics/ui/themes.html) to the `HandlerActivity`. \n\n    Before applying, we need to create a custom style that will make the UI transparent. So go to res -> values -> styles.xml of \"ApplyProfileSilentlyTutorial\" tutorial and write following Android style in `<resources>` tag that will make background transparent.\n\n        :::xml\n        <style name=\"Transparent\" parent=\"@android:style/Theme\">\n    \t  <item name=\"android:windowBackground\">@android:color/transparent</item>\n    \t  <item name=\"android:windowIsTranslucent\">true</item>\n    \t  <item name=\"android:windowIsFloating\">true</item>\n    \t  <item name=\"android:windowNoTitle\">true</item>\n    \t  <item name=\"android:windowContentOverlay\">@null</item>\n    \t  <item name=\"android:backgroundDimEnabled\">false</item>\n\t\t</style>\n\n    So the code for applying styles in res->values->styles.xml looks like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/styles.jpg)\n\n8. We will now include this style in HandlerActivity to make it transparent. So go to `AndroidManifest.xml` and add the following code in the `<activity>` tag for \"HandlerActivity\".\n\n        :::xml\n        android:theme=\"@style/Transparent\"\n\n    This will apply the styles to \"HandlerActivity\" and make it transparent for those few milliseconds when this Activity is displayed to the user, which will resolve the purpose of calling it Applying Profile **Silently**.\n\n    So the Manifest file looks like: looks like:\n    ![img](images/ApplyProfileSilentlyTutorialImages/handler_styles.jpg)\n \n9. This completes coding and configuration part that will allow us to apply App Manager's install configuration silently in a Non-Blocking way using Handler. If you want, you can run the Application now to test but we are now going to see how the same thing is done using our second option **AsyncTask**.  \n\n###Using AsyncTask:\n\n1. We will create another activity (Ex. AsyncTaskActivity) and apply App Manager's install configuration silently in a Non-Blocking way using [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html).\n\n2. Select the project and add a new Empty with name \"AsyncTaskActivity\".\n\n3. Now we will start to add some code in the \"AsyncTaskActivity\" that we created to apply App Manager profile to the device on a background thread in a Non-Blocking way using AsyncTask. \n\n    Applying the profile silently without UI is same as we did for HandlerActivity.\n\n    > Note: We will use the same earlier transparent styles in \"AsyncTaskActivity\" to make the Activity transparent, which will resolve the purpose of calling it Applying Profile **Silently**.\n\n4. Follow the step 1 of Adding Some Code using Handlers.\n\n    Add two more global variables.\n\n        :::java\n        // Contains XML while setting a profile programmatically. It can be Null.\n        private String[] modifyData;\n\n        // Contains the status of processProfile operation.    \t    \n        private EMDKResults results;\n\n    The code should now look like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/async_oncreate_added.jpg)\n\n5. We will now create an inner class named \"ConfigureProfile\" in \"AsyncTaskActivity\" that will extend `AsyncTask`. [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) will run the operation on a background thread without blocking UI thread. It can also return the processing result on UI thread if you want.\n\n        :::java\n        // Class extending AsyncTask that runs operations in a background thread\n\t    // without blocking UI thread. It returns result on UI thread once the\n\t    // operation is completed.\n\t    private class ConfigureProfile extends AsyncTask<String, Integer, String> {\n\t\t  // Operation to be performed on background thread\n\t\t  @Override\n\t\t  protected String doInBackground(String... params) {\n\t\t\tmodifyData = new String[1];\n\t\t\t// Call processPrfoile with profile name and SET flag to create the\n\t\t\t// profile. The modifyData can be null.\n\t\t\tresults = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\t\t\treturn null;\n\t\t  }\n\n\t\t  // Return result to the UI Thread\n\t\t  @Override\n\t\t  protected void onPostExecute(String result) {\n\t\t\t// Display Success or Failure Message based on result\n\t\t\t// Check the return status of processProfile\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\t\t\t\t// Success\n\n\t\t\t} else {\n\n\t\t\t\t// Failure\n\t\t\t}\n\n\t\t  }\n\n\t\t  // Method to implement actions before the AsynTask executes.\n\t\t  @Override\n\t\t  protected void onPreExecute() {\n\n\t\t  }\n\n\t\t  // Method to display updates of operation\n\t\t  @Override\n\t\t  protected void onProgressUpdate(Integer... progress) {\n\t\t\t\n\t\t  }\n\t    }\n\n    The `doInBackground` method applies the App Manager's install configurations on background thread using `processProfile` method.\n\n    The `onPostExecute` is used to return the result back to the UI thread when the operation on background thread is done.  \n\n    > Note: We won't return any result on UI thread as we want to apply profile silently in this tutorial.\n\n    The code for AsyncTask should look like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/async_task_class.jpg)\n\n6. Once the EMDK is ready, we will get the `ProfileManager` object to process the profile in `onOpened` method.\n    \n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`\n\n        :::java\n        this.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);\n\n     After that we will execute the AsyncTask that by creating instance of it and calling execute method. This will start the process of applying profile on background thread.\n\n    Since we don't want any UI for this application, we will call the `finish()` method immediately to close the application, once the AsyncTask starts executing on background thread. \n\n        :::java\n        if (profileManager != null) {\n\t\t\t// Start EMDK process profile operation on the background thread.\n\t\t\tnew ConfigureProfile().execute(\"\");\n            finish();\n\n\t\t}\n\n    So the complete `onOpened` method looks like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/async_on_opened_method.jpg)\n\n7. We will now write `onDestroy` and `onClosed` methods by adding the same code that we added in the Handler Activity.\n\n    So `onDestroy` and `onClosed` methods look like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/on_closed_destroyed_async.jpg)\n\n8. But the app will still be visible to the user for small period of time (few milliseconds) before it is closed similar to the case of Handler. We want to avoid UI as it may not require for many Mx configurations. So We will make the UI invisible (basically transparent) for those few milliseconds by applying [Android Styles](http://developer.android.com/guide/topics/ui/themes.html) to the `AsyncTaskActivity`.\n\n    We have already created a transparent style earlier in this tutorial while applying profile using Handler. We will now  simply include that style in \"AsyncTaskActivity\" to make it transparent. So go to `AndroidManifest.xml` and add the following code in the `<activity>` tag for \"AsyncTaskActivity\".\n\n        :::xml\n        android:theme=\"@style/Transparent\"\n\n    This will apply the styles to \"AsyncTaskActivity\" and make it transparent for those few milliseconds when this Activity is displayed to the user, which will resolve the purpose of calling it Applying Profile **Silently**.\n\n    So the Manifest file looks like: looks like:\n    ![img](images/ApplyProfileSilentlyTutorialImages/async_styles.jpg)\n\n9. This completes coding and configuration part that will allow us to apply App Manager's install configuration silently in a Non-Blocking way using AsyncTask.\n\n10. So far, We have created two different activities that perform the same operation of applying App Manager's install configuration silently in a Non-Blocking way, but using two different ways viz. Handler and AsyncTask respectively.\n\n    Now, Let us run the application. \n                   \n## Running the Application\n\n1. Connect the Symbol device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, change the lable name to application name for \"AsyncTaskActivity\" in the `<activity>` tag of AndroidManifest.xml\" file by using following code.\n\n        :::xml\n        android:label=\"@string/app_name\"\n\n    So the Manifest file should now look like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/change_lable_name.jpg)\n\n    > Note: It is not necessary to change the label name. But if we don't change, it will display the \"AsyncTaskActivity\" name instead of application name in the device's applications grid, when we run the application using AsyncTask.\n   \n    Now when we run the application, it will launch \"HandlerActivity\" because currently that is the Launcher Activity in \"AndroidManifest.xml\" file. \n\n    ![img](images/ApplyProfileSilentlyTutorialImages/handler_manifest_launcher.jpg) \n\n    > Note: Make sure that \"AllInstalledApps\" is not installed on the device before running the app, else the install feature will give error.  \n\n2. Run the application (Uses Handler).\n\n    You will not see any User Interface. The application applied the App Manager's install configuration on background thread silently using Handler and installed the \"AllInstalledApps\" application whose APK we had provided in the wizard.\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/handler_success.png)\n  \n3. Now we will run the application using AsyncTask. We need to set \"AsyncTaskActivity\" as the Launcher Activity to start the application with \"AsyncTaskActivity\". So remove the \"Intent-Filter\" code from \"HandlerActivity\" and add to the \"AsyncTaskActivity\" in the \"AndroidManifest.xml\" file.\n\n        :::xml\n        <intent-filter>\n           <action android:name=\"android.intent.action.MAIN\" />\n\n           <category android:name=\"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n\n    So the AndroidManifest.xml file now looks like:\n\n    ![img](images/ApplyProfileSilentlyTutorialImages/async_manifest_launcher.jpg)\n\n    Before running the application using \"AsyncTask\", uninstall the \"AllInstalledApps\" application that we installed using Handler just now.\n\n    > Note: Make sure that \"AllInstalledApps\" is not installed on the device before running the app, else the install feature will give error. \n\n4. Run the application (Uses AsyncTask).\n\n    You will not see any User Interface. The application applied the App Manager's install configuration on background thread silently using AsyncTask and installed the \"AllInstalledApps\" application whose APK we had provided in the wizard.  \n\n    ![img](images/ApplyProfileSilentlyTutorialImages/handler_success.png)\n\n    > Note: While running the application using both Handler and AsyncTask, you can interact with the User Interface while profile settings are being applied on background thread. It won't hang the User Interface this time.\n\n    So this is how we can use both Handler and AsyncTask to apply profile settings on background thread in a Non-Blocking way with the help of Android styles to execute it silently without UI.\n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/ApplyProfileSilentlyTutorial.zip)."},{"key":"guide-tutorial-tutBasicScanningAPI","name":" Basic Scanning Tutorial using Barcode API","md":"# Basic Scanning Tutorial using Barcode API\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use [Barcode/Scanning APIs](#guide-reference-EMDKList) introduced in EMDK V 3.0, to perform Scanning operations on your Symbol Android devices without using Profile Wizard. The API uses [Barcode Manager](#api-BarcodeManager), which is the primary object to access barcode scanning feature. \n\nIn this tutorial, we will explore the [Barcode/Scanning API](#guide-reference-EMDKList) by using it for developing a basic application that will scan barcodes.\n\n> Note: You don't need the Profile Wizard while using the Barcode/Scanning APIs as everything could be configured programmatically through code.   \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"BasicScanningTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK to scan the barcodes.\n  \n    ![img](images/BasicScanningTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\" /> \n\n    Then you must enable the library for EMDK:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/BasicScanningTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.EMDKManager;\n\t\timport com.symbol.emdk.EMDKManager.EMDKListener;\n\t\timport com.symbol.emdk.barcode.ScanDataCollection;\n\t\timport com.symbol.emdk.barcode.Scanner.DataListener;\n\t\timport com.symbol.emdk.barcode.Scanner.StatusListener;\n\t\timport com.symbol.emdk.barcode.StatusData;   \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.\n\n    After that you also need to implement StatusListener for notifying client applications to notify scan events. Override its `onStatus` function.\n\n    Finally implement DataListener for notifying client applications when the scan data is available. Override its `onData` function. \n\n\t> Note: If you are using Android Studio, press CTRL+ALT+O or CMD+ALT+O to organize imports.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+O or CMD+SHFT+O to organize imports.\n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener, StatusListener, DataListener{  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }\n\n            @Override\n\t        public void onData(ScanDataCollection scanDataCollection) {\n\t\t           // TODO Auto-generated method stub\n\t        }\n\n\t        @Override\n\t        public void onStatus(StatusData statusData) {\n\t\t           // TODO Auto-generated method stub\n\t        }  \n          \n        }      \n\n    We will now create some global variables to hold the instance objects of EMDKManager, BarcodeManager and Scanner. These variables would be used throughout the code.\n\n    We will then add some UI elements starting with a [TextView](http://developer.android.com/reference/android/widget/TextView.html) to display the status of scanning operation and then [EditText](http://developer.android.com/reference/android/widget/EditText.html) to populate scanned barcode data.\n \n    \n        :::java\n        // Declare a variable to store EMDKManager object\n\t\tprivate EMDKManager emdkManager = null;\n\t\n\t\t// Declare a variable to store Barcode Manager object\n\t\tprivate BarcodeManager barcodeManager = null;\n\t\n\t\t// Declare a variable to hold scanner device to scan\n\t\tprivate Scanner scanner = null;\n\t\n\t\t// Text view to display status of EMDK and Barcode Scanning Operations\n\t\tprivate TextView statusTextView = null;\n\t\n\t\t// Edit Text that is used to display scanned barcode data\n\t\tprivate EditText dataView = null;\n\n    The code till here looks like:\n    ![img](images/BasicScanningTutorialImages/variables_added.jpg) \n\n2. Now, let us design the simple UI that has a [TextView](http://developer.android.com/reference/android/widget/TextView.html) to display the status of scanning operation and above that an [EditText](http://developer.android.com/reference/android/widget/EditText.html) to populate scanned barcode data.\n\n    So, remove all the code, inside \"res/layout/activity_main.xml\" and add following XML layout code for UI.\n\n        :::xml\n        <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:padding=\"16dip\"\n        tools:context=\".MainActivity\" >\n\n          <EditText\n          android:id=\"@+id/editText1\"\n          android:layout_width=\"wrap_content\"\n          android:layout_height=\"wrap_content\"\n          android:layout_above=\"@+id/textViewStatusTitle\"\n          android:layout_centerHorizontal=\"true\"\n          android:ems=\"10\"\n          android:fadeScrollbars=\"true\"\n          android:inputType=\"none|textMultiLine\" />\n\n          <TextView\n          android:id=\"@+id/textViewStatus\"\n          android:layout_width=\"wrap_content\"\n          android:layout_height=\"wrap_content\"\n          android:layout_centerInParent=\"true\"\n          android:text=\"\" />\n\n          <TextView\n          android:id=\"@+id/textViewStatusTitle\"\n          android:layout_width=\"wrap_content\"\n          android:layout_height=\"wrap_content\"\n          android:layout_above=\"@+id/textViewStatus\"\n          android:layout_centerHorizontal=\"true\"\n          android:layout_marginBottom=\"15dp\"\n          android:text=\"Status:\" />\n\n        </RelativeLayout>\n\n    > Note: Press CTRL+SHFT+F or CMD+SHFT+F for indentation.     \n \n3. In the onCreate method, we take reference of UI elements that are declared in \"res/layout/activity_main.xml\" in order to use them in our [Activity](http://developer.android.com/reference/android/app/Activity.html). We then call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        // Reference to UI elements\n\t\tstatusTextView = (TextView) findViewById(R.id.textViewStatus);\n\t\tdataView = (EditText) findViewById(R.id.editText1);\n\n\t\t// The EMDKManager object will be created and returned in the callback.\n\t\tEMDKResults results = EMDKManager.getEMDKManager(\n\t\t\t\tgetApplicationContext(), this);\n\t\t// Check the return status of getEMDKManager and update the status Text\n\t\t// View accordingly\n\t\tif (results.statusCode != EMDKResults.STATUS_CODE.SUCCESS) {\n\t\t\tstatusTextView.setText(\"EMDKManager Request Failed\");\n\t\t}\n\n    So the complete `onCreate` method looks like:\n     \n     ![img](images/BasicScanningTutorialImages/on_create_added.jpg)\n\n4. We will write a method `initializeScanner` to initialize and enable the scanner and its listeners by using [Barcode Manager](#api-BarcodeManager) object. The `enable` method enables the scanner hardware. This method does not make the scanner to scan or turn on the laser. Basically it will make the scanner device available for your application. If the same of scanner is enabled by other applications, this will throws ScannerExceptions. You must call `disable()` when you are done the scanning, otherwise it will remain locked and be unavailable to other applications.\n\n\tOnce the barcode is enabled, we will call `read` method on scanner. The scanning API provides `read` method that starts an asynchronous Scan. The method will not turn ON the scanner. It will, however, put the scanner in a state in which the scanner can be turned ON either by pressing a hardware trigger or can be turned ON automatically. This is determined by the `Scanner.TriggerType`. The data notification must registered in order to scan and get the Scan Data. The read request can be canceled by issuing a `cancelRead`. If a `read()` is submitted while another read is pending, the method call will fail. It is recommended to check whether a read is pending by calling `isReadPending()` before submitting a `read()`. A read() can also be submitted from within `onData` and `onStatus` events. If called within `onStatus`, it should be called only when IDLE status is received. If called within `onData`, then checking for `isReadPending()` is recommended.\n\n\t> Note: The `read` method allows you to scan the barcode only once. If you want to scan the barcodes multiple times then call `read` multiple times. Hence later in this tutorial, we will also call `read` in the `onData` callback method, which is executed every time a barcode is scanned. \n\n\n        :::java\n        // Method to initialize and enable Scanner and its listeners\n\t\tprivate void initializeScanner() throws ScannerException {\n\t\n\t\t\tif (scanner == null) {\n\t\n\t\t\t\t// Get the Barcode Manager object\n\t\t\t\tbarcodeManager = (BarcodeManager) this.emdkManager\n\t\t\t\t\t\t.getInstance(FEATURE_TYPE.BARCODE);\n\t\n\t\t\t\t// Get default scanner defined on the device\n\t\t\t\tscanner = barcodeManager.getDevice(DeviceIdentifier.DEFAULT);\n\t\n\t\t\t\t// Add data and status listeners\n\t\t\t\tscanner.addDataListener(this);\n\t\t\t\tscanner.addStatusListener(this);\n\t\n\t\t\t\t// Hard trigger. When this mode is set, the user has to manually\n\t\t\t\t// press the trigger on the device after issuing the read call.\n\t\t\t\tscanner.triggerType = TriggerType.HARD;\n\t\n\t\t\t\t// Enable the scanner\n\t\t\t\tscanner.enable();\n\t\n\t\t\t\t// Starts an asynchronous Scan. The method will not turn ON the\n\t\t\t\t// scanner. It will, however, put the scanner in a state in which\n\t\t\t\t// the scanner can be turned ON either by pressing a hardware\n\t\t\t\t// trigger or can be turned ON automatically.\n\t\t\t\tscanner.read();\n\t\t\t}\n\t\t}\n\n    The `initializeScanner` method looks like:\n     \n     ![img](images/BasicScanningTutorialImages/initialize_scanner_method.jpg)\n\n5. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the earlier steps. We have used that instance to get an instance [Barcode Manager](#api-BarcodeManager) to enable scanning.\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        this.emdkManager = emdkManager;\n\n\t\ttry {\n\t\t\t// Call this method to enable Scanner and its listeners\n\t\t\tinitializeScanner();\n\t\t} catch (ScannerException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Toast to indicate that the user can now start scanning\n\t\tToast.makeText(MainActivity.this,\n\t\t\t\t\"Press Hard Scan Button to start scanning...\",\n\t\t\t\tToast.LENGTH_SHORT).show();  \n\n    Your complete onOpened method should now look like this:\n    \n    ![img](images/BasicScanningTutorialImages/on_opened_method.jpg)\n\n6. As mentioned earlier that whenever a barcode is scanned, its data will be received in a callback `onData` method upon data availability. So we need to get that data, process it in the format we want and populate in the [EditText](http://developer.android.com/reference/android/widget/EditText.html) of UI.\n\n    The received data should be processed on a background thread not to block the UI thread. Hence we will use Android's own [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) to process the scanned data on background thread. So we create AsyncTask `AsyncDataUpdate` that takes [ScanDataCollection](#api-ScanDataCollection), which has the scanned data. It then processes this object in `doInBackground` method to filter the barcode data and label type in strings, which is then passed to the UI thread in `onPostExecute` method of AsyncTask to Populate.\n\n\tAs mentioned earlier we would call `read` method here in this callback so that the user can scan multiple barcodes.\n\n        :::java\n        // Update the scan data on UI\n\t\tint dataLength = 0;\n\t\n\t\t// AsyncTask that configures the scanned data on background\n\t\t// thread and updated the result on UI thread with scanned data and type of\n\t\t// label\n\t\tprivate class AsyncDataUpdate extends\n\t\t\t\tAsyncTask<ScanDataCollection, Void, String> {\n\t\n\t\t\t@Override\n\t\t\tprotected String doInBackground(ScanDataCollection... params) {\n\t\n\t\t\t\t// Status string that contains both barcode data and type of barcode\n\t\t\t\t// that is being scanned\n\t\t\t\tString statusStr = \"\";\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\t// Starts an asynchronous Scan. The method will not turn ON the\n\t\t\t\t\t// scanner. It will, however, put the scanner in a state in\n\t\t\t\t\t// which\n\t\t\t\t\t// the scanner can be turned ON either by pressing a hardware\n\t\t\t\t\t// trigger or can be turned ON automatically.\n\t\t\t\t\tscanner.read();\n\t\n\t\t\t\t\tScanDataCollection scanDataCollection = params[0];\n\t\n\t\t\t\t\t// The ScanDataCollection object gives scanning result and the\n\t\t\t\t\t// collection of ScanData. So check the data and its status\n\t\t\t\t\tif (scanDataCollection != null\n\t\t\t\t\t\t\t&& scanDataCollection.getResult() == ScannerResults.SUCCESS) {\n\t\n\t\t\t\t\t\tArrayList<ScanData> scanData = scanDataCollection\n\t\t\t\t\t\t\t\t.getScanData();\n\t\n\t\t\t\t\t\t// Iterate through scanned data and prepare the statusStr\n\t\t\t\t\t\tfor (ScanData data : scanData) {\n\t\t\t\t\t\t\t// Get the scanned data\n\t\t\t\t\t\t\tString barcodeDate = data.getData();\n\t\t\t\t\t\t\t// Get the type of label being scanned\n\t\t\t\t\t\t\tLabelType labelType = data.getLabelType();\n\t\t\t\t\t\t\t// Concatenate barcode data and label type\n\t\t\t\t\t\t\tstatusStr = barcodeDate + \" \" + labelType;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t} catch (ScannerException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\n\t\t\t\t// Return result to populate on UI thread\n\t\t\t\treturn statusStr;\n\t\t\t}\n\t\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(String result) {\n\t\t\t\t// Update the dataView EditText on UI thread with barcode data and\n\t\t\t\t// its label type\n\t\t\t\tif (dataLength++ > 50) {\n\t\t\t\t\t// Clear the cache after 50 scans\n\t\t\t\t\tdataView.getText().clear();\n\t\t\t\t\tdataLength = 0;\n\t\t\t\t}\n\t\t\t\tdataView.append(result + \"\\n\");\n\t\t\t}\n\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t}\n\t\n\t\t\t@Override\n\t\t\tprotected void onProgressUpdate(Void... values) {\n\t\t\t}\n\t\t}\n\n    We call this AsyncTask in overridden `onData` method, by creating an instance of `AsyncDataUpdate` and passing the `scanDataCollection` for further processing.\n\n        :::java\n        // Use the scanned data, process it on background thread using AsyncTask\n\t\t// and update the UI thread with the scanned results\n\t\tnew AsyncDataUpdate().execute(scanDataCollection);\n\n    So the `onData` method and `AsyncDataUpdate` looks like:\n\n    ![img](images/BasicScanningTutorialImages/async_data_update.jpg)\n\n\t![img](images/BasicScanningTutorialImages/async_data_update_remaining_1.jpg)\n\n\tand here is the remaining part of the `AsyncDataUpdate`.\n\n\t![img](images/BasicScanningTutorialImages/async_data_update_remaining_2.jpg)\n\n\t> Note: The `AsyncDataUpdate` has been divided into multiple screen captures due to long body.\n  \n7. Whether we scan the barcode by pressing the hard scan key or keep it idle, it returns the status of the scanner at specific point of time in the overridden `onStatus` method of implemented `StatusListener` interface. Since we are also displaying the status along with barcode data, we will make use of this method and populate the status.\n\n    Just like scanned data, we are also processing the scanner status on a background thread. Hence we will create another [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) named `AsyncStatusUpdate` that takes [StatusData](#api-StatusData) and processes it in `doInBackground` method to retrieve state in string format which is populated in status Text View on UI thread in `onPostExecute` method of the AsyncTask.              \n\n        :::java\n        // AsyncTask that configures the current state of scanner on background\n\t\t// thread and updates the result on UI thread\n\t\tprivate class AsyncStatusUpdate extends AsyncTask<StatusData, Void, String> {\n\t\n\t\t\t@Override\n\t\t\tprotected String doInBackground(StatusData... params) {\n\t\t\t\tString statusStr = \"\";\n\t\t\t\t// Get the current state of scanner in background\n\t\t\t\tStatusData statusData = params[0];\n\t\t\t\tScannerStates state = statusData.getState();\n\t\t\t\t// Different states of Scanner\n\t\t\t\tswitch (state) {\n\t\t\t\t// Scanner is IDLE\n\t\t\t\tcase IDLE:\n\t\t\t\t\tstatusStr = \"The scanner enabled and its idle\";\n\t\t\t\t\tbreak;\n\t\t\t\t// Scanner is SCANNING\n\t\t\t\tcase SCANNING:\n\t\t\t\t\tstatusStr = \"Scanning..\";\n\t\t\t\t\tbreak;\n\t\t\t\t// Scanner is waiting for trigger press\n\t\t\t\tcase WAITING:\n\t\t\t\t\tstatusStr = \"Waiting for trigger press..\";\n\t\t\t\t\tbreak;\n\t\t\t\t// Scanner is not enabled\n\t\t\t\tcase DISABLED:\n\t\t\t\t\tstatusStr = \"Scanner is not enabled\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\n\t\t\t\t// Return result to populate on UI thread\n\t\t\t\treturn statusStr;\n\t\t\t}\n\t\n\t\t\t@Override\n\t\t\tprotected void onPostExecute(String result) {\n\t\t\t\t// Update the status text view on UI thread with current scanner\n\t\t\t\t// state\n\t\t\t\tstatusTextView.setText(result);\n\t\t\t}\n\t\n\t\t\t@Override\n\t\t\tprotected void onPreExecute() {\n\t\t\t}\n\t\n\t\t\t@Override\n\t\t\tprotected void onProgressUpdate(Void... values) {\n\t\t\t}\n\t\t}\n\n    We call this AsyncTask in overridden `onStatus` method, by creating an instance of `AsyncStatusUpdate` and passing the `StatusData` for further processing.\n\n        :::java\n        // process the scan status event on the background thread using\n\t\t// AsyncTask and update the UI thread with current scanner state\n\t\tnew AsyncStatusUpdate().execute(statusData);\n\n    So the `onStatus` method and `AsyncStatusUpdate` looks like:\n\n    ![img](images/BasicScanningTutorialImages/async_status_update.jpg)\n\n\tand here is the remaining part of the `AsyncStatusUpdate`.\n\n\t![img](images/BasicScanningTutorialImages/async_status_update_remaining.jpg)\n\n\t> Note: The `AsyncStatusUpdate` has been divided into multiple screen captures due to long body.\n\n8. Now let's override the `onDestroy` method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override\n\t    protected void onDestroy() {\n\t\t super.onDestroy();\n\t\t if (emdkManager != null) {\n\n\t\t\t// Clean up the objects created by EMDK manager\n\t\t\temdkManager.release();\n\t\t\temdkManager = null;\n\t\t }\n\t    } \n\n    Your `onDestroy` method should now look like this:  \n\n    ![img](images/BasicScanningTutorialImages/on_destroy_method.jpg)\n\n9. When we are done with scanning, we must release the scanner hardware resources for other applications to use. So override `onStop` method and disable the scanner to release it.\n\n        :::java\n        @Override\n\t    protected void onStop() {\n\t\t  // TODO Auto-generated method stub\n\t\t  super.onStop();\n\t\t  try {\n\t\t\tif (scanner != null) {\n\t\t\t\t// releases the scanner hardware resources for other application\n\t\t\t\t// to use. You must call this as soon as you're done with the\n\t\t\t\t// scanning.\n\t\t\t\tscanner.disable();\n\t\t\t\tscanner = null;\n\t\t\t}\n\t\t  } catch (ScannerException e) {\n\t\t\te.printStackTrace();\n\t\t  }\n\t    }\n\n    Your `onStop` method should now look like this:  \n\n    ![img](images/BasicScanningTutorialImages/on_stop_method.jpg) \n\n10. Finally, Clean up the objects created by EMDK manager in `onClosed` method, if EMDK closed abruptly.\n\n        :::java\n        // The EMDK closed abruptly. // Clean up the objects created by EMDK\n\t\t// manager\n\t\tif (this.emdkManager != null) {\n\n\t\t\tthis.emdkManager.release();\n\t\t\tthis.emdkManager = null;\n\t\t}\n\n    Your `onClosed` method should now look like this:  \n\n    ![img](images/BasicScanningTutorialImages/on_closed_method.jpg)\n\t\nThat's it!!! We are done with all the coding part that will let us scan the barcodes of configured decoder params on Symbol Android device using [Barcode/Scanning APIs](#guide-reference-EMDKList) introduced in EMDK V 3.0. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n \n2. Run the application.\n\n    ![img](images/BasicScanningTutorialImages/home_screen.png)\n\n    You can see a [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html), which indicates that the Scanner has been enabled and you can start scanning by pressing hard scan button of the device.\n  \n3. Now if you press the hard scan button, the status listener in the code starts working and current status of Scanner is displayed in Status [TextView](http://developer.android.com/reference/android/widget/TextView.html), which is `Scanning`.  \n\n    ![img](images/BasicScanningTutorialImages/status_scanning.png)\n\n4. Once you are done with scanning and release the hard scan button, data gets populated on [EditText](http://developer.android.com/reference/android/widget/EditText.html) and status is again updated in Status [TextView](http://developer.android.com/reference/android/widget/TextView.html), which is `Idle`.\n\n    ![img](images/BasicScanningTutorialImages/status_idle.png)  \n\n    This is how [Barcode/Scanning APIs](#guide-reference-EMDKList) introduced in EMDK V 3.0 can be used to perform Basic Scanning operations on your Symbol devices without using Profile Wizard. We will see the [Barcode/Scanning APIs](#guide-reference-EMDKList) in depth to perform advanced scanning operations in the next tutorial. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to perform Basic Scanning operations on your Symbol Android devices through applications without using Profile Wizard, let us try to understand the API in depth and perform some advanced scanning. So in the next tutorial, we will concentrate on [Barcode/Scanning APIs](#guide-reference-EMDKList) in depth and use it to perform advanced scanning operations by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/BasicScanningTutorial.zip)."},{"key":"guide-tutorial-tutbatteryintent","name":" Battery Intent Tutorial","md":"# Battery Intent Tutorial\n\n## Overview\nOn Symbol devices like the MC40, extra battery information can be retrieved using the standard [Android Battery Intent](http://developer.android.com/training/monitoring-device-state/battery-monitoring.html). Setting up to receive this information is the same as with consumer Android devices. However, the data that is returned to your application includes some extra information like:\n\n* Backup Battery Voltage\n* Battery Manufacture Date\n* Battery Serial Number\n* Part Number for Battery\n* Unique ID for Battery\n* Rated Capacity of the Battery\n* Charge Cycle count of the Battery \n\n## Enabling the Receiver \n\n\t:::java\n\tmIntent_Receiver = new Intent_Receiver();  \n\tmIntentFilter = new IntentFilter();  \n\tmIntentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);  \n\tregisterReceiver(mIntent_Receiver,mIntentFilter);  \n\n## Processing The Data\nIn the below code we are getting the Symbol specific battery information provided by the [Battery Intent](#guide-reference-refbatteryintent) extras. Notice that some values are strings and other values are integers.\n\n\t:::java\n\tpublic void onReceive(Context context, Intent intent) {      \n\t\tif (BATTERY_STATE_CHANGED_INTENT.equals(intent.getAction())) {          \n\t\t\tint bkvoltage = intent.getExtras().getInt(\"bkvoltage\");  \n\t\t\tString mfd = intent.getExtras().getString(\"mfd\");  \n\t\t\tString serialnumber = intent.getExtras().getString(\"serialnumber\");  \n\t\t\tString partnumber = intent.getExtras().getString(\"partnumber\");  \n\t\t\tString uniqueid = intent.getExtras().getString(\"uniqueid\");  \n\t\t\tint ratedcapacity = intent.getExtras().getInt(\"ratedcapacity\");  \n\t\t\tint cycle = intent.getExtras().getInt(\"cycle\");  \n\t\t}  \n\t} \n\n## Downloading the Sample\nDownload the source for this project in the [associated sample](#guide-sample-samplebatteryintent)."},{"key":"guide-tutorial-tutBluetoothScannerAPI","name":" Pairing with Bluetooth Scanning device using Bluetooth Scanner API","md":"# Pairing with Bluetooth Scanning device using Bluetooth Scanner API\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use [Bluetooth Scanner API](#guide-reference-EMDKList?Barcode%20APIs) introduced in EMDK V 3.1, to perform pairing with Bluetooth Scanning device using Bluetooth Pairing Utility of Bluetooth Scanner API.\n\n> Note: The Bluetooth Scanner API is a part of [Barcode API](#guide-reference-EMDKList?Barcode%20APIs).  \n\nInitially, the Bluetooth Scanner is not connected to the device. So the Bluetooth Pairing Utility would turn ON the Bluetooth of the device where the app is running (Ex. TC55) if not already turned ON. Once that is done, the utility will ask you to scan a Barcode in the app using Bluetooth Scanner (Ex. RS507). After scanning the Barcode, the utility will start pairing process and pair the Bluetooth Scanning device (Ex. RS507) with your device where the app is running (Ex. TC55). \n\nIn this tutorial, we will explore the [Bluetooth Scanner API](#guide-reference-EMDKList?Barcode%20APIs) by using it for developing a basic application that will pair the device with Bluetooth Scanner by allowing Bluetooth Scanner to scan the Barcode in the app through Bluetooth Pairing Utility.\n\n> Note: The [Bluetooth Scanner API](#guide-reference-EMDKList?Barcode%20APIs) does not use Profile Wizard to pair with Bluetooth Scanner and everything needs to be configured programmatically through code.   \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.1 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"BluetoothScannerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK to scan the barcodes.\n  \n    ![img](images/BluetoothScannerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\" /> \n\n    Then you must enable the library for EMDK:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/BluetoothScannerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.EMDKManager;\n\t\timport com.symbol.emdk.barcode.BarcodeManager;  \n\n    Then you must make the activity to implement [EMDKListener](#api-EMDKManager-EMDKListener). Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.\n\n    After that you also need to implement [BarcodeManager.ScannerConnectionListener](#api-BarcodeManager-ScannerConnectionListener), which is an interface to notify the client when the scanner device (Ex. RS507) has been connected or disconnected to the mobile device (Ex. TC55). Override its `onConnectionChange` method, which would be called when the scanner gets connected or disconnected to the mobile device. \n\n\t> Note: If you are using Android Studio, press CTRL+ALT+O or CMD+ALT+O to organize imports.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+O or CMD+SHFT+O to organize imports.\n    \n        :::java\n        public class MainActivity extends Activity EMDKManager.EMDKListener, BarcodeManager.ScannerConnectionListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override\n    \t\tpublic void onOpened(EMDKManager emdkManager) {\n\n    \t\t}\n\n    \t\t@Override\n    \t\tpublic void onClosed() {\n\n    \t\t}\n\n    \t\t@Override\n    \t\tpublic void onConnectionChange(ConnectionStatus connectionStatus) {\n\n    \t\t}  \n          \n        }      \n    \n\tWe will now create some global variables to hold the instance objects of EMDKManager and BarcodeManager. These variables would be used throughout the code.\n\n    We will then add some UI elements, which is just a [TextView](http://developer.android.com/reference/android/widget/TextView.html) for notifying intermediate status operations performed during pairing.      \n \n    \n        :::java\n\t    // Text View to display status during pairing operation\n\t    private TextView statusView = null;\n\t\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\t\n\t    // Declare a variable to store Barcode Manager object\n\t    private BarcodeManager barcodeManager = null;\n\t\n\t    // Declare a variable to hold scanner device to scan\n\t\tprivate Scanner scanner = null;\n\n    The code till here looks like:\n\n    ![img](images/BluetoothScannerTutorialImages/variables_added.jpg)\n\t \n\n2. Now, let us design a simple UI that has simply has a [TextView](http://developer.android.com/reference/android/widget/TextView.html) to indicate status during pairing operation.\n\n    So, remove all the code, inside \"res/layout/activity_main.xml\" and add following XML layout code for UI.\n\n        :::xml\n        <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    \txmlns:tools=\"http://schemas.android.com/tools\"\n    \tandroid:layout_width=\"match_parent\"\n    \tandroid:layout_height=\"match_parent\"\n    \tandroid:padding=\"16dip\"\n    \ttools:context=\".MainActivity\" >\n\n    \t  <TextView\n           android:id=\"@+id/textViewStatus\"\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"wrap_content\"\n           android:layout_centerInParent=\"true\"\n           android:text=\"\" />\n\n    \t  <TextView\n           android:id=\"@+id/textViewStatusTitle\"\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"wrap_content\"\n           android:layout_above=\"@+id/textViewStatus\"\n           android:layout_centerHorizontal=\"true\"\n           android:layout_marginBottom=\"15dp\"\n           android:text=\"Status:\" />\n\n\t\t</RelativeLayout>\n\n\tThe layout should look like:\n\n    ![img](images/BluetoothScannerTutorialImages/layout_added.jpg)\n\n    > Note: If you are using Android Studio, press CTRL+ALT+I or CMD+ALT+I to auto indent lines.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+F or CMD+SHFT+F to auto indent lines     \n \n3. In the `onCreate` method, we take reference of UI elements that are declared in \"res/layout/activity_main.xml\" in order to use them in our [Activity](http://developer.android.com/reference/android/app/Activity.html). We then call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready.   \n\n        :::java\n        // Reference to UI elements\n        statusView = (TextView) findViewById(R.id.textViewStatus);\n\n        // The EMDKManager object will be created and returned in the callback.\n        EMDKResults results = EMDKManager.getEMDKManager(\n                getApplicationContext(), this);\n\n        // Check the return status of getEMDKManager and update the status Text\n        // View accordingly\n        if (results.statusCode != EMDKResults.STATUS_CODE.SUCCESS) {\n            statusView.setText(\"Status: \"\n                    + \"EMDKManager object request failed!\");\n        }\n\n    So the complete `onCreate` method looks like:\n     \n    ![img](images/BluetoothScannerTutorialImages/on_create_added.jpg)\n\n4. Get the [EMDK Manager](#api-EMDKManager) in the `onOpened` method, update the `StatusView` TextView with a message and add the [ScannerConnectionListener](BarcodeManager-ScannerConnectionListener) to get the Connected/Disconnected events between Bluetooth Scanner and Mobile by adding following code in `onOpened` method.\n\n\t\t:::java\n\t\t// Update status view with EMDK Open Success message\n        statusView.setText(\"Status: \" + \"EMDK open success!\");\n\n        this.emdkManager = emdkManager;\n        // Get the Barcode Manager Instance\n        barcodeManager = (BarcodeManager) emdkManager\n                .getInstance(EMDKManager.FEATURE_TYPE.BARCODE);\n        // Add the Scanner Connection Listener to receive Connected/Disconnected events\n        if (barcodeManager != null) {\n            barcodeManager.addConnectionListener(this);\n        }\n\n\t\t// Initialize Scanner\n        initScanner();\n\n\tThe `onOpened` method should look like: \n\t\n\t![img](images/BluetoothScannerTutorialImages/on_opened_method.jpg)\n\n5. You will see error as we have not added `initScanner` method for initializing Bluetooth Scanner of our mobile device (Ex TC55). `initScanner` method gets the number of supported devices in a list.\n\n\t\t:::java\n\t\tList<ScannerInfo> deviceList = barcodeManager\n                    .getSupportedDevicesInfo();\n\n\tIt then iterates through this list of devices and checks one with \"Bluetooth Scanner\" by refering friendly name. If the list has Bluetooth Scanner device, it initializes Scanner object with Bluetooth Scanner.\n\n\t\t:::java\n\t\tfor (ScannerInfo scannerInfo : deviceList){\n                if(scannerInfo.getFriendlyName().equalsIgnoreCase(\"Bluetooth Scanner\"))\n                    scanner = barcodeManager.getDevice(scannerInfo);\n        }\n\n\tIf the Scanner Object is still null after iteration, your device doesn't support Bluetooth Scanner. Finally, we enable the Bluetooth Scanner.\n\n\t\t:::java\n\t\tscanner.enable();\n\n\tSo the complete source code for `initScanner` method would look like:\n\n\t\t:::java\n\t\t// Initialize Bluetooth Scanner\n\t    private void initScanner() {\n\t\n\t        if (scanner == null) {\n\t            // Get a list of supported scanner devices\n\t            List<ScannerInfo> deviceList = barcodeManager\n\t                    .getSupportedDevicesInfo();\n\t\n\t            // Iterate through Scanner devices and check if it supports Bluetooth Scanner\n\t            for (ScannerInfo scannerInfo : deviceList){\n\t                if(scannerInfo.getFriendlyName().equalsIgnoreCase(\"Bluetooth Scanner\"))\n\t                    scanner = barcodeManager.getDevice(scannerInfo);\n\t            }\n\t            // If null, then your device does not support Bluetooth Scanner\n\t            if(scanner == null) {\n\t                statusView.setText(\"Bluetooth Scanner not supported!!!\");\n\t                return;\n\t            }else{\n\t                // Supports Bluetooth Scanner\n\t                try {\n\t                    // Enable the Scanner\n\t                    scanner.enable();\n\t                } catch (ScannerException e) {\n\t                    statusView.setText(\"Status: \" + e.getMessage());\n\t                }\n\t            }\n\t        }\n\t    } \n\n\tThis should look like:\t\n\n\t![img](images/BluetoothScannerTutorialImages/init_scanner.jpg)\n\n6. Now, we will add a method to de-initialize the Scanner named `deInitScanner`. This method will perform following operations in the same sequence.\n\n\t* Cancel any pending read operations.\n\t* Disable the Scanner.\n\t* Release the Scanner resource.\n\t* Eventually set the Scanner object to `null`.\n\n\tThe source code for `deInitScanner` method should look like:\n\n\t\t:::java\n\t\t// DeInitialize Scanner\n\t    private void deInitScanner() {\n\t        if (scanner != null) {\n\t            try {\n\t                // Cancel pending reads\n\t                scanner.cancelRead();\n\t                // Disable Scanner\n\t                scanner.disable();\n\t                // Release Scanner\n\t                scanner.release();\n\t\n\t            } catch (ScannerException e) {\n\t                statusView.setText(\"Status: \" + e.getMessage());\n\t            }\n\t\n\t            scanner = null;\n\t        }\n\t    }\n\n\tThe method should look like:\t\n\n\t![img](images/BluetoothScannerTutorialImages/de_init_scanner.jpg)\n\n7.  Let's add an [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) for asynchronously updating the StatusView. This would be useful in the `onConnectionChange` callback method that updates the status to Connected/Disconnected depending upon the result. So `AsyncStatusUpdate` is an [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) that would simply update the Status View with following code.\n\n\t\t:::java\n\t\t// AsyncTask for Updating Status in statusView during pairing operation\n\t    private class AsyncStatusUpdate extends AsyncTask<String, Void, String> {\n\t\n\t        @Override\n\t        protected String doInBackground(String... params) {\n\t            return params[0];\n\t        }\n\t\n\t        @Override\n\t        protected void onPostExecute(String result) {\n\t            // Update Status View\n\t            statusView.setText(\"Status: \" + result);\n\t        }\n\t    }\n\n\tThe `AsyncStatusUpdate` should look like:\n\n\t![img](images/BluetoothScannerTutorialImages/async_status_update.jpg) \n\n8. We would now add the code to update `statusView` in `onConnectionChange` callback method. This method would be invoked when the scanner device has been connected or disconnected to the mobile device. \n\n\tSo we will first get the connection state and friendly name of the Scanner device received through `onConnectionChange` callback method.\n\n\t\t:::java\n\t\t// Returns the Connection State for Bluetooth Scanner through callback\n        String statusBT = connectionStatus.getConnectionState().toString();\n        // Returns the Friendly Name of the Scanner through callback\n        String scannerNameBT = connectionStatus.getScannerInfo()\n                .getFriendlyName(); \n\n\tIf the friendly name is \"Bluetooth Scanner\", then we would update the statusView with the Scanner Name and its state.\n\n\tLater, if the state is `CONNECTED`, we would invoke `initScanner` method and `deInitScanner` method for the `DISCONNECTED` state.\n\n\tSo the source code for `onConnectionChange` callback method with the above mentioned steps would look like:\n\n\t\t:::java\n\t\t@Override\n\t    public void onConnectionChange(ConnectionStatus connectionStatus) {\n\t        String status = \"\";\n\t        String scannerName = \"\";\n\t\n\t        // Returns the Connection State for Bluetooth Scanner through callback\n\t        String statusBT = connectionStatus.getConnectionState().toString();\n\t        // Returns the Friendly Name of the Scanner through callback\n\t        String scannerNameBT = connectionStatus.getScannerInfo()\n\t                .getFriendlyName();\n\t\n\t        // Get the friendly name of our device's Scanner\n\t        scannerName = scanner.getScannerInfo().getFriendlyName();\n\t\n\t        // Check for the Bluetooth Scanner\n\t        if (scannerName.equalsIgnoreCase(scannerNameBT)) {\n\t            // If Bluetooth Scanner, update the status view\n\t            status = scannerNameBT + \":\" + statusBT;\n\t            new AsyncStatusUpdate().execute(status);\n\t            // Initialize or De-Initialize Bluetooth Scanner\n\t            // device based on Connection State\n\t            switch (connectionStatus.getConnectionState()) {\n\t                case CONNECTED:\n\t                    // Initialize Scanner\n\t                    initScanner();\n\t                    break;\n\t                case DISCONNECTED:\n\t                    // De-Initialize Scanner\n\t                    deInitScanner();\n\t                    break;\n\t            }\n\t        }\n\t    }\n\n\tThe `onConnectionChange` method should look like:\n\n\t![img](images/BluetoothScannerTutorialImages/on_connection_change.jpg)\n\n9. Finally, release all the resources in `onClosed` method. So it would remove the `ScannerConnectionListener` and release the `EMDKManager` using following code.\n\n\t\t:::java\n\t\t@Override\n\t    public void onClosed() {\n\t        if (emdkManager != null) {\n\t            // Remove the connection listener\n\t            if (barcodeManager != null) {\n\t                barcodeManager.removeConnectionListener(this);\n\t            }\n\t            // Release EMDK Manager\n\t            emdkManager.release();\n\t            emdkManager = null;\n\t        }\n\t        statusView\n\t                .setText(\"Status: \"\n\t                        + \"EMDK closed unexpectedly! Please close and restart the application.\");\n\t    } \n\n\tThe `onClosed` method should look like:\n\n\t![img](images/BluetoothScannerTutorialImages/on_closed.jpg)\n  \n      \t\nThat's it!!! We are done with all the coding part that will let us perform pairing with Bluetooth Scanning device using Bluetooth Pairing Utility of [Bluetooth Scanner API](#guide-reference-EMDKList?Barcode%20APIs) introduced in EMDK V 3.1. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n \n2. Run the application.\n\n\t> Note: Initially the bluetooth of the device is turned OFF.\n\n    ![img](images/BluetoothScannerTutorialImages/home_screen.png)\n\n\tSo it displays a [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html) saying bluetooth scanner is not connected, which would start Bluetooth Pairing Utility to pair devices.\n\n3. It will first ask you to enable the Bluetooth of the device.\n\n\t![img](images/BluetoothScannerTutorialImages/enable_bluetooth.png)\n\n4. Click \"Allow\" and the Bluetooth Scanning Utility would turn your device's Bluetooth ON.\n\n\t![img](images/BluetoothScannerTutorialImages/turning_on_bluetooth.png)\n\n5. It would display a screen with a Barcode, which needs to be scanned to pair with this device.\n\n\t![img](images/BluetoothScannerTutorialImages/barcode_screen.png)\n\n6. You can take a Bluetooth Scanning device (Ex RS507) and scan the Barcode shown on the screen of your app (App is on TC55) and Bluetooth Scanning Utility would pair these two devices.\n\n\t![img](images/BluetoothScannerTutorialImages/bluetooth_scanner_connected.png)\n\n7. You can see a [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html) confirming that the two devices (TC55 & RS507) have been paired and connected to each other along with the updated status on `statusView`.\n\n8. Now, lets check under Bluetooth Settings of the Mobile device (TC55) for further confirmation. So go to device's Settings -> Bluetooth.\n\n\t![img](images/BluetoothScannerTutorialImages/devices_paired.png)\n\n9. You can see RS507 under Paired devices that further confirms pairing. This is how we can perform pairing of Mobile device (Ex. TC55) with Bluetooth Scanning device (Ex. RS507) using Bluetooth Pairing Utility of [Bluetooth Scanner API](#guide-reference-EMDKList?Barcode%20APIs)   \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n\n\n## What's Next\nNow that you have learned how to perform pairing with Bluetooth Scanning device using Bluetooth Pairing Utility of [Bluetooth Scanner API](#guide-reference-EMDKList?Barcode%20APIs), in the next tutorial we would concentrate on [ScanAndPair APIs]((../guide/reference/EMDKList?ScanAndPair%20APIs)) and develop an application to demonstrate its use. \n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)]().\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/BluetoothScannerTutorial.zip)."},{"key":"guide-tutorial-tutCreateProjectAndroidStudio","name":" Creating Project using Android Studio","md":"# Creating Project using Android Studio\n## Overview\n\nThis tutorial helps you creating a new Android application project using [Android Studio](http://developer.android.com/sdk/index.html). This is going to be a common step for all the tutorials that use [EMDK for Android](https://developer.motorolasolutions.com/community/android/emdk) API.\n\n\n## Creating The Project \n\n1. If you have launched a fresh Android Studio, it should look like this:\n\n\t![img](images/CreatingProjectAndroidStudioImages/fresh_launch.jpg)\n\n\tSo just click the first button \"Start a new Android Studio project\" under \"Quick Start\" section.\n\n\t![img](images/CreatingProjectAndroidStudioImages/create_new_project_from_fresh.jpg)\n\n2. If you already have some open project in Android Studio, it should look like:\n\n\t![img](images/CreatingProjectAndroidStudioImages/existing_open_project.jpg)\n\n\tClick on the \"File\" button at the top left and select \"New Project\" option.\n\n\t![img](images/CreatingProjectAndroidStudioImages/create_new_project_from_existing.jpg)\n\n3. This would pop up the project creation screen where you need to specify project details.\n\n\t![img](images/CreatingProjectAndroidStudioImages/create_new_project_from_existing.jpg)\n\n4. Assign Application Name specific to your tutorial of EMDK feature along with Company Domain and click \"Next\".\n\n\t![img](images/CreatingProjectAndroidStudioImages/app_name.jpg)\n\n\t\n5. Select `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` depending on the project/EMDK feature requirement and click \"Next\".\n\n\t![img](images/CreatingProjectAndroidStudioImages/select_minimum_sdk.jpg)\n\n6. Select \"Blank Activity\" option on \"Add an activity to Mobile\" screen and click \"Next\".\n\n\t![img](images/CreatingProjectAndroidStudioImages/blank_activity.jpg)\n\n7. Click \"Finish\" and your new Android Studio project will be created.\n\n\t![img](images/CreatingProjectAndroidStudioImages/create_project_finish.jpg)\n\n\t![img](images/CreatingProjectAndroidStudioImages/main_activity.jpg)\n\n\t>Note: The `\\assets` folder is not present in the project structure by default unless you have created any profile. But, you can add it by simply right clicking the `app` directory and selecting `Assets Folder` under `Folder` option. \n\n\t![img](images/CreatingProjectAndroidStudioImages/add_assets_folder.jpg)\n\n\t![img](images/CreatingProjectAndroidStudioImages/assets_folder_creating.jpg)\n\n\tClick \"Finish\" and this is how `\\assets` folder can be manually added to the project structure. \n\n\t![img](images/CreatingProjectAndroidStudioImages/assets_folder_created.jpg)\n\n"},{"key":"guide-tutorial-tutCreateProjectEclipseADT","name":" Creating Project using Eclipse with ADT","md":"# Creating Project using Eclipse with ADT\n## Overview\n\nThis tutorial helps you creating a new Android application project using Eclipse ADT. This is going to be a common step for all the tutorials that use [EMDK for Android](https://developer.motorolasolutions.com/community/android/emdk) API.\n\n> Note:\n> If you have been using Eclipse with ADT, be aware that [Android Studio](http://developer.android.com/sdk/index.html) is now the official IDE for Android, so you should migrate to [Android Studio](http://developer.android.com/sdk/index.html) to receive all the latest IDE updates. Click [here](#guide-tutorial-tutCreateProjectAndroidStudio) to create a new Android application project using Android Studio.\n\n\n## Creating The Project\n1.  Create new Android Application project.\n  \n    ![img](images/CreatingProjectEclipseIDEImages/create_new_app.jpg)\n\n2.  Assign names for the application and package specific to your tutorial of EMDK feature.\n \n3.  Set the minimum required SDK to \"API 16: Android 4.1 (Jelly Bean)\".\n  \n    ![img](images/CreatingProjectEclipseIDEImages/set_app_name.jpg)\n\n4.  Click \"Next\".\n  \n    ![img](images/CreatingProjectEclipseIDEImages/configure_project.jpg)\n  \n5.  Click \"Next\".\n  \n    ![img](images/CreatingProjectEclipseIDEImages/configure_launcher_icon.jpg)\n  \n6.  Click \"Next\".  \n\n7.  Select \"Empty Activity\" Click \"Next\".  \n\n    ![img](images/CreatingProjectEclipseIDEImages/create_activity.jpg)  \n\n    >Note:  \n    >If \"Empty Activity\" is not available make sure you are using \"Android SDK Tools 22.6.3\" and \"Android SDK Platform Tools 19.0.2\"\n\n7.  Click \"Next\".  \n\n    ![img](images/CreatingProjectEclipseIDEImages/empty_activity.jpg)\n  \n8.  Click \"Finish\".\n\n    >Note:  \n    >Currently there is nothing under \"\\assets\" folder.  \n    \n    ![img](images/CreatingProjectEclipseIDEImages/main_activity.jpg)\n\n\n"},{"key":"guide-tutorial-tutdatacaptureintent","name":" Data Capture Intents Tutorial","md":"# Data Capture Intents Tutorial\n\n## Overview\nDataWedge on Android has the ability to output captured data via Intents. This article describes how to use the DataWedge Intent output plug-in and the Data Capture API to receive captured data in your native Android application.\n\nKnowledge of Android programming and familiarity with the Android intent mechanism are assumed. Also assumed is some familiarity with DataWedge and that you have read the DataWedge section in the Integrator Guide for your device.\n \n## Application Layout\nFor this article we created an Android application with a blank activity using Eclipse, to which we added the following layout.\n\n    :::xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>  \n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n        android:layout_width=\"fill_parent\"  \n        android:layout_height=\"fill_parent\"  \n        android:orientation=\"vertical\" >  \n        <LinearLayout  \n            android:layout_width=\"fill_parent\"  \n            android:layout_height=\"wrap_content\"  \n            android:orientation=\"horizontal\" >  \n            <ImageView  \n                android:id=\"@+id/logo\"  \n                style=\"@style/logo\"  \n                android:contentDescription=\"@string/title\" />  \n            <LinearLayout  \n                android:layout_width=\"fill_parent\"  \n                android:layout_height=\"wrap_content\"  \n                android:orientation=\"vertical\" >  \n                <TextView style=\"@style/title\" />  \n                <TextView style=\"@style/copyright\" />  \n            </LinearLayout>  \n        </LinearLayout>  \n        <View style=\"@style/hr\" />  \n        <TextView style=\"@style/intro\" />  \n        <EditText  \n            android:id=\"@+id/editbox\"  \n            style=\"@style/editbox\"  \n            android:inputType=\"textMultiLine\"  \n            />  \n    </LinearLayout> \n\nThe things to note in the above layout are the ImageView and the EditText widgets.  The ImageView widget will effectively act as a button which can be used to toggle the scanner instead of pressing the trigger button on the device. The EditText widget will be used to display the data that we receive in the intent.\n \n## Intent Strings\nThe intent we will receive from DataWedge will contain a bundle of data which we will be retrieving using the Intent.getStringtExtra() and Intent.getSerializableExtra() methods.  \n\n### Data Items\nThe following is a list of the data item names that the bundle could contain.\n\n* String SOURCE_TAG = \"com.motorolasolutions.emdk.datawedge.source\";\n* String contains the source of the data i.e. scanner or MSR\n* String DATA_STRING_TAG = \"com.motorolasolutions.emdk.datawedge.data_string\";\n    * String contains the output data as a String. In the case of concatenated bar codes, the decode data is concatenated and sent out as a single string. In the case of MSR output, the data from the MSR tracks is concatenated and sent out as a single string.\n* String LABEL_TYPE_TAG = \"com.motorolasolutions.emdk.datawedge.label_type\";\n* String contains the label type of the bar code.\n* String DECODE_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.decode_data\";\n    * Decode data returned as a list of byte arrays. In most cases there will be one byte array per decode. For bar-code symbologies that support concatenation e.g. Codabar, Code128, MicroPDF, etc., the decoded data is stored in multiple byte arrays (one byte array per bar code). Clients can get data in each byte array by passing an index.\n\n### MSR Intent Names\nLet's list the MSR intent names (in case we want to use these in the future).\nThe MSR related data added to the intent's bundle can be retrieved using the Intent.getStringtExtra() and Intent.getSerializableExtra() calls, using the following String tags:\n\n* String MSR_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.msr_data\";\n    * The data from the MSR tracks is concatenated and sent out as a byte array.\n* String MSR_TRACK1_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1\";\n    * MSR track 1 data is returned as a byte array.\n* String MSR_TRACK2_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2\";\n    * MSR track 2 data is returned as a byte array.\n* String MSR_TRACK3_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3\";\n    * MSR track 3 data is returned as a byte array.\n* String MSR_TRACK1_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_status\";\n    * MSR track 1 decode status as an Integer where 0 indicates a successful decode.\n* String MSR_TRACK2_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_status\";\n    * MSR track 2 decode status as an Integer where 0 indicates a successful decode.\n* String MSR_TRACK3_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_status\";\n    * MSR track 3 decode status as an Integer where 0 indicates a successful decode.\n* String MSR_TRACK1_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_encrypted\";\n    * MSR track 1 encrypted data is returned as a byte array.\n* String MSR_TRACK2_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_encrypted\";\n    * MSR track 2 encrypted data is returned as a byte array.\n* String MSR_TRACK3_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_encrypted\";\n    * MSR track 3 encrypted data is returned as a byte array.\n* String MSR_TRACK1_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_hashed\";\n    * MSR track 1 hashed data is returned as a byte array.\n* String MSR_TRACK2_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_hashed\";\n    * MSR track 2 hashed data is returned as a byte array.\n* String MSR_TRACK3_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_hashed\";\n    * MSR track 3 hashed data is returned as a byte array.\n\n### Soft Scan Trigger Intent Names\nHere are the API intent names for the soft scan trigger:\n\n* String ACTION_SOFTSCANTRIGGER = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\";\n    * This is the intent action for the soft scan trigger.\n* String EXTRA_PARAM = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";\n    * Parameter passed in the intent to specify the action the soft scan trigger should perform.  The following actions are recognized:\n* String DWAPI_START_SCANNING = \"START_SCANNING\";\n    * Start scanning.\n* String DWAPI_STOP_SCANNING = \"STOP_SCANNING\";\n    * Stop scanning.\n* String DWAPI_TOGGLE_SCANNING = \"TOGGLE_SCANNING\";\n    * Toggle scanning.\n\n>In the code that follows we will just be using the SOURCE_TAG, DATA_STRING_TAG and LABEL_TYPE_TAG intent data to display the intent data in the EditText widget.\n \n## Handling Intents\nIncoming intents can be handled by overriding the onNewIntent method.\n\n    :::java\n    @Override  \n    public void onNewIntent(Intent i) {  \n        handleDecodeData(i);  \n    }  \n\nOur *handleDecodeData()* method will responsible for getting the data from the intent, formatting it and adding it to the end of the edit box; something like this:\n\n    :::java\n    private void handleDecodeData(Intent i) {  \n        // check the intent action is for us  \n        if ( i.getAction().contentEquals(com.motorolasolutions.emdk.sample.dwdemosample.RECVR) ) {       \n            // define a string that will hold our output  \n      \n      \n            String out = \"\";  \n            // get the source of the data  \n            String source = i.getStringExtra(SOURCE_TAG);  \n            // save it to use later  \n            if (source == null) source = \"scanner\";  \n            // get the data from the intent  \n            String data = i.getStringExtra(DATA_STRING_TAG);  \n            // let's define a variable for the data length  \n            Integer data_len = 0;  \n            // and set it to the length of the data  \n            if (data != null) data_len = data.length();  \n            // check if the data has come from the barcode scanner  \n            if (source.equalsIgnoreCase(\"scanner\")) {  \n                // check if there is anything in the data  \n                if (data != null && data.length() > 0) {  \n                  // we have some data, so let's get it's symbology  \n                    String sLabelType = i.getStringExtra(LABEL_TYPE_TAG);  \n                    // check if the string is empty  \n                    if (sLabelType != null && sLabelType.length() > 0) {  \n                        // format of the label type string is LABEL-TYPE-SYMBOLOGY  \n                        // so let's skip the LABEL-TYPE- portion to get just the symbology  \n                        sLabelType = sLabelType.substring(11);  \n                    }  \n                    else {  \n                      // the string was empty so let's set it to \"Unknown\"  \n                        sLabelType = \"Unknown\";  \n                    }  \n                  // let's construct the beginning of our output string  \n                    out = \"Source: Scanner, \" + \"Symbology: \" + sLabelType + \", Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n                }  \n            }  \n            // check if the data has come from the MSR  \n            if (source.equalsIgnoreCase(\"msr\")) {  \n                // construct the beginning of our output string  \n              out = \"Source: MSR, Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n            }  \n      \n      \n            // let's get our edit box view  \n            EditText et = (EditText)findViewById(R.id.editbox);  \n            // and get it's text into an editable string  \n            Editable txt = et.getText();  \n            // now because we want format our output  \n          // we need to put the edit box text into a spannable string builder  \n            SpannableStringBuilder stringbuilder = new SpannableStringBuilder(txt);  \n            // add the output string we constructed earlier  \n            stringbuilder.append(out);  \n            // now let's highlight our output string in bold type  \n          stringbuilder.setSpan(new StyleSpan(Typeface.BOLD), txt.length(), stringbuilder.length(), SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE);  \n      \n      \n          // then add the barcode or msr data, plus a new line, and add it to the string builder  \n          stringbuilder.append(data + \"\\r\\n\");  \n          // now let's update the text in the edit box  \n          et.setText(stringbuilder);  \n            // we want the text cursor to be at the end of the edit box  \n            // so let's get the edit box text again  \n            txt = et.getText();  \n            // and set the cursor position at the end of the text  \n            et.setSelection(txt.length());  \n            // and we are done!  \n      }  \n    } \n\n\n## Toggling The Scan Trigger\nOur activity layout has an ImageView which we will use as a button to toggle the scan trigger.  This is done by using the Data Capture API.  The following code toggles the scan trigger each time the image is tapped.\n\n    :::java\n    ImageView img = (ImageView) findViewById(R.id.dwdemo_logo);  \n    img.setOnClickListener(new OnClickListener() {  \n        @Override  \n        public void onClick(View v) {  \n            Intent i = new Intent();  \n            i.setAction(ACTION_SOFTSCANTRIGGER);  \n            i.putExtra(EXTRA_PARAM, DWAPI_TOGGLE_SCANNING);  \n            DWDemoActivity.this.sendBroadcast(i);  \n            Toast.makeText(v.getContext(), \"Soft scan trigger toggled.\", Toast.LENGTH_SHORT).show();  \n        }  \n    }); \n\n\n## Putting It All Together\nLet's put all that code together so that we can see what our final activity class should look like.\n\n    :::java\n    package com.motorolasolutions.emdk.sample.dwdemosample;  \n    import android.os.Bundle;  \n    import android.app.Activity;  \n    import android.content.Intent;  \n    import android.graphics.Typeface;  \n    import android.view.View;  \n    import android.view.View.OnClickListener;  \n    import android.widget.EditText;  \n    import android.widget.ImageView;  \n    import android.widget.Toast;  \n    import android.text.Editable;  \n    import android.text.SpannableString;  \n    import android.text.SpannableStringBuilder;  \n    import android.text.style.StyleSpan;  \n    public class MainActivity extends Activity {  \n        // Tag used for logging errors  \n        private static final String TAG = MainActivity.class.getSimpleName();  \n        // Let's define some intent strings  \n        // This intent string contains the source of the data as a string  \n        private static final String SOURCE_TAG = \"com.motorolasolutions.emdk.datawedge.source\";  \n        // This intent string contains the barcode symbology as a string  \n        private static final String LABEL_TYPE_TAG = \"com.motorolasolutions.emdk.datawedge.label_type\";  \n        // This intent string contains the barcode data as a byte array list  \n        private static final String DECODE_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.decode_data\";  \n        // This intent string contains the captured data as a string  \n        // (in the case of MSR this data string contains a concatenation of the track data)  \n        private static final String DATA_STRING_TAG = \"com.motorolasolutions.emdk.datawedge.data_string\";  \n        // Let's define the MSR intent strings (in case we want to use these in the future)  \n        private static final String MSR_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.msr_data\";  \n        private static final String MSR_TRACK1_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1\";  \n        private static final String MSR_TRACK2_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2\";  \n        private static final String MSR_TRACK3_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3\";  \n        private static final String MSR_TRACK1_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_status\";  \n        private static final String MSR_TRACK2_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_status\";  \n        private static final String MSR_TRACK3_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_status\";  \n        private static final String MSR_TRACK1_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_encrypted\";  \n        private static final String MSR_TRACK2_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_encrypted\";  \n        private static final String MSR_TRACK3_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_encrypted\";  \n        private static final String MSR_TRACK1_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_hashed\";  \n        private static final String MSR_TRACK2_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_hashed\";  \n        private static final String MSR_TRACK3_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_hashed\";  \n        // Let's define the API intent strings for the soft scan trigger    private static final String ACTION_SOFTSCANTRIGGER = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\";  \n        private static final String EXTRA_PARAM = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";  \n        private static final String DWAPI_START_SCANNING = \"START_SCANNING\";  \n        private static final String DWAPI_STOP_SCANNING = \"STOP_SCANNING\";  \n        private static final String DWAPI_TOGGLE_SCANNING = \"TOGGLE_SCANNING\";  \n        private static String ourIntentAction = \"com.motorolasolutions.emdk.sample.dwdemosample.RECVR\";  \n      \n      \n        @Override  \n        public void onCreate(Bundle savedInstanceState) {  \n            super.onCreate(savedInstanceState);  \n            setContentView(R.layout.activity_main);  \n            // Let's set the cursor at the end of any text in the editable text field        EditText et = (EditText)findViewById(R.id.editbox);  \n            Editable txt = et.getText();  \n            et.setSelection(txt.length());  \n      \n      \n            // Since we will be using the image as a soft scan trigger toggle button        // let's handle the image on onClick event  \n            ImageView img = (ImageView) findViewById(R.id.logo);  \n            img.setOnClickListener(new OnClickListener() {  \n                @Override  \n                public void onClick(View v) {  \n                    // the image has been tapped so shoot off the intent to DataWedge                // to toggle the soft scan trigger  \n                    // Create a new intent  \n                    Intent i = new Intent();  \n                    // set the intent action using soft scan trigger action string declared earlier  \n                    i.setAction(ACTION_SOFTSCANTRIGGER);  \n                    // add a string parameter to tell DW that we want to toggle the soft scan trigger  \n                    i.putExtra(EXTRA_PARAM, DWAPI_TOGGLE_SCANNING);  \n                    // now broadcast the intent  \n                    MainActivity.this.sendBroadcast(i);  \n                    // provide some feedback to the user that we did something                Toast.makeText(v.getContext(), \"Soft scan trigger toggled.\", Toast.LENGTH_SHORT).show();  \n                }  \n            });  \n      \n      \n            // in case we have been launched by the DataWedge intent plug-in  \n            // using the StartActivity method let's handle the intent  \n            Intent i = getIntent();  \n            handleDecodeData(i);  \n        }  \n      \n      \n        // We need to handle any incoming intents, so let override the onNewIntent method  \n        @Override  \n        public void onNewIntent(Intent i) {  \n            handleDecodeData(i);  \n        }  \n      \n      \n        // This method is responsible for getting the data from the intent  \n        // formatting it and adding it to the end of the edit box  \n        private void handleDecodeData(Intent i) {  \n            // check the intent action is for us  \n            if ( i.getAction().contentEquals(ourIntentAction) ) {  \n                // define a string that will hold our output  \n                String out = \"\";  \n                // get the source of the data  \n                String source = i.getStringExtra(SOURCE_TAG);  \n                // save it to use later  \n                if (source == null) source = \"scanner\";  \n                // get the data from the intent  \n                String data = i.getStringExtra(DATA_STRING_TAG);  \n                // let's define a variable for the data length  \n      \n      \n                Integer data_len = 0;  \n                // and set it to the length of the data  \n                if (data != null) data_len = data.length();  \n                // check if the data has come from the barcode scanner  \n                if (source.equalsIgnoreCase(\"scanner\")) {  \n                    // check if there is anything in the data  \n                    if (data != null && data.length() > 0) {  \n                        // we have some data, so let's get it's symbology  \n                        String sLabelType = i.getStringExtra(LABEL_TYPE_TAG);  \n                        // check if the string is empty  \n                        if (sLabelType != null && sLabelType.length() > 0) {                        // format of the label type string is LABEL-TYPE-SYMBOLOGY  \n                            // so let's skip the LABEL-TYPE- portion to get just the symbology  \n                            sLabelType = sLabelType.substring(11);  \n                        }  \n                        else {  \n                            // the string was empty so let's set it to \"Unknown\"  \n                            sLabelType = \"Unknown\";  \n                        }  \n      \n      \n                        // let's construct the beginning of our output string  \n                        out = \"Source: Scanner, \" + \"Symbology: \" + sLabelType + \", Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n                    }  \n                }  \n                // check if the data has come from the MSR  \n                if (source.equalsIgnoreCase(\"msr\")) {  \n                    // construct the beginning of our output string  \n                    out = \"Source: MSR, Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n                }  \n      \n      \n                // let's get our edit box view  \n                EditText et = (EditText)findViewById(R.id.editbox);  \n                // and get it's text into an editable string  \n                Editable txt = et.getText();  \n                // now because we want format our output  \n      \n      \n                // we need to put the edit box text into a spannable string builder  \n                SpannableStringBuilder stringbuilder = new SpannableStringBuilder(txt);  \n                // add the output string we constructed earlier  \n                stringbuilder.append(out);  \n                // now let's highlight our output string in bold type  \n                stringbuilder.setSpan(new StyleSpan(Typeface.BOLD), txt.length(), stringbuilder.length(), SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE);  \n                // then add the barcode or msr data, plus a new line, and add it to the string builder  \n                stringbuilder.append(data + \"\\r\\n\");  \n                // now let's update the text in the edit box  \n                et.setText(stringbuilder);  \n                // we want the text cursor to be at the end of the edit box  \n                // so let's get the edit box text again  \n                txt = et.getText();  \n                // and set the cursor position at the end of the text  \n                et.setSelection(txt.length());  \n                // and we are done!  \n            }  \n        }  \n    }  \n\n## Defining Intent Filters\nHaving dealt with the coding of our activity, we now need to inform the system which implicit intents our application can handle.  For that we need to define an intent-filter as follows.\n\n    :::xml\n    <intent-filter>  \n        <action android:name=\"com.motorolasolutions.emdk.sample.dwdemosample.RECVR\"/>  \n        <category android:name=\"android.intent.category.DEFAULT\"/>  \n    </intent-filter>  \n\n\nWe will be using the com.motorolasolutions.emdk.sample.dwdemosample.RECVR action and the android.intent.category.DEFAULT category we have just defined above later on when we come to configure our DataWedge profile.\n\nIn this article DataWedge is configured to use the startActivity() method to send the intent. The startActivity() method causes a new activity to be launched. However since we do not want another instance of our activity launched each time we receive an intent, we need to specify the launch mode of our activity as single task.\nandroid:launchMode=\"singleTask\"\n\nAfter adding the above, our AndroidManifest.xml should look something like this\n\n    :::xml\n    <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n        package=\"com.motorolasolutions.emdk.sample.dwdemosample\"  \n        android:versionCode=\"1\"  \n        android:versionName=\"1.0.0\" >  \n        <uses-sdk  \n            android:minSdkVersion=\"10\"  \n            android:targetSdkVersion=\"10\" />  \n        <application  \n            android:icon=\"@drawable/ic_launcher\"  \n            android:label=\"@string/app_name\"  \n            android:theme=\"@style/AppTheme\" >  \n            <activity  \n                android:name=\".MainActivity\"  \n                android:label=\"@string/app_name\"  \n                android:launchMode=\"singleTask\" >  \n                <intent-filter>  \n                    <action android:name=\"android.intent.action.MAIN\" />  \n                    <category android:name=\"android.intent.category.LAUNCHER\" />  \n                </intent-filter>  \n                <intent-filter>  \n                    <action android:name=\"com.motorolasolutions.emdk.sample.dwdemosample.RECVR\"/>  \n                    <category android:name=\"android.intent.category.DEFAULT\"/>  \n                </intent-filter>  \n                </activity>  \n        </application>  \n    </manifest>  \n\n## Configuring DataWedge\nNow we need to configure DataWedge to send the desired intent to our application.\n\nThe following steps will help you get started\n\n* Launch DataWedge\n* Create a new profile and give it a name such as \"dwdemosample\"\n* Edit the profile\n* Go into Associated apps, tap the menu button, and add a new app/activity\n* For the application select com.motorolasolutions.emdk.sample.dwdemosample\n* For the activity select com.motorolasolutions.emdk.sample.dwdemosample.MainActivty\n* Go back and disable the keystroke output plug-in\n* Enable the intent output plug-in\n* For the intent action enter com.motorolasolutions.emdk.sample.dwdemosample.RECVR\n* For the intent category enter android.intent.category.DEFAULT\n \n## Summary\nThat's it.  You should now be able to scan a bar-code and see it appear in the sample application.\nIn this article, we covered:\n\n* DataWedge intent strings\n* Handling intents from Data Capture\n* Receiving barcode/MSR data\n* Sending intents to Data Capture\n* Toggling of the soft scan trigger\n* Defining intent filters\n* Configuring DataWedge to send intents to our application\n\n## Sample Code\nDownload the source for this project in the [associated sample](#guide-sample-sampledatacaptureintent)."},{"key":"guide-tutorial-tutdatacaptureprofile","name":" Data Capture Profile Feature Tutorial","md":"# Data Capture Profile Feature Tutorial\n## Developing an EMDK for Android Application Part 1\n\nThis guide will walk you through creating an EMDK For Android application that will use [Data Capture Profiles](#guide-profiles-profilebarcode) to get barcode data into your application using the [KeyStroke output](#guide-profiles-profilekeystroke) feature of [EMDK Profiles](#guide-profiles-usingwizard).\n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"EMDKSample\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding a DataCapture Profile\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"DataCaptureProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all the available features on the left hand side of the Profile Editor window. Select any feature from the list and click \"Right Arrow\" (Ex: \"ActivitySelection\" has been selected. By using this feature Activities can be associated with the application. Then the data capture feature will be enabled automatically when the specified activity is in foreground).\n  \n    ![img](images/setup/image051.jpg)\n  \n4. Click on the selected feature. The parameter list will be populated. \n\n\t> Note:\n\t> The field \"Name\" contains user defined name to identify a particular feature. This is required when editing any specific feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty. \n  \n5. Click \"ActivitySelection\" under parameters.\n  \n    ![img](images/setup/image055.jpg)  \n\n6. Specify the applications package name and click \"Apply\".\n  \n    ![img](images/setup/image057.jpg)\n  \n7. Specify an Activity inside the application and click \"Apply\".\n  \n    ![img](images/setup/image059.jpg)\n  \n8. Click \"OK\".\n  \n    ![img](images/setup/image061.jpg)\n  \n9. Select any data capture feature and click Right Arrow (Ex: \"Barcode\" has been selected).\n  \n    ![img](images/setup/image063.jpg)\n  \n10. Click on the \"Barcode\" feature. The parameter list will be populated.\n\t> Note: \n\t> The field \"Name\" contains user defined name to identify a particular Barcode feature. This is required when editing any specific Barcode feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n  \n11. Enable the feature and change some parameters.\n    ![img](images/setup/image067.jpg)\n    ![img](images/setup/image069.jpg)\n    ![img](images/setup/image071.jpg)\n  \n12.    Click \"Apply\". \n13.    Select the Keystroke feature and click \"Right Arrow\" (Ex: \"Keystroke\" has been selected).\n\t> Note:\n\t> The field \"Name\" contains user defined name to identify a particular Keystroke feature. This is required when editing any specific Keystroke feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n\n    ![img](images/setup/image073.jpg)\n  \n14. Enable the feature and change some parameters.\n  \n    ![img](images/setup/image075.jpg)\n  \n    ![img](images/setup/image077.jpg)\n  \n15. Click \"Apply\" and \"Finish\".\n  \n    ![img](images/setup/image079.jpg)\n  \n16.    Click \"Close\".  \n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n17. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/setup/image083.jpg)\n   \n    ![img](images/setup/image085.jpg)   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/setup/image087.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/setup/image089.jpg)  \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n    \n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager that we will use throughout the code:  \n    \n        :::java\n        //Assign the profile name used in EMDKConfig.xml  \n        private String profileName = \"DataCaptureProfile\";  \n          \n        //Declare a variable to store ProfileManager object  \n        private ProfileManager mProfileManager = null;  \n          \n        //Declare a variable to store EMDKManager object  \n        private EMDKManager emdkManager = null;     \n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n        if(results.statusCode == STATUS_CODE.FAILURE)  \n        {  \n                //Failed to create EMDKManager object  \n                \n        }  \n\n    So far your code should look like:\n     \n     ![img](images/setup/image091.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `mProfileManager`. This is how we will interface with the APIs in the rest of the code:  \n\n        :::java\n        this.emdkManager = emdkManager;  \n        //Get the ProfileManager object to process the profiles  \n        mProfileManager = (ProfileManager) emdkManager.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:  \n\n        :::java\n        if(mProfileManager != null)  \n        {  \n            try{\n\n                String[] modifyData = new String[1];  \n                //Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.  \n             \n                EMDKResults results = mProfileManager.processProfile(profileName, ProfileManager.PROFILE_FLAG.SET, modifyData);  \n                 if(results.statusCode == STATUS_CODE.FAILURE)  \n                 {  \n                     //Failed to set profile  \n                 }  \n             }catch (Exception ex){\n                // Handle any exception\n            }\n\n        }  \n\n    Your onOpened method should now look like this:\n    \n    ![img](images/setup/image095.jpg)  \n    \n3. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/setup/image093.jpg)  \n\n4. Remove the default \"TextView\", inside \"res/layout/activity_main.xml\".\n\n5. Add an EditText Field in the UI called \"editTextBarcode\", inside \"res/layout/activity_main.xml\".\n    \n        :::xml\n        <EditText  \n            android:id=\"@+id/editTextBarcode\"  \n            android:layout_width=\"wrap_content\"  \n            android:layout_height=\"wrap_content\"  \n            android:layout_marginTop=\"200dp\"  \n            android:layout_marginLeft=\"50dp\"  \n            android:ems=\"10\" >  \n\n6. Connect the device (having the latest EMDK runtime) to USB port.\n    >Note:   \n    >Make sure the device is in USB debug.\n7. Run the application.\n  \n\t![img](images/setup/image103.png)\n  \n8. Press the trigger button and scan a barcode.\n9. The scanned data will be populated in the Edit Text field added to the UI.\n  \n\t![img](images/setup/image104.png)  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. When using the \"Barcode\" feature in EMDK Wizard, the specified value for \"Scanner\" is not supported on the device, it will be considered as \"Auto\" during runtime (Ex: BT_LASER1, BT_IMAGER1 and BT_CAMERA1).\n3. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device. \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned the basics of an EMDK for Android application, the [next tutorial](#guide-tutorial-tutdatacaptureprofilePt2)</a> will show you how to use the [Intent Output](#guide-profiles-profileintent) feature of EMDK Profiles to handle Data Capture output programmatically.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-DataCapture-ProfileManagerTutorial.zip)."},{"key":"guide-tutorial-tutdatacaptureprofilePt2","name":" Using Intent Output With DataCapture Profiles","md":"# Using Intent Output With DataCapture Profiles\n## Developing an EMDK for Android Application Part 2\n\nThis tutorial will walk you through adding [Intent Output](#guide-profiles-profileintent) support to the EMDK For Android application you made using [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile). This tutorial will assume your project is at the state of the end of that tutorial and build on top of it. You can follow the tutorial in the previous step of download the source from the previous step and start from there.\n\nThe tutorial uses EMDK V 2.1 that has organized existing features as well as got some new features that would be discussed later in the tutorial.\n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android \n* Completion of [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile)\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Adding Intents to the DataCapture Profile\n1. Select \"EMDKSample\" project from Package Explorer.    \n2. Click \"EMDK\" menu present on the top-bar and select \"Profile Manager\" option.\n  \n3. The EMDK Profile Manager Window will appear.\n  \n    ![img](images/setup/image105.jpg)\n  \n4. select \"DataCaptureProfile\" and click \"Edit\".\n5. Select \"Intent\" from the list of \"Available Features\" and add it to \"Selected Features\" by clicking \"Right Arrow\".\n\n\t> Note: \n\t> The field \"Name\" contains user defined name to identify a particular Intent Output feature. This is required when editing any specific Intent Output feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n\n\t![img](images/setup/image106.jpg)\n  \n6. Select \"Intent\" from the list of \"Selected Features\". \n7. Now we will configure the \"Intent\" parameters.  \n\t* Switch \"Intent Output Enable\" to Enable\". \n\t* For \"Intent Output Action\" enter \"com.symbol.emdksample.RECVR\".\n\t* For \"Intent Output Category\" enter \"android.intent.category.DEFAULT\".\n\t* Switch \"Intent Output Delivery\" to \"Send via startActivity\".  \n\t* Switch \"Basic data formatting Enable\" to Enable\". \n\t* Switch \"Basic data formatting Send Data\" to Enable\". \t\n\n\tYour Intent configuration should now look like this:\n  \n\t![img](images/setup/image107.jpg)  \n\n8. Click \"Apply\" and \"Finish\".\n  \n    ![img](images/setup/image105.jpg)\n  \n9. Click \"Close\".  \n    >Note:  \n    >Now the \"EMDKConfig.xml\" under \"\\assets\" folder will be updated with your changes.\n\n##Adding the Intent Filter\n1. Open your application's \"Manifest.xml\" file.\n  \n\t![img](images/setup/image211.jpg)\n\n2. Make the following changes to your application's\"Manifest.xml\" file.  \n\n\tAdd the following parameter to your activity settings to enable \"singleTask\" mode.\n\t\n        :::xml\n        android:launchMode=\"singleTask\"  \n\t\n\tAdd the following lines to receive EMDK Intents in your application: \n\n        :::xml\n        <intent-filter>  \n                <action android:name=\"com.symbol.emdksample.RECVR\"/>  \n                <category android:name=\"android.intent.category.DEFAULT\"/>  \n        </intent-filter>     \n\n    When done, your manifest.xml should look like this:\n\n    ![img](images/setup/image108.jpg)  \n\n\t>Note:  \n\t>\n\t>* The intent action name should match the value of \"Intent Output Action\" in the EMDK Profile Manager. \n\t>* The intent category name should match the value of \"Intent Output Category\" in the EMDK Profile Manager.\n\n##Adding the Intent code\n1. Add the following imports to your program.\n\n        :::java\n        import android.content.Intent;  \n        import android.widget.TextView; \n\n\t![img](images/setup/image109.jpg)\n \n2. Add the following function to your program for processing intents. \n\n        :::java\n        //This function is responsible for getting the data from the intent  \n        private void handleDecodeData(Intent i)  \n        {  \n          \n        }\n     \n    ![img](images/setup/image110.jpg)\n \n3. Add the following code to your \"onCreate\" function check for a possible intent; \n\n        :::java\n        //In case we have been launched by the DataWedge intent plug-in  \n        Intent i = getIntent();  \n        handleDecodeData(i); \n\n    ![img](images/setup/image112.jpg)\n  \n4. Overide \"onNewIntent\" to handle incoming intents. \n\n        :::java\n        //We need to handle any incoming intents, so let override the onNewIntent method  \n        @Override  \n        public void onNewIntent(Intent i) {  \n                handleDecodeData(i);  \n           \n        } \n     \n    ![img](images/setup/image111.jpg)\n\n5. Add a TextView in the UI called \"textViewBarcode\", inside \"res/layout/activity_main.xml\".\n    \n        :::xml\n        <TextView  \n                android:id=\"@+id/textViewBarcode\"  \n            android:layout_width=\"wrap_content\"  \n            android:layout_height=\"wrap_content\"  \n            android:layout_alignParentTop=\"true\"  \n            android:layout_centerHorizontal=\"true\"  \n            android:layout_marginTop=\"50dp\"  \n            android:text=\"@+string/hello_world\"  \n            android:textAppearance=\"?android:attr/textAppearanceMedium\" />  \n\n\t![img](images/setup/image113.jpg)\n  \n6. Add a global variable for the TextView. \n \n        :::java\n        //Declare a variable to store the textViewBarcode  \n        private TextView textViewBarcode = null;\n\t\n\t![img](images/setup/image114.jpg)\n    \n7. Add the following code to your onCreate function to get a handle on the TextView.\n \n        :::java\n        //Get the textViewBarcode  \n        textViewBarcode = (TextView) findViewById(R.id.textViewBarcode); \n\n\t![img](images/setup/image115.jpg)\n   \n8. Add the following code to your \"handleDecodeData\" function to confirm the intent was meant for us. \n\n        :::java\n        //Check the intent action is for us  \n        if (i.getAction().contentEquals(\"com.symbol.emdksample.RECVR\") ) {  \n          \n        } \n    \n    ![img](images/setup/image116.jpg)   \n    \n9. Add the following code to your \"handleDecodeData\" function to check if the intent contains Barcode data.  \n\n        :::java\n        //Get the source of the data  \n        String source = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.source\");  \n          \n        //Check if the data has come from the Barcode scanner  \n        if(source.equalsIgnoreCase(\"scanner\"))  \n        {  \n          \n        }\n\n\t![img](images/setup/image117.jpg)\n   \n10. Add the following code to your \"handleDecodeData\" function to retrieve Barcode data.  \n\n        :::java\n        //Get the data from the intent  \n        String data = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.data_string\");  \n          \n        //Check that we have received data  \n        if(data != null && data.length() > 0)  \n        {  \n          \n        } \n\n\t![img](images/setup/image118.jpg)\n\n11. Add the following code to your \"handleDecodeData\" function to populate the TextView with the revived Barcode data.\n\n        :::java\n        //Display the data to the text view  \n        textViewBarcode.setText(\"Data = \" + data); \n\n\t![img](images/setup/image119.jpg)\n \n12. Connect the device (having the latest EMDK runtime) to USB port.\n    \n    >Note:   \n    >Make sure the device is in USB debug.\n\n13. Run the application.\n  \n\t![img](images/setup/image120.png)\n \n14. Press the trigger button and scan a Barcode.\n15. The scanned data will be populated in the Edit Text field Through the previous Keystroke Intent and will appear on the Text View using the new Datawedge Intent.\n   \n\t![img](images/setup/image121.png) \n\n\n## What's Next\nThe [next tutorial](#guide-tutorial-tutdatacaptureprofilePt3) will show you how to use multiple Data Capture Profiles that are handled by multiple activities.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-DataCaptureProfiles-Using+Intent+Output.zip)."},{"key":"guide-tutorial-tutdatacaptureprofilePt3","name":" Using Multiple Data Capture Profiles","md":"# Using Multiple Data Capture Profiles\n## Developing an EMDK for Android Application Part 3\n\nThis guide will walk you through adding MSR support and multiple profiles to the Android application you made using [Developing an EMDK for Android Application Part 2](#guide-tutorial-tutdatacaptureprofilePt2). This tutorial will add some more complexity by adding a second screen as well as adding a second Data Capture Profile.\n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android \n* Completion of [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile)\n* Completion of [Developing an EMDK for Android Application Part 2](#guide-tutorial-tutdatacaptureprofilePt2)\n \nFor more information about setting up the EMDK please see the EMDK [Setup](#guide-setup).\n\n##Adding MSR Activity\nLet's start by defining a second activity for the application. This activity will be used to to activate a Data Capture profile that listens for MSR data.\n\n1. Select \"EMDKSample\" project, right click on it and create a new Activity with the name \"MSRActivity\".\n   \n\n##Adding MSR Completed Activity\nNext let's create a third activity that will listen for the MSR data and display the data to the user.\n\n1. Select \"EMDKSample\" project, right click on it and create a new Activity with the name \"MSRCompletedActivity\".  \n\n##Updating Main Activity\nNow we will update \"MainActivity\", adding a button to launch our \"MSRActivity\".\n\n1. Select \"activity_main.xml\" from \"Package Explorer\" in Eclipse/Android Studio.\n  \n2. Add the following Button to \"activity_main.xml\". This Button will be used for opening \"MSRActivity\".  \n\t\n        :::xml\n        <Button  \n        android:id=\"@+id/buttonMSR\"  \n        android:layout_width=\"wrap_content\"  \n        android:layout_height=\"wrap_content\"  \n        android:layout_alignParentBottom=\"true\"  \n        android:layout_marginBottom=\"50dp\"  \n        android:layout_marginLeft=\"50dp\"  \n        android:text=\"MSR\" />\n\n\t![img](images/setup/image129.jpg)\n  \n3. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse/Android Studio. \n\n\t![img](images/setup/image130.jpg)\n \n4. Add the following Imports to \"MainActivity.java\".  \n\t\n        :::java\n        import android.widget.Button;  \n        import android.view.View;  \n        import android.view.View.OnClickListener; \n\n\t![img](images/setup/image131.jpg)\n  \n5. Declare a variable inside \"MainActivity\" to store \"buttonMSR\". \n\t\n        :::java\n        //Declare a variable to store the buttonMSR  \n        private Button buttonMSR = null;  \n\n\t![img](images/setup/image132.jpg)\n  \n6. Inside \"onCreate\" get a reference to \"buttonMSR\".\n\t\n        :::java\n        //Declare a variable to store the buttonMSR  \n        private Button buttonMSR = null; \n\n\t![img](images/setup/image133.jpg)\n  \n7. Inside \"onCreate\" add an \"OnClickListener\" for \"buttonMSR\".  \n\t\n        :::java\n        //Add an OnClickListener for buttonMSR  \n        buttonMSR.setOnClickListener(buttonMSROnClick);     \n\n\t![img](images/setup/image134.jpg)  \n\n8. Add a new \"OnClickListener\" inside \"MainActivity\". \n\n        :::java\n        //OnClickListener for buttonMSR  \n        private OnClickListener buttonMSROnClick = new OnClickListener() {  \n            public void onClick(View v) {  \n          \n            }  \n        };  \n\n\t![img](images/setup/image135.jpg)\n  \n9. Add the following code to \"onClick\" to launch \"MSRActivity\". \n\n        :::java\n        //Launch MSRActivity  \n        Intent myIntent = new Intent(MainActivity.this, MSRActivity.class);  \n        startActivity(myIntent);  \n\n\t![img](images/setup/image136.jpg) \n\n##Creating MSR UI\nNext we will create the UI for \"MSRActivity\". \n\n1. Select \"activity_msr.xml\" from \"Package Explorer\" in Eclipse/Android Studio.\n \n2. Remove the default \"TextView\". \n3. Add the following TextView. \n\n        :::xml\n        <TextView  \n            android:id=\"@+id/textViewInfo\"  \n            android:layout_width=\"wrap_content\"  \n            android:layout_height=\"wrap_content\"  \n            android:layout_alignParentTop=\"true\"  \n            android:layout_centerHorizontal=\"true\"  \n            android:layout_marginTop=\"50dp\"  \n            android:text=\"Please swipe a card to continue.\"  \n            android:textAppearance=\"?android:attr/textAppearanceLarge\" /> \n\n\t![img](images/setup/image138.jpg) \n\n##Creating our MSR Profile\nNext we will create a Data Capture profile that will activate the MSR on \"MSRActivity\" and send the data via a startActivity Intent to \"MSRCompletedActivity\".  \n\n1. Select \"EMDKSample\" project from Package Explorer.    \n2. Click \"EMDK\" menu present on the top-bar and select \"Profile Manager\" option.\n  \n3. The EMDK Profile Manager Window will appear.\n  \n    ![img](images/setup/image139.jpg)\n  \n4. click \"Create\".\n  \n    ![img](images/setup/image140.jpg)\n  \n5. Provide \"DataCaptureProfileMSR\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.\n  \n    ![img](images/setup/image141.jpg)\n  \n6. select \"ActivitySelection\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow.\n\n\t> Note: \n\t> The field \"Name\" contains user defined name to identify a particular feature. This is required when editing any specific feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n  \n    ![img](images/setup/image142.jpg)\n  \n7. Select \"Activity Selection\".\n  \n    ![img](images/setup/image143.jpg)\n  \n8. Enter \"com.symbol.emdksample\" as the application name and click apply.\n  \n    ![img](images/setup/image144.jpg)\n  \n9. Enter \"MSRActivity\" as the activity name and click apply.\n  \n    ![img](images/setup/image145.jpg)  \t\n\n10. Click OK.  \n11. select \"MSR\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow.\n\n\t> Note: \n\t> The field \"Name\" contains user defined name to identify a particular Data Input MSR feature. This is required when editing any specific Data Input MSR feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n \n    ![img](images/setup/image146.jpg)  \t\n\n12. Change \"MSR Input Enable\" to \"Enable\".\n  \n\t![img](images/setup/image147.jpg)\n \n13. select \"Intent\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow.\n \n\t![img](images/setup/image148.jpg)\n \n14. Now we will configure the \"Intent\" parameters.  \n\t* Switch \"Intent Output Enable\" to Enable\". \n\t* For \"Intent Output Action\" enter \"com.symbol.emdksample.RECVRMSR\".\n\t* For \"Intent Output Category\" enter \"android.intent.category.DEFAULT\".\n\t* Switch \"Intent Output Delivery\" to \"Send via startActivity\".  \n\t* Switch \"Basic data formatting Enable\" to Enable\". \n\t* Switch \"Basic data formatting Send Data\" to Enable\". \t\n\n\tYour Intent configuration should now look like this:\n  \n\t![img](images/setup/image149.jpg)  \n\n15. Click \"Apply\" and \"Finish\".\n  \n    ![img](images/setup/image150.jpg)\n  \n16. Click \"Close\".  \n    >Note:  \n    >Now the \"EMDKConfig.xml\" file under the \"\\assets\" folder will be updated with your changes.\n\n##Adding the MSR Intent Filter\nNow will add an Intent filter to our Manifest file to allow \"MSRCompletedActivity\" to listen for our new Data Capture Intent. \n\n1. Open your application's \"Manifest.xml\" file.\n  \n\t![img](images/setup/image151.jpg)\n\n2. Add the following configuration to the activity \"com.symbol.emdksample.MSRCompletedActivity\" to revive our MSR intent.  \n\n        :::xml\t \n        <intent-filter>  \n                <action android:name=\"com.symbol.emdksample.RECVRMSR\"/>  \n                <category android:name=\"android.intent.category.DEFAULT\"/>  \n        </intent-filter>  \n\n    When done, your manifest.xml should look like this:\n\n    ![img](images/setup/image152.jpg)  \n\n\t>Note:  \n\t>\n\t>* The intent action name should match the value of \"Intent Output Action\" in the EMDK Profile Manager. \n\t>* The intent category name should match the value of \"Intent Output Category\" in the EMDK Profile Manager.\n\n##Registering the MSR EMDK profile\nNext we will register our new Data Capture profile from \"MainActivity\".\n\n1. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/setup/image153.jpg)\n \n2. Inside \"MainActivity\" add the following code to hold the name of our MSR profile.  \n\n        :::java\n        //Assign the profile name used in EMDKConfig.xml  for MSR handling  \n        private String profileNameMSR = \"DataCaptureProfileMSR\";  \n\n    ![img](images/setup/image154.jpg)\n  \n3. Inside \"onOpened\" add the following code to register the MSR EMDK profile. \n\n        :::java\n        //Call processPrfoile for profile MSR  \n        results = mProfileManager.processProfile(profileNameMSR, ProfileManager.PROFILE_FLAG.SET, modifyData);  \n          \n        if(results.statusCode == STATUS_CODE.FAILURE)  \n        {  \n        //Failed to set profile MSR  \n        }  \n\n    ![img](images/setup/image155.jpg)  \n\n##Creating MSR Completed UI\nNow we will create the UI for \"MSRCompletedActivity\". This UI will allow us to display the MSR data to the user.\n\n1. Select \"activity_msr.xml\" from \"Package Explorer\" in Eclipse/Android Studio. \n \n2. Remove the default \"TextView\". \n3. Add the following TextView. \n\n\t    :::xml\n    \t<TextView  \n        android:id=\"@+id/textViewMSRData\"  \n        android:layout_width=\"wrap_content\"  \n        android:layout_height=\"wrap_content\"  \n        android:layout_alignParentTop=\"true\"  \n        android:layout_centerHorizontal=\"true\"  \n        android:layout_marginTop=\"50dp\"  \n        android:text=\"Data = \"  \n        android:textAppearance=\"?android:attr/textAppearanceMedium\" />  \n\n\t![img](images/setup/image157.jpg) \n\n##Handling MSR Intents\nNext will will add the code to \"MSRCompletedActivity\" for capturing the startActivity Intent and displaying the result data to the user. \n\n1. Select \"MSRCompletedActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/setup/image158.jpg)\n \n2. Add the following imports.  \n\n        :::java\n        import android.content.Intent;  \n        import android.widget.TextView; \n\n\t![img](images/setup/image159.jpg)\n  \n3. Add the following function for processing intents.  \n\n        :::java\n        //This function is responsible for getting the data from the intent  \n        private void handleDecodeData(Intent i)  \n        {  \n          \n        }  \n     \n    ![img](images/setup/image160.jpg)\n  \n4. Add the following code to your \"onCreate\" function to check for a possible intent;  \n\n        :::java\n        //In case we have been launched by the DataWedge intent plug-in  \n        Intent i = getIntent();  \n        handleDecodeData(i);\n     \n    ![img](images/setup/image161.jpg)\n  \n5. Overide \"onNewIntent\" to handle incoming intents.  \n\n        :::java\n        //We need to handle any incoming intents, so let override the onNewIntent method  \n        @Override  \n        public void onNewIntent(Intent i) {  \n            handleDecodeData(i);  \n           \n        }\n     \n    ![img](images/setup/image162.jpg)\n  \n6. Add a global variable for the TextView. \n\n        :::java\n        //Declare a variable to store the textViewMSRData  \n        private TextView textViewMSRData = null; \n\t\n\t![img](images/setup/image163.jpg)\n  \n7. Add the following code to your onCreate function to get a handle on the TextView.\n \n        :::java\n        //Get the textViewBarcode  \n        textViewMSRData = (TextView) findViewById(R.id.textViewMSRData); \n\n\t![img](images/setup/image164.jpg)\n   \n8. Add the following code to your \"handleDecodeData\" function to confirm the intent was meant for us. \n\n        :::java\n        //Check the intent action is for us  \n        if (i.getAction().contentEquals(\"com.symbol.emdksample.RECVRMSR\"))  \n        {  \n          \n        }\n    \n    ![img](images/setup/image165.jpg)\n   \n9. Add the following code to your \"handleDecodeData\" function to check if the intent contains MSR data.  \n\n        :::java\n        //Get the source of the data  \n        String source = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.source\");  \n          \n             \n        //Check if the data has come from the msr  \n        if(source.equalsIgnoreCase(\"msr\"))  \n        {  \n          \n        }  \n\n\t![img](images/setup/image166.jpg)\n  \n10. Add the following code to your \"handleDecodeData\" function to retrieve MSR data.  \n\n        :::java\n        //Get the data from the intent  \n        String data = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.data_string\");  \n          \n        //Check that we have received data  \n        if(data != null && data.length() > 0)  \n        {  \n          \n        }\n\n\t![img](images/setup/image167.jpg)\n\n11. Add the following code to your \"handleDecodeData\" function to populate the TextView with the revived MSR data.\n\n        :::java\n        //Display the data to textViewMSRData  \n        textViewMSRData.setText(\"Data = \" + data);  \n\n\t![img](images/setup/image168.jpg) \n\n##Running the Application\nLastly we will run and test our application. \n\n1. Connect the device (having the latest EMDK runtime) to USB port.\n\n    >Note:   \n    >Make sure the device is in USB debug.\n\n2. Run the application.  \n\n\t![img](images/setup/image169.png)\n \n3. Press the trigger button and scan a Barcode. \n4. Like before the scanned data will be populated in the Edit Text field Through the previous Keystroke Intent and will appear on the Text View using the previous Datawedge Intent.   \n\n\t![img](images/setup/image170.png)\n \n5. Press the button \"MSR\".  \n\n\t![img](images/setup/image171.png)\n\n6. Swipe a cad through the MSR.  \n\n\t![img](images/setup/image172.png)\n\n7. Press return to go back to the MSR where you can swipe another card, or hit return again to go back to the main screen. \n\n## What's Next\nThe [next tutorial](#guide-tutorial-tutdatacaptureprofilePt4) will show you how to use the Intent Output as a Broadcast instead of starting an activity.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-UsingMultipleDataCaptureProfiles.zip)."},{"key":"guide-tutorial-tutdatacaptureprofilePt4","name":" Using Broadcast Intent in DataCapture Profiles","md":"# Using Broadcast Intent in DataCapture Profiles\n## Developing an EMDK for Android Application Part 4\n\nThis guide will walk you through adding broadcast intent support to the Android application you made using [Developing an EMDK for Android Application Part 3](#guide-tutorial-tutdatacaptureprofilePt3).\n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android \n* Completion of [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile)\n* Completion of [Developing an EMDK for Android Application Part 2](#guide-tutorial-tutdatacaptureprofilePt2)\n* Completion of [Developing an EMDK for Android Application Part 3](#guide-tutorial-tutdatacaptureprofilePt3)\n \nFor more information about setting up the EMDK please see the EMDK [Setup](#guide-setup).\n\n##Using EMDK Wizard and EMDK for Android Broadcast Intents.\n\n###Adding Broadcast Intent Activity\nFirst we will add a new activity that will be used for listening and displaying Barcode data to the user. \n\n1. Select \"EMDKSample\" from \"Package Explorer\" in Eclipse/Android Studio.\n\n2. Right click and create a new \"Empty Activity\" with the name \"BroadcastIntentActivity\"     \n\n###Updating Main Activity\nNext we will update \"MainActivity\", adding a button to launch our \"BroadcastIntentActivity\".\n\n1. Select \"activity_main.xml\" from \"Package Explorer\" in Eclipse/Android Studio.  \n\t  \n2. Add the following Button to \"activity_main.xml\". This Button will be used for opening \"BroadcastIntentActivity\".  \n\n\t\t:::xml\n\t\t<Button  \n\t\t     \n\t\t    android:id=\"@+id/buttonBroadcastIntent\"  \n\t\t    android:layout_width=\"wrap_content\"  \n\t\t    android:layout_height=\"wrap_content\"  \n\t\t    android:layout_alignParentBottom=\"true\"  \n\t\t    android:layout_marginBottom=\"50dp\"  \n\t\t    android:layout_marginLeft=\"120dp\"  \n\t\t    android:text=\"Broadcast Intent\" \" /> \n\n\t![img](images/setup/image171.jpg)  \n3. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/setup/image172.jpg) \n4. Declare a variable inside \"MainActivity\" to store \"buttonBroadcastIntent\". \n\n\t\t:::java\n\t\t//Declare a variable to store the buttonBroadcastIntent  \n\t\tprivate Button buttonBroadcastIntent = null;  \n\n\t![img](images/setup/image173.jpg)  \n5. Inside \"onCreate\" get a reference to \"buttonBroadcastIntent\".\n\n\t\t:::java\n\t\t//Get the buttonBroadcastIntent  \n\t\tbuttonBroadcastIntent = (Button) findViewById(R.id.buttonBroadcastIntent); \n\n\t![img](images/setup/image174.jpg)  \n6. Inside \"onCreate\" add an \"OnClickListener\" for \"buttonMSR\".  \n\n\t\t:::java\n\t\t//Add an OnClickListener for buttonBroadcastIntent  \n\t\tbuttonBroadcastIntent.setOnClickListener(buttonBroadcastIntentOnClick);  \n\n\t![img](images/setup/image175.jpg)  \n7. Add a new \"OnClickListener\" inside \"MainActivity\".  \n\n\t\t:::java\n\t\t//OnClickListener for buttonBroadcastIntent  \n\t\tprivate OnClickListener buttonBroadcastIntentOnClick = new OnClickListener() {  \n\t\t    public void onClick(View v) {  \n\t\t  \n\t\t    }  \n\t\t};  \n\n\t![img](images/setup/image176.jpg)  \n8. Add the following code to \"onClick\" to launch \"BroadcastIntentActivity\". \n\n\t\t:::java\n\t\t//Launch BroadcastIntentActivity  \n\t\tIntent myIntent = new Intent(MainActivity.this, BroadcastIntentActivity.class);  \n\t\tstartActivity(myIntent);  \n\n\t![img](images/setup/image177.jpg) \n\n###Creating Broadcast Intent UI\nThen we will create the UI for displaying Barcode data to the user. \n\n1. Select \"activity_msr.xml\" from \"Package Explorer\" in Eclipse.  \n \n2. Remove the default \"TextView\". \n3. Add the following TextView. \n\n\t\t:::xml\n\t\t<TextView  \n\t\t    android:id=\"@+id/textViewData\"  \n\t\t    android:layout_width=\"wrap_content\"  \n\t\t    android:layout_height=\"wrap_content\"  \n\t\t    android:layout_alignParentTop=\"true\"  \n\t\t    android:layout_centerHorizontal=\"true\"  \n\t\t    android:layout_marginTop=\"50dp\"  \n\t\t    android:text=\"Please Scan a Barcode.\"  \n\t\t    android:textAppearance=\"?android:attr/textAppearanceMedium\" />  \n\n\t![img](images/setup/image179.jpg) \n\n###Creating our Broadcast Intent Profile\nNext will will create a Data Capture profile that will be active on \"BroadcastIntentActivity\" and send Barcode data using a Broadcast Intent. \n\n1. Select \"EMDKSample\" project from Package Explorer.    \n2. Click \"EMDK\" menu present on the top-bar and select \"Profile Manager\" option.\n  \n3. The EMDK Profile Manager Window will appear.\n  \n    ![img](images/setup/image180.jpg)\n  \n4. click \"Create\".\n  \n    ![img](images/setup/image181.jpg)\n  \n5. Provide \"DataCaptureProfileBroadcastIntent\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.\n  \n    ![img](images/setup/image182.jpg)\n  \n6. select \"ActivitySelection\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow.\n\n\t> Note: \n\t> The field \"Name\" contains user defined name to identify a particular feature. This is required when editing any specific feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n  \n    ![img](images/setup/image_data_capture_broadcast_activity_selection.jpg)\n  \n7. Select \"Activity Selection\".\n  \n    ![img](images/setup/image143.jpg)\n  \n8. Enter \"com.symbol.emdksample\" as the application name and click apply.\n  \n    ![img](images/setup/image144.jpg)\n  \n9. Enter \"BroadcastIntentActivity\" as the activity name and click apply.\n  \n    ![img](images/setup/image183.jpg)  \t\n\n10. Click OK.  \n11. select \"Barcode\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow.\n \n    ![img](images/setup/image184.jpg)  \t\n\n12. Change \"Barcode Scanner Input Enable\" to \"Enable\".\n\n\t> Note: \n\t> The field \"Name\" contains user defined name to identify a particular Barcode Scanner Input feature. This is required when editing any specific Barcode Scanner Input feature programmatically, which is outside the scope of this tutorial. So we will keep the \"Name\" field empty.\n  \n\t![img](images/setup/image185.jpg)\n  \n13. select \"Intent\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow. \n\n\t![img](images/setup/image186.jpg)\n \n14. Now we will configure the \"Intent\" parameters.  \n\t* Switch \"Intent Output Enable\" to Enable\". \n\t* For \"Intent Output Action\" enter \"com.symbol.emdksample.RECVRBI\".\n\t* Switch \"Intent Output Delivery\" to \"Broadcast Intent\".  \n\t* Switch \"Basic data formatting Enable\" to Enable\". \n\t* Switch \"Basic data formatting Send Data\" to Enable\". \t\n\n\tYour Intent configuration should now look like this:\n  \n\t![img](images/setup/image187.jpg)  \n\n15. Click \"Apply\" and \"Finish\".\n  \n    ![img](images/setup/image188.jpg)\n  \n16. Click \"Close\".  \n    >Note:  \n    >Now the \"EMDKConfig.xml\" file under the \"\\assets\" folder will be updated with your changes.\n\n###Registering for the Broadcast Intent profile\nNow will register our new Data Capture profile in \"MainActivity\".\n\n1. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/setup/image189.jpg)\n \n2. Inside \"MainActivity\" add the following code to hold the name of our Broadcast Intent profile.  \n\n\t\t:::java\n\t\t//Assign the profile name used in EMDKConfig.xml  for Broadcast Intent handling  \n\t\tprivate String profileNameBroadcastIntent = \"DataCaptureProfileBroadcastIntent\";\n\t\n    ![img](images/setup/image190.jpg)\n  \n3. Inside \"onOpened\" add the following code to register the Broadcast Intent EMDK profile. \n\n\t\t:::java\n\t\t//Call processPrfoile for profile Broadcast Intent.  \n\t\tresults = mProfileManager.processProfile(profileNameBroadcastIntent, ProfileManager.PROFILE_FLAG.SET, modifyData);  \n\t\t  \n\t\tif(results.statusCode == STATUS_CODE.FAILURE)  \n\t\t{  \n\t\t//Failed to set profile  \n\t\t}  \n\n    ![img](images/setup/image191.jpg)  \n\n###Handling Broadcast Intents\nNewt we will add the code to listen for our Broadcast Intent and display the Barcode data to the user in side \"BroadcastIntentActivity\". \n\n1. Select \"BroadcastIntentActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/setup/image192.jpg)\n  \n2. Add the following imports.  \n\n\t\t:::java\n\t\timport android.content.BroadcastReceiver;  \n\t\timport android.content.Context;  \n\t\timport android.content.Intent;  \n\t\timport android.content.IntentFilter;  \n\t\timport android.widget.TextView;  \n\n\t![img](images/setup/image193.jpg)\n  \n3. Add a global variable for the TextView. \n\n\t\t:::java\n\t\t//Declare a variable to store the textViewData  \n\t\tprivate TextView textViewData = null;  \n\t\n\t![img](images/setup/image194.jpg)\n\n4. Add the following code to your onCreate function to get a handle on the TextView.\n\n\t\t:::java\n\t\t//Get the textViewData  \n\t\ttextViewData = (TextView) findViewById(R.id.textViewData);  \n\n\t![img](images/setup/image195.jpg)\n  \n5. Add a global variable to BroadcastIntentActivity to hold our Broadcast Receiver.\n\n\t\t:::java\n\t\t//Declare a variable to store our Broadcast Receiver.  \n\t\tprivate BroadcastReceiver EMDKReceiver;  \n     \n    ![img](images/setup/image196.jpg)\n  \n6. Override \"onResume\".  \n\n\t\t:::java\n\t\t@Override  \n\t\tprotected void onResume() {  \n\t\t// TODO Auto-generated method stub  \n\t\t    super.onResume();  \n\t\t} \n\n    ![img](images/setup/image197.jpg)  \n7. Override \"onPause\".  \n\n\t\t:::java\n\t\t@Override  \n\t\tprotected void onPause() {  \n\t\t    // TODO Auto-generated method stub  \n\t\t    super.onPause();  \n\t\t} \n\n    ![img](images/setup/image198.jpg)\n   \n8. Add the following code to \"onResume\" to create an Intent filter.  \n\n\t\t:::java\n\t\t//Create an Intent Filter  \n\t\tIntentFilter intentFilter = new IntentFilter(\"com.symbol.emdksample.RECVRBI\");\n\n\t![img](images/setup/image199.jpg)\n \n9. Add the following code to \"onResume\" to create a Broadcast Receiver.  \n\n\t\t:::java\n\t\t//Create a our Broadcast Receiver.  \n\t\tEMDKReceiver = new BroadcastReceiver() {  \n\t\t  \n\t\t};  \n\n\t![img](images/setup/image200.jpg)\n   \n10. Override \"onReceive\" inside the Broadcast Receiver.  \n\n\t\t:::java\n\t\t@Override  \n\t\tpublic void onReceive(Context context, Intent intent) {  \n\t\t  \n\t\t} \n\n\t![img](images/setup/image201.jpg)\n  \n11. Add the following code to \"onReceive\" to check if the data is coming from the Barcode scanner.  \n\n\t\t:::java\n\t\t//Get the source of the data  \n\t\tString source = intent.getStringExtra(\"com.motorolasolutions.emdk.datawedge.source\");  \n\t\t  \n\t\t//Check if the data has come from the barcode scanner  \n\t\tif(source.equalsIgnoreCase(\"scanner\")){  \n\t\t  \n\t\t} \n\n\t![img](images/setup/image202.jpg)\n  \n12. Add the following code to get the data from the intent.  \n\n\t\t:::java\n\t\t//Get the data from the intent  \n\t\tString data = intent.getStringExtra(\"com.motorolasolutions.emdk.datawedge.data_string\");  \n\t\t  \n\t\t//Check that we have received data  \n\t\tif(data != null && data.length() > 0){  \n\t\t  \n\t\t}\n\n\t![img](images/setup/image203.jpg)\n  \n13. Add the following code to display the data to the TextView.  \n\n\t\t:::java\n\t\t//Display the data to the text view  \n\t\ttextViewData.setText(\"Data = \" + data);  \n\n\t![img](images/setup/image204.jpg)\n  \n14. Add the following code to \"onResume\" to register our receiver.  \n\n\t\t:::java\n\t\t//Register our receiver.\n\t\tthis.registerReceiver(EMDKReceiver, intentFilter);\n\n\t![img](images/setup/image205.jpg)\n  \n15. Add the following code to \"onPause\" to unregister our receiver.  \n\n\t\t:::java\n\t\t//Register our receiver.\n\t\tthis.registerReceiver(EMDKReceiver, intentFilter);\n\n\t![img](images/setup/image206.jpg)  \n\n###Running the Application###\nLastly we will run and test our application. \n\n1. Connect the device (having the latest EMDK runtime) to USB port.\n\n    >Note:   \n    >Make sure the device is in USB debug.\n\n2. Run the application.  \n\n\t![img](images/setup/image207.png)\n  \n3. Press the trigger button and scan a Barcode.  \n\n\t![img](images/setup/image208.png)\n  \n4. Like before the scanned data will be populated in the Edit Text field Through the previous Keystroke Intent and will appear on the TextView using the previous Datawedge Intent.   \n5. Press the button \"Broadcast Intent\".  \n\n\t![img](images/setup/image209.png)\n  \n6. Scan a Barcode.  \n\n\t![img](images/setup/image210.png)\n  \n8. The TextView will be populated by the Broadcast Intent.\n7. Press the back button to rerun to the main screen.  \n\n\t![img](images/setup/image208.png)\n  \n9. Press the button \"MSR\", like before the MSR screen will come up.  \n\n\t![img](images/setup/image171.png)\n\n10. Swipe a cad through the MSR.  \n\n\t![img](images/setup/image172.png)\n\n11. Press return to go back to the MSR where you can swipe another card, or hit return again to go back to the main screen. \n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-UsingBroadcastIntentinDataCaptureProfiles.zip)."},{"key":"guide-tutorial-tutEnableEMDKEclipseADT","name":" Enabling the EMDK in Eclipse with ADT","md":"# Enabling the EMDK in Eclipse with ADT\n## Overview\n\nThis tutorial helps you enabling the EMDK API in your project created in Eclipse with ADT, so that you can access it in your application. This is going to be a common step for all the tutorials that use [EMDK for Android](https://developer.motorolasolutions.com/community/android/emdk) API. \n\n## Enabling the EMDK \n1. Select the project.\n  \n2. Select \"File -> Properties\" or right click on the project and select \"Properties\".\n  \n    ![img](images/setup/image011.jpg)\n   \n    ![img](images/setup/image013.jpg)\n   \n3. Click \"Android\" from the left pane.\n  \n    ![img](images/setup/image037.jpg)\n \n4. Select the \"EMDK\" target name from the list of Project Build Targets for the API version you require.  \n    ![img](images/setup/image039.jpg)  \n\n    >Note:  \n    >If an \"EMDK...\" target name is not on the list of Build Targets, please confirm you have installed Android API 16 SDK Platform.\n\n5. Click \"Apply\" and \"OK\".  \n    >Note:  \n    >The EMDK library will be added to the project.  \n    \n    ![img](images/setup/image041.jpg) \n\n    >Note:\n    >If you are using Java 1.7 as the compiler, you may see this error\n    \n    ![img](images/setup/compiler_error.jpg) \n\n    > To correct this, you will need to change the compiler to use 1.6\n    \n    > * Click on the Java Compiler\n    > * Click Enable project specific settings\n    > * Select 1.6 for Compiler compliance level\n    \n    ![img](images/setup/image101.jpg)"},{"key":"guide-tutorial-tutModifyBarcodeProfileSettings","name":" Modifying Profiles With ProfileConfig API","md":"# Modifying Profiles With ProfileConfig API\n\n## Overview\nThis guide will walk you through creating an EMDK For Android application that will make use [Profile Config](#api-ProfileConfig) object to modify Profile Settings programmatically in order to get barcode data into your application using the [KeyStroke output](#guide-profiles-profilekeystroke) feature of [EMDK Profiles](#guide-profiles-usingwizard).\n\n###Prerequisites###\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android 2.0 and above\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"ModifyBarcodeProfileTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding a DataCapture Profile\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"ModifyBarcodeProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code. \n   \n3. Now, you can see all the available features on the left hand side of the Profile Editor window. Select any feature from the list and click \"Right Arrow\" (Ex: \"ActivitySelection\" has been selected. By using this feature Activities can be associated with the application. Then the data capture feature will be enabled automatically when the specified activity is in foreground).\n  \n\t![img](images/modify_profile_settings_images/activity_selection.jpg)\n  \n4. Provide the name to identify each feature (Ex: DataCaptureActivity). This is required while editing features programmatically.  \n\n\t![img](images/modify_profile_settings_images/activity_selection_parameters.jpg)\n  \n5. Click \"ActivitySelection\" under parameters.  \n\n\t![img](images/modify_profile_settings_images/activity_selection_parameter_package_name.jpg)  \n\n6. Specify the applications package name and click \"Apply\".  \n\n\t![img](images/modify_profile_settings_images/activity_selection_parameter_activity_name.jpg) \n \n7. Specify an Activity inside the application and click \"Apply\".  \n\n\t![img](images/modify_profile_settings_images/activity_selection_done.jpg)  \n\n8. Click \"OK\".  \n9. Select any data capture feature and click Right Arrow (Ex: \"Barcode\" has been selected).\n  \n\t![img](images/modify_profile_settings_images/barcode.jpg)\n  \n10. Click on the \"Barcode\" feature in the \"Data Input\" section. The parameter list will be populated. \n \n\t![img](images/modify_profile_settings_images/barcode_profile_editor.jpg)\n  \n11. Provide name to Barcode Scanner Input so as to modify it programmatically (Ex: DataInputBarcode). Enable the feature and change some parameters.\n  \n\t![img](images/modify_profile_settings_images/barcode_select_scanner_type.jpg)\n  \n\t![img](images/modify_profile_settings_images/barcode_select_decoders.jpg)\n  \n12. Click \"Apply\". \n\n13. Select the Keystroke feature in the \"Data Delivery\" section and click \"Right Arrow\" (Ex: \"Keystroke\" has been selected).\n  \n\t![img](images/modify_profile_settings_images/keystroke_editor.jpg)  \n\n14. Provide name to Keystroke output (Ex: DataDeliveryKeystroke). This is required when editing the features programmatically. Enable the feature and change some parameters. \n \n\t![img](images/modify_profile_settings_images/enable_keystroke.jpg)\n  \n\t![img](images/modify_profile_settings_images/enable_keystroke_data_formatting.jpg)\n  \n15. Click \"Apply\" and \"Finish\".  \n\n\t![img](images/modify_profile_settings_images/profile_editing_done.jpg) \n \n16. Click \"Close\".  \n\n\t> Note: \n    > Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n17. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n\t![img](images/modify_profile_settings_images/emdk_config_activity_selection_changes.jpg)\n   \n\t![img](images/modify_profile_settings_images/emdk_config_keystroke_changes.jpg)   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK. \n \n\t![img](images/modify_profile_settings_images/manifest_file_default.jpg)\n\n\tYou must first enable permissions for 'com.symbol.emdk.permission.EMDK':\n\n    \t:::xml\n    \t<uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n\n\tThen you must enable the library:\n  \n    \t:::xml\n    \t<uses-library android:name=\"com.symbol.emdk\" />\n\n\tWhen done, your manifest.xml should look like:\n\n\t![img](images/modify_profile_settings_images/manifest_file_updated.jpg)  \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n\tFirst you must add references to the libraries:\n  \n    \t:::java\n    \timport com.symbol.emdk.*;\n    \timport com.symbol.emdk.EMDKManager.EMDKListener;\n\n\tThen you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n\t    :::java\n\t    public class MainActivity extends Activity implements EMDKListener {\n\t         .. .. .. .. .. .. ...\n\t\n\t        @Override\n\t        public void onClosed() {\n\t\n\t               // TODO Auto-generated method stub\n\t\n\t        }\n\t        @Override\n\t        public void onOpened(EMDKManager emdkManager) {\n\t\n\t               // TODO Auto-generated method stub\n\t\n\t         }\n\t    }\t\t    \n\n    \n\tWe will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager that we will use throughout the code:\n\n\t    :::java\n\t    //Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"ModifyBarcodeProfile\";\n\t\n\t    //Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\t\n\t    //Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\t\t\n\tIn the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n\t    :::java\n\t    // The EMDKManager object creation\n\t    // The EMDKManager object will be returned in the callback.\n\t    EMDKResults results = EMDKManager.getEMDKManager(\n\t    \t\tgetApplicationContext(), this);\n\t\n\t    // Check the return status of processProfile\n\t    if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\t\n\t      // EMDKManager object creation success\n\t\n\t    \t} else {\n\t\n\t      // EMDKManager object creation failed\n\t    \t}\n    \n\tSo far your code should look like:\n     \n\t![img](images/modify_profile_settings_images/main_activity_declare_profile_name.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n  \n\t    :::java\n\t    this.emdkManager = emdkManager;\n\n        //Get the ProfileManager object to process the profiles\n        profileManager = (ProfileManager) emdkManager.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);\n\n\t> Note: \n\t> Sometimes the default parameter in `onOpened` method is `arg0`. So you have to rename that parameter to `emdkManager`.\n    \n\tNow that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\tSo the `onOpened` method now looks like:\n\n\t    :::java\n\t    @Override\n\t    public void onOpened(EMDKManager emdkManager) {\n\t     this.emdkManager = emdkManager;\n\t\n\t      // Get the ProfileManager object to process the profiles\n\t      profileManager = (ProfileManager) emdkManager\n\t    \t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);\n\t\n\t      String[] modifyData = new String[1];\n\t\n\t      // Call processPrfoile with profile name and SET flag to create the\n\t      // profile. The modifyData can be null.\n\t      EMDKResults results = profileManager.processProfile(profileName,\n\t    \t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\t\n\t      // Check the return status of processProfile\n\t      if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\t    \tToast.makeText(MainActivity.this, \"Profile initialization Success\",\n\t    \t\t\tToast.LENGTH_SHORT).show();\n\t\n\t      } else {\n\t    \tToast.makeText(MainActivity.this, \"Profile initialization failed\",\n\t    \t\t\tToast.LENGTH_SHORT).show();\n\t      }\n\t\n\t    }   \n \n\tYour onOpened method should now look like this:\n    \n\t![img](images/modify_profile_settings_images/onopened_method.jpg)  \n    \n3. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:\n\n\t    :::java\n\t    @Override\n\t    protected void onDestroy() {\n\t    \t// TODO Auto-generated method stub\n\t    \tsuper.onDestroy();\n\t\n\t    \t// Clean up the objects created by EMDK manager\n\t    \temdkManager.release();\n\t    }\n\n\tYour onDestroy method should now look like this: \n\n\t![img](images/modify_profile_settings_images/on_destroy_method.jpg) \n\n4. Now lets add some of the string values in \"res/values/strings.xml\" that we would be using in our layout files.\n\n\t    :::xml\n\t    <string name=\"code128_string\">Code128</string>\n\t      <string name=\"code39_string\">Code39</string>\n\t      <string name=\"EAN8_string\">EAN8 </string>\n\t      <string name=\"EAN13_string\">EAN13 </string>\n\t      <string name=\"UPCE_string\">UPCA </string>\n\t      <string name=\"UPCE0_string\">UPCE0 </string>\n\t      <string name=\"button_set_string\">Update Settings </string>\n\n5. Remove the default code, inside \"res/layout/activity_main.xml\".\n\n6. add the following code, inside \"res/layout/activity_main.xml\". This code contains some checkboxes that represent some of the barcode types. We will change the status of these barcode types \"Enable/Disable\" programmatically.\n\n    The code also contains a Drop-Down (Spinner) that we would be using to select a specific type of barcode scanner device programmatically.\n\n\tAt the bottom, the layout file contains a button \"Update Settings\" that is used to apply settings selected by the user.\n\n\t    :::xml\n\t    <ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t      android:layout_width=\"fill_parent\"\n\t      android:layout_height=\"fill_parent\" >\n\t\n\t        <RelativeLayout\n\t          android:layout_width=\"match_parent\"\n\t          android:layout_height=\"wrap_content\"\n\t          android:padding=\"10dip\" >\n\t\n\t          <Button\n\t            android:id=\"@+id/btn_barcode\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_centerHorizontal=\"true\"\n\t            android:layout_margin=\"10dip\" />\n\t\n\t          <Spinner\n\t            android:id=\"@+id/scanner_type_spinner\"\n\t            android:layout_width=\"match_parent\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_below=\"@+id/btn_barcode\" />\n\t\n\t          <CheckBox\n\t            android:id=\"@+id/checkBoxEAN8\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_alignParentLeft=\"true\"\n\t            android:layout_below=\"@+id/scanner_type_spinner\"\n\t            android:layout_marginBottom=\"5dip\"\n\t            android:layout_marginLeft=\"5dip\"\n\t            android:layout_marginRight=\"5dip\"\n\t            android:layout_marginTop=\"20dp\"\n\t            android:checked=\"true\"\n\t            android:enabled=\"true\"\n\t            android:text=\"@string/EAN8_string\" />\n\t\n\t          <CheckBox\n\t            android:id=\"@+id/checkBoxEAN13\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_alignParentRight=\"true\"\n\t            android:layout_below=\"@+id/scanner_type_spinner\"\n\t            android:layout_marginBottom=\"5dip\"\n\t            android:layout_marginLeft=\"5dip\"\n\t            android:layout_marginRight=\"12dip\"\n\t            android:layout_marginTop=\"20dip\"\n\t            android:text=\"@string/EAN13_string\" />\n\t\n\t          <CheckBox\n\t            android:id=\"@+id/checkBoxUPCA\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_alignParentLeft=\"true\"\n\t            android:layout_below=\"@+id/checkBoxEAN8\"\n\t            android:layout_margin=\"5dip\"\n\t            android:checked=\"true\"\n\t            android:enabled=\"true\"\n\t            android:text=\"@string/UPCE_string\" />\n\t\n\t          <CheckBox\n\t            android:id=\"@+id/checkBoxUPCE0\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_alignParentRight=\"true\"\n\t            android:layout_below=\"@+id/checkBoxEAN13\"\n\t            android:layout_marginBottom=\"5dip\"\n\t            android:layout_marginLeft=\"5dip\"\n\t            android:layout_marginRight=\"12dip\"\n\t            android:layout_marginTop=\"5dip\"\n\t            android:text=\"@string/UPCE0_string\" />\n\t\n\t          <CheckBox\n\t            android:id=\"@+id/checkBoxCode128\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_alignParentLeft=\"true\"\n\t            android:layout_below=\"@+id/checkBoxUPCA\"\n\t            android:layout_margin=\"5dip\"\n\t            android:checked=\"true\"\n\t            android:enabled=\"true\"\n\t            android:text=\"@string/code128_string\" />\n\t\n\t          <CheckBox\n\t            android:id=\"@+id/checkBoxCode39\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_alignParentRight=\"true\"\n\t            android:layout_below=\"@+id/checkBoxUPCE0\"\n\t            android:layout_margin=\"5dip\"\n\t            android:text=\"@string/code39_string\" />\n\t\n\t          <EditText\n\t            android:id=\"@+id/editText\"\n\t            android:layout_width=\"match_parent\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_below=\"@+id/checkBoxCode39\"\n\t            android:layout_margin=\"10dip\"\n\t            android:ems=\"5\"\n\t            android:inputType=\"none\"\n\t            android:scrollbars=\"vertical\" />\n\t\n\t          <Button\n\t            android:id=\"@+id/btn_set\"\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_below=\"@+id/editText\"\n\t            android:layout_centerHorizontal=\"true\"\n\t            android:layout_margin=\"20dip\"\n\t            android:text=\"@string/button_set_string\" />\n\t      </RelativeLayout>\n\t    </ScrollView>\t\t\n\t\n\tYour activity_main.xml file should now look like this:\n\n\t![img](images/modify_profile_settings_images/create_layout.jpg)\n    \n7. Next, we will declare these UI elements in our activity class by writing following code in \"MainActivity.java\" class.\n  \n\t    :::java\n\t    // CheckBox for Barcode type 128\n\t    private CheckBox checkBoxCode128;\n\t    // CheckBox for Barcode type 39\n\t    private CheckBox checkBoxCode39;\n\t    // CheckBox for Barcode type EAN8\n\t    private CheckBox checkBoxEAN8;\n\t    // CheckBox for Barcode type EAN13\n\t    private CheckBox checkBoxEAN13;\n\t    // CheckBox for Barcode type UPCA\n\t    private CheckBox checkBoxUPCA;\n\t    // CheckBox for Barcode type UPCE0\n\t    private CheckBox checkBoxUPCE0;\n\t\n\t    // Drop down that displays a list of available types of scanners\n\t    private Spinner scannerTypeSpinner;\n\t\n\t    // Button for updating changes made in the barcode types.\n\t    private Button setButton;\n\t\n\t    // Button to specify current status of the Barcode.\n\t    private Button barcodeStatusButton;\n\t\t\n\n\t> Note: If you are using Android Studio, press CTRL+ALT+O or CMD+ALT+O to organize imports.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+O or CMD+SHFT+O to organize imports.\n\n\tSo declaration of UI elements would look like:\n\n\t![img](images/modify_profile_settings_images/declare_ui_elements.jpg)\n\n\n8. We will now get reference of these UI elements in the 'onCreate()' method of 'MainActivity.java' class as follows:\n\n\n\t    :::java\n\t    // Get references of the checkboxes declared in the UI\n\t    checkBoxCode128 = (CheckBox) findViewById(R.id.checkBoxCode128);\n\t    checkBoxCode39 = (CheckBox) findViewById(R.id.checkBoxCode39);\n\t    checkBoxEAN8 = (CheckBox) findViewById(R.id.checkBoxEAN8);\n\t    checkBoxEAN13 = (CheckBox) findViewById(R.id.checkBoxEAN13);\n\t    checkBoxUPCA = (CheckBox) findViewById(R.id.checkBoxUPCA);\n\t    checkBoxUPCE0 = (CheckBox) findViewById(R.id.checkBoxUPCE0);\n\t\n\t    // Get references of all the buttons declared in the UI\n\t    setButton = (Button) findViewById(R.id.btn_set);\n\t    barcodeStatusButton = (Button) findViewById(R.id.btn_barcode);\n\t\n\t    // Get the reference scanner type spinner\n\t    scannerTypeSpinner = (Spinner) findViewById(R.id.scanner_type_spinner);\n\t\t\n\tThe onCreate() method at this point should look like this:\n\n\t![img](images/modify_profile_settings_images/references_of_ui_elements.jpg)\n\n9. In the next step, we will set the list of scanning devices in the drop down [Spinner](http://developer.android.com/guide/topics/ui/controls/spinner.html)\n\n\tIn order to implement that, we have created an 'Arraylist' of Strings that contains the list of scanner devices that the user can select to scan Barcodes. This list will be set in an Array Adapter.\n\n\tWe have implemented an 'on item selected listener' for this spinner, which would select respective type of scanning device programmatically.\n\n\tAdd the following code in the onCreate() method after references of UI elements:\n\n\t    :::java\n\t    // List that contains supported scanning device types\n\t      List<String> scannerTypeList = new ArrayList<String>();\n\t    scannerTypeList.add(\"AUTO\");\n\t    scannerTypeList.add(\"INTERNAL_LASER1\");\n\t    scannerTypeList.add(\"INTERNAL_IMAGER1\");\n\t    scannerTypeList.add(\"INTERNAL_CAMERA1\");\n\t\n\t    // Adapter to hold the list of scanning device types.\n\t    ArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(this,\n\t    \t\tandroid.R.layout.simple_spinner_item, scannerTypeList);\n\t    dataAdapter\n\t    \t\t.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\n\t    // Set the adapter to the spinner\n\t    scannerTypeSpinner.setAdapter(dataAdapter);\n\t\n\t    // On Item Selected Listener of Spinner items.\n\t    scannerTypeSpinner\n\t    \t\t.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\n\t    @Override\n\t    public void onItemSelected(AdapterView<?> parent,\n\t    \t\t\t\t\tView view, int position, long id) {\n\t\n\t    \t// Set the user selected device type as scanning device.\n\t    \tsetDeviceType(parent.getItemAtPosition(position)\n\t    \t\t\t\t\t\t.toString());\n\t\n\t    }\n\t\n\t    @Override\n\t    public void onNothingSelected(AdapterView<?> parent) {\n\t    \t// TODO Auto-generated method stub\n\t\n\t    \t}\n\t    });\n\n        \n\tThe onCreate() method should now look like this:\n\n\t![img](images/modify_profile_settings_images/drop_down_details.jpg)\n\n\n10. The method 'setDeviceType()' takes the position of the user selected device type from the drop down and modifies the profile settings by accessing Profile Manager API.\n \n\tIn order to get access to the Profile Manager's API, EMDK provides three ways:   \n    \n\t* Document - data will be handled as a XML Document\n\t* String - data will be handled as a raw string\n\t* ProfileConfig - data will be handled as a ProfileConfig class \n      \n\tThe preferred way is to use the profileConfig option and the examples below present using such option. Using the Document or String methods may not work if the XML is not structured properly.\n\n\tSo, we will create reference of 'ProfileConfig' in the MainActivity.java class.\n\n\t    :::java\n\t    // Profile Config reference for modifying Profiles.\n\t    private ProfileConfig profileConfigObj = null;\t\t\n\n\tThis would look like:\n\n\t![img](images/modify_profile_settings_images/profile_config_declaration.jpg)\n\n11. In the 'setDeviceType method, we create an object of 'ProfileConfig' class. To modify a profile, we would:\n  * Use the PROFILE_FLAG.GET option to retrieve the profile (if it exists)\n  * Use the profileConfig Object and APIs to modify the settings\n  * Use the PROFILE_FLAG.SET option to save the settings.\n\t\n\tThe user would be notified via [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html) if the profile does not exist.\n\n\tThe method accepts a String argument, which is the type of scanning device selected by the user from drop down. Based on this parameter, the problemConfig object would be modified and set to the user selected device type.\n\n\tHere's the code for selecting specific type of scanning device programmatically by  modifying the profileConfig object in 'setDeviceType' method.  \n\n\t    :::java\n\t    // Sets the scanner device type selected by user from the spinner\n\t    public void setDeviceType(String deviceType) {\n\t     // Create the ProfileConfig object\n\t     profileConfigObj = new ProfileConfig();\n\t     // Get the ProfileConfig from the profile XML\n\t     EMDKResults results = profileManager.processProfile(profileName,\n\t    \t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t\n\t     // Check the return status of processProfile\n\t     if (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\t    \tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t    \t\t\tToast.LENGTH_SHORT).show();\n\t    \treturn;\n\t     }\n\t     // Set the profile config object to the user selected device type from\n\t     // the spinner\n\t     if (deviceType.equalsIgnoreCase(\"AUTO\")) {\n\t    \tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.AUTO;\n\t     } else if (deviceType.equalsIgnoreCase(\"INTERNAL_LASER1\")) {\n\t    \tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.INTERNAL_LASER1;\n\t     } else if (deviceType.equalsIgnoreCase(\"INTERNAL_CAMERA1\")) {\n\t    \tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.INTERNAL_CAMERA1;\n\t     } else {\n\t    \tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.INTERNAL_IMAGER1;\n\t     }\n\t     // Call processPrfoile with profile name, SET flag and config data\n\t     // to update the profile\n\t     results = profileManager.processProfile(profileName,\n\t    \t\tProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\t\n\t     // Check the return status of processProfile\n\t     if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\t\n\t    \t// Device type selected\n\t\n\t     } else {\n\t\n\t    \t// Failed to select device type\n\t     }\n\t    }\n\n\n\tSo the method would look like:\n\n\t![img](images/modify_profile_settings_images/set_device_type_method.jpg)\n\n12. Similarly we would now use this 'profileConfig' object for modifying other parameters. one of these will be to check the status of the barcode (Enable/Disable)\n\n\tOnce the profile is retrieved using 'PROFILE_FLAG.GET', we will check 'profileConfigObj.dataCapture.barcode.scanner_input_enabled' parameter in the 'checkBarcodeStatus' method and set the status on the 'barcodeStatusButton'. This method is called when the EMDK Manager is ready in the 'onOpened()' method of the 'MainActivity.java' file.\n\n\tcall 'checkBarcodeStatus()' method from 'onOpened()' method\n\n\t    :::java\n\t    checkBarcodeStatus();\n\n\tSo the complete onOpened() method looks like this:\n\n\t![img](images/modify_profile_settings_images/check_barcode_status_method_call.jpg)\n\n\tThe code for checkBarcodeStatus() method looks like this:\n\n\t    :::java\n\t    // Check and display the status of the Barcode on the button\n\t    // (Enable/Disable)\n\t    public void checkBarcodeStatus() {\n\t     // Create the ProfileConfig object\n\t     profileConfigObj = new ProfileConfig();\n\t\n\t     // Get the ProfileConfig from the profile XML\n\t     EMDKResults results = profileManager.processProfile(profileName,\n\t    \t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t\n\t     // Check the return status of processProfile\n\t     if (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\t\n\t    \tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t    \t\t\tToast.LENGTH_SHORT).show();\n\t    \treturn;\n\t\n\t     }\n\t\n\t     if (profileConfigObj.dataCapture.barcode.scanner_input_enabled == ENABLED_STATE.FALSE) {\n\t    \tbarcodeStatusButton.setText(\"Enable Barcode\");\n\t     } else {\n\t    \tbarcodeStatusButton.setText(\"Disable Barcode\");\n\t     }\n\t\n\t    }\t\t\n\n\tThe checkBarcodeStatus() method finally looks like:\n\n\t![img](images/modify_profile_settings_images/check_barcode_status_method.jpg)\n  \n\n13. Apart from this, we have few checkboxes that represent different types of barcode and two buttons 'Barcode' and 'Update Settings'.\n    \n\tLets concentrate on the top button that allows user to Enable/Disable Barcode scanning programatically using profileConfig object. If the scanning is enabled, the user can disable it by pressing 'Disable Barcode' button so that the application will not be able to scan any barcode. If the scanning is disabled, the user can enable it by pressing 'Enable Barcode' button.\n\n\tThe checkboxes represent different types of barcode types that can be scanned using this application. The user can select the desired types of barcodes that need to be scanned by the application.\n\n\tOnce the checkboxes have been selected, the user will press 'Update Profile' button that would update the profile settings based on users selection.\n\n\tSo we will implement both of these functionalities using 'profileConfig' object. \n\n\tIn order to implement this, we need to implement 'on click listener' of both of these buttons. We can do it by writing a common 'on click' method and perform operations based on the button ID's.\n\n\tSo we will set the 'on click listener' on these two buttons using following code:\n\n\t    :::java\n\t    // Set the on click listeners on buttons\n\t    setButton.setOnClickListener(onClickListener);\n\t    barcodeStatusButton.setOnClickListener(onClickListener);\t\t\n\n\tThis makes the onCreate() method looks like:\n\n\t![img](images/modify_profile_settings_images/button_on_click_declaration.jpg)\n\n\tWe would now write the on click listener that has the common onclick method in which we have called the respective operations based on button ID's.\n\n\t    :::java\n\t    // Common on Click Listener for all buttons\n\t    private OnClickListener onClickListener = new OnClickListener() {\n\t\n\t    @Override\n\t    public void onClick(View view) {\n\t    \tint id = view.getId();\n\t    \tswitch (id) {\n\t    \t// On Click Listener for Set Button\n\t    \tcase R.id.btn_set:\n\t    \t\t// Create the ProfileConfig object\n\t    \t\tif (profileConfigObj.dataCapture.barcode.scanner_input_enabled == ENABLED_STATE.FALSE)\n\t    \t\t\tToast.makeText(MainActivity.this,\n\t    \t\t\t\t\t\"Please Enable Barcode to update settings...\",\n\t    \t\t\t\t\tToast.LENGTH_SHORT).show();\n\t    \t\telse\n\t    \t\t\tupdateProfile();\n\t    \t\tbreak;\n\t    \t// On Click Listener for Barcode Button\n\t    \tcase R.id.btn_barcode:\n\t    \t\tsetBarcodeStatus();\n\t    \t\tbreak;\n\t\n\t    \tdefault:\n\t    \t\tbreak;\n\t    \t}\n\t      }\n\t    };\t\t \n\n\tSo the on click listener would finally look like:\n\n\t![img](images/modify_profile_settings_images/button_on_click_defination.jpg)\n\n\t>Note:   \n\t>We have shown Toast messages wherever necessary to inform user about the operations being performed.\n\n14. As explained earlier, the button Barcode is used for updating the Barcode status using profileConfig object by calling 'setBarcodeStatus' method.\n\n\tSo the 'setBarcodeStatus()' method can be implemented as:\n\n\t    :::java\n\t    // Sets the status of the Barcode (Enable/Disable)\n\t    public void setBarcodeStatus() {\n\t     // Create the ProfileConfig object\n\t     profileConfigObj = new ProfileConfig();\n\t\n\t     // Get the ProfileConfig from the profile XML\n\t     EMDKResults results = profileManager.processProfile(profileName,\n\t    \t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t\n\t     // Check the return status of processProfile\n\t     if (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\t\n\t    \tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t    \t\t\tToast.LENGTH_SHORT).show();\n\t    \treturn;\n\t\n\t     }\n\t\n\t     if (barcodeStatusButton.getText().toString()\n\t    \t\t.equalsIgnoreCase(\"Enable Barcode\")) {\n\t    \t//Barcode is enabled so disable it.\n\t    \tprofileConfigObj.dataCapture.barcode.scanner_input_enabled = ENABLED_STATE.TRUE;\n\t    \tbarcodeStatusButton.setText(\"Disable Barcode\");\n\t\n\t     } else {\n\t    \t//Barcode is disabled so enable it.\n\t    \tprofileConfigObj.dataCapture.barcode.scanner_input_enabled = ENABLED_STATE.FALSE;\n\t    \tbarcodeStatusButton.setText(\"Enable Barcode\");\n\t\n\t     }\n\t\n\t     // Call processPrfoile with profile name, SET flag and config data\n\t     // to update the profile\n\t     results = profileManager.processProfile(profileName,\n\t    \t\tProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\t\n\t     // Check the return status of processProfile\n\t     if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\t\n\t    \tToast.makeText(MainActivity.this, \"Barcode Status updated\",\n\t    \t\t\tToast.LENGTH_SHORT).show();\n\t\n\t     } else {\n\t    \tToast.makeText(MainActivity.this, \"Barcode status update failed\",\n\t    \t\t\tToast.LENGTH_SHORT).show();\n\t     }\n\t\n\t    }\n\n\tsetBarcodeStatus() method would look like:\n\n\t![img](images/modify_profile_settings_images/set_barcode_status_method.jpg)\n \n\n15. Finally, we would implement the on click listener for 'Update Profile' by calling 'updateProfile' method. This method would update the status of all the checkboxes (Enable/Disable) that represent the various barcode types.\n\n\tSo if a particular barcode checkbox is unchecked, the user will not be able to scan that specific type of barcode and vice-versa.\n\n\tWe will define the 'updateProfile' method as follows:\n\n\t    :::java\n\t    // Updates the profile based on user selected attributes\n\t    public void updateProfile() {\n\t      String resultString = \"\";\n\t      try {\n\t\n\t    \t// Create the ProfileConfig object\n\t    \tprofileConfigObj = new ProfileConfig();\n\t\n\t    \t// Get the ProfileConfig from the profile XML\n\t    \tEMDKResults results = profileManager.processProfile(profileName,\n\t    \t\t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t\n\t    \t// Check the return status of processProfile\n\t    \tif (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\t\n\t    \t\tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t    \t\t\t\tToast.LENGTH_SHORT).show();\n\t    \t\treturn;\n\t\n\t    \t }\n\t\n\t    \t // Set the code128\n\t    \t if (checkBoxCode128.isChecked()) {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.code128 = ENABLED_STATE.TRUE;\n\t\n\t    \t  } else {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.code128 = ENABLED_STATE.FALSE;\n\t    \t  }\n\t\n\t    \t // set code39\n\t    \t if (checkBoxCode39.isChecked()) {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.code39 = ENABLED_STATE.TRUE;\n\t\n\t    \t } else {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.code39 = ENABLED_STATE.FALSE;\n\t    \t }\n\t\n\t    \t // set EAN8\n\t    \t if (checkBoxEAN8.isChecked()) {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.ean8 = ENABLED_STATE.TRUE;\n\t\n\t    \t } else {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.ean8 = ENABLED_STATE.FALSE;\n\t    \t }\n\t\n\t    \t // set ENA13\n\t    \t if (checkBoxEAN13.isChecked()) {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.ean13 = ENABLED_STATE.TRUE;\n\t\n\t    \t } else {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.ean13 = ENABLED_STATE.FALSE;\n\t    \t }\n\t\n\t    \t // set upca\n\t    \t if (checkBoxUPCA.isChecked()) {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.upca = ENABLED_STATE.TRUE;\n\t\n\t    \t } else {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.upca = ENABLED_STATE.FALSE;\n\t    \t }\n\t\n\t    \t // set upce0\n\t    \t if (checkBoxUPCE0.isChecked()) {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.upce0 = ENABLED_STATE.TRUE;\n\t\n\t    \t } else {\n\t\n\t    \t\tprofileConfigObj.dataCapture.barcode.decoders.upce0 = ENABLED_STATE.FALSE;\n\t    \t }\n\t\n\t    \t // Call processPrfoile with profile name, SET flag and config data\n\t    \t // to update the profile\n\t    \t results = profileManager.processProfile(profileName,\n\t    \t\t\tProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\t\n\t    \t // Check the return status of processProfile\n\t    \t if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\t\n\t    \t\tToast.makeText(MainActivity.this,\n\t    \t\t\t\t\"Profile successfully updated\", Toast.LENGTH_SHORT)\n\t    \t\t\t\t.show();\n\t\n\t    \t } else {\n\t    \t\tToast.makeText(MainActivity.this, \"Profile update failed\",\n\t    \t\t\t\tToast.LENGTH_SHORT).show();\n\t    \t}\n\t\n\t      } catch (Exception ex) {\n\t    \tresultString = ex.getMessage();\n\t    \tToast.makeText(MainActivity.this, resultString, Toast.LENGTH_SHORT)\n\t    \t\t\t.show();\n\t      }\n\t    }\n\n\tSo the updateProfile method looks like:\n\n\t![img](images/modify_profile_settings_images/update_profile_method.jpg)\n\n\tSo now we are done with the coding part. Lets test our application.\n\n## Running the Application\n1. Connect the device (having the latest EMDK runtime) to USB port.\n\n\t>Note:   \n\t>Make sure the device is in USB debug.\n\n2. Run the application.  \n\n\t![img](images/modify_profile_settings_images/initial_screen.png)\n\n3. Enable/Disable Barcode scanning by pressing Barcode button on top of the screen. \n\n\t>Note: If the barcode disabled, you will not be able to scan any type of barcode.\n\n\t![img](images/modify_profile_settings_images/update_barcode_status.png)\n\n4. Choose the specific type of barcode scanning device from the drop down.\n\n\t![img](images/modify_profile_settings_images/drop_down_for_device_type.png)  \n\n5. Now select the desired barcode types from the checkboxes and press the Update Settings button. This will modify the profile settings.\n\n\t![img](images/modify_profile_settings_images/update_settings.png)\n\n\tNow press trigger button to scan the respective types of barcodes.\n\n6. The scanned data will be populated in the Edit Text field added to the UI.\n\t>Note:\n    > Only those typs of barcodes will be scanned that are checked in the checkboxes.\n  \n\t![img](images/modify_profile_settings_images/scan_data.png)  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n  >Note:\n  >* Include the permission for EMDK:  \n  \n    \t:::xml\n    \t<uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n  >Note:\n  >* Use the EMDK library:  \n    \n    \t:::xml\n    \t<uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. When using the \"Barcode\" feature in EMDK Wizard, the specified value for \"Scanner\" is not supported on the device, it will be considered as \"Auto\" during runtime (Ex: BT_LASER1, BT_IMAGER1 and BT_CAMERA1).\n3. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device. \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-ModifyBarcodeProfileTutorial.zip)."},{"key":"guide-tutorial-tutMxAccessManager","name":" Controlling Application Access using Access Manager","md":"# Controlling Application Access using Access Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on controlling access to the device's applications using [Access Manager](#guide-profiles-access) feature of Mx. The [Access Manager](#guide-profiles-access) feature allows you to configure a set of applications that will be allowed to run and install on the device. When a profile with this feature is enabled, the device will only allow user installed applications on the Whitelist to be executed and/or installed (some applications that are part of the default operating system will still be available). To disable the Whitelist, you would select \"Single User Without Whitelist\". Overall, the Access Manager supports following features.\n\n   > Note: \"Enable Whitelist\" refers to \"Single User Mode with Whitelist\". \"Disable Whitelist\" refers to \"Single User Mode without Whitelist\" options in the wizard.\n\n**1. Enable/Disable single user mode white list:**\n\nThis feature allows user to Enable or Disable the single user mode white list. When the single user white list mode is enabled, user can see only those apps that have been added to the white list and have access restrictions. The user can see all the applications when single user mode white list is disabled.   \n\n**2. Add packages to the white list:**\n\nWhen the single user mode white list is enabled, user can add application package to the white list and set restricted access to that particular application (Ex. com.symbol.emdkmxaccessmanagertutorial). user can also add multiple applications to the white list separated by commas to control access across multiple applications (Ex. com.symbol.emdkmxaccessmanagertutorial,com.symbol.emdkmxclocktutorial,com.symbol.mxgprstutorial). \n\n   > Note: Make sure to add executing EMDK application to the white list in order to set access restrictions on other applications. otherwise your application will lose control of the Whitelist configuration and you will not be able to change the behavior until you perform Enterprise Reset on the device to get the default settings back.  \n\n**3. Remove specific packages from the white list:**  \n\nUser can remove specific package(s) from the white list. If we want to remove multiple applications from white list, we need to specify their package names separated by commas (Ex. com.testapp1, com.testapp2, com.testapp3).\n\n   > Note: Package names are unique identifiers of Android applications. Hence the API requires package names to refer any specific application.   \n\n**4. Remove all packages from the white list:**\n\nWhen the device has lots of applications in the white list and if we want to remove all applications from white list then we can use this feature of Access Manager. It prevents user from adding all the package names manually, which could be time consuming.\n\n**5. Control the behavior of the system settings menu when in single user mode white list:**\n\nWhen the single user mode white list is enabled, user can control the behavior of the system settings menu that lets user control the level of access to the applications added in the white list. The user can either provide \"Full Access\" or \"Reduced Access\" to the applications that have been added to the white list.\n\nSo now we will create a tutorial to demonstrate how to Add/Remove applications to/from single user mode white list and observe the difference when the single user white list mode is changed (Enabled/Disabled) programmatically. \n  \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxAccessManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The Access Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"AccessManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.\n\n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Access Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxAccessManagerTutorialImages/access_manager_feature.jpg)\n\n    As mentioned earlier you can see the drop down showing two options in the operation Mode. First one is Single user without whitelist and second is single user with whitelist. We would demonstrate both of these feature programatically using Access Manager API later in this tutorial. But for now, lets us configure one of these two operation modes from the wizard. This is to show you that we can modify any Mx feature both programmatically as well as using wizrad. Hence select Operation mode as \"Single User Without Whitelist\". \n\n\tProvide some name to refer this feature programmatically in order to modify it (Ex. MyAccessMgr).You can also keep the \"Name\" field empty.    \n\n    ![img](images/MxAccessManagerTutorialImages/access_mgr_details.jpg)   \n \n4. Click Apply to apply the settings we provided. This setting would display all the applications that have not been added to the whitelist.    \n  \n    ![img](images/MxAccessManagerTutorialImages/access_profile_applied.jpg)\n\n5. Click Finish and your Access Manager profile is created that would display all applications, which are not in the whitelist. We would configure rest of the features programmatically later in this tutorial.\n\n    ![img](images/MxAccessManagerTutorialImages/access_manager_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxAccessManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxAccessManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxAccessManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"AccessManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxAccessManagerTutorialImages/on_create_added.jpg)\n\n2. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxAccessManagerTutorialImages/on_destroy_method.jpg) \n\n3. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:  \n\n        :::java\n        if (profileManager != null) {\n\t\t    String[] modifyData = new String[1];\n\t\t\n\t\t  // Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t  EMDKResults results = profileManager.processProfile(profileName,\n\t\t            ProfileManager.PROFILE_FLAG.SET, modifyData);\n\t\t\n\t\t  if (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\t\t\n\t\t\n\t\t  } else {\n\t\t    // Show dialog of Failure\n\t\t      AlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t      builder.setTitle(\"Failure\");\n\t\t      builder.setMessage(\"Failed to apply profile...\")\n\t\t              .setPositiveButton(\"OK\",\n\t\t                    new DialogInterface.OnClickListener() {\n\t\t                            public void onClick                                                 \t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t                                    int id) {\n\t\t\n\t\t                            }\n\t\t                        });\n\t\t      AlertDialog alert = builder.create();\n\t\t      alert.show();\n\t\t   }\n\t\t}\n\n\tThis `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\tNow we will call a method `handleEMDKResult` in case of `CHECK_XML` status to handle this [EMDKResults](#api-EMDKResults), which we will create in the next step.\n\n\t\t:::java\n\t\t// Method call to handle EMDKResult\n\t\thandleEMDKResult(results);    \n\n    Your complete `onOpened` method should now look like this:\n    \n    ![img](images/MxAccessManagerTutorialImages/on_opened_method.jpg)\n\n4. It shows error as we have not yet declared `handleEMDKResult` method. So let us create this method, which would get the XML String response from [EMDKResults](#api-EMDKResults), call the `parseXML` method to parse it and eventually call `displayResults` method to display output in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html), which we would be declaring in coming steps. \n\n\t\t:::java\n\t\t// Method to handle EMDKResult by extracting response and parsing it\n\t\tpublic void handleEMDKResult(EMDKResults results) {\n\t\t\t// Get XML response as a String\n\t\t\tString statusXMLResponse = results.getStatusString();\n\t\n\t\t\ttry {\n\t\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t\t// for the parser\n\t\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t\t// Call method to parse the response\n\t\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\n\t\t\t// Method call to display results in a dialog\n\t\t\tdisplayResults();\n\t\t}\n\n\tYour `handleEMDKResult` method should now look like this:\n    \n    ![img](images/MxAccessManagerTutorialImages/handle_emdk_result.jpg)\n\n5. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxAccessManagerTutorialImages/parse_xml.jpg) \n\n6. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxAccessManagerTutorialImages/build_failure_message.jpg)\n\n7. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxAccessManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.    \n    \n8. If you run the application at this moment, whatever the settings you made in the wizard would be applied to the device. But we are not done yet. We also have to implement a way to modify Access Manager settings programmatically using Mx API as it could be annoying to change the wizard settings repetitively and then run the application each time to see the changes. So let us implement that using following steps.\n\n9. Declare some global variables for User Interfaces such as Drop-down (Spinner), Button, Edit Text, Radio Group and Relative Layout. Now declare some global variables for drop-down (Spinner) adapter that holds lists for various drop downs such as system settings, add package, remove package. We will also declare some global integers that would contain position of an item clicked by the user in each of the three drop-downs (Spinners).\n\n        :::java\n        // Relative Layout that contains entire view when the single user mode with\n\t    // white list is enabled\n\t    private RelativeLayout whiteListLayout;\n\n\t    // Boolean that indicates whether single user mode with/without white list\n\t    // (False for without and True for with white list)\n\t    private boolean isWhiteListActive = false;\n\n\t    // Drop Down that contains options for settings menu of the Access Manager\n\t    private Spinner settingsAccessSpinner;\n\n\t    // Drop Down that contains options for deleting packages from white list\n\t    private Spinner deletePackageSpinner;\n\n\t    // Edit Text that contains comma separated package names to be removed from\n\t    // white list\n\t    private EditText deletePackageEditText;\n\n\t    // Drop Down that contains options for Adding packages to white list\n\t    private Spinner addPackageSpinner;\n\n\t    // Edit Text that contains comma separated package names to be added in the\n\t    // white list\n\t    private EditText AddPackageEditText;\n\n\t    // Array Adapter to hold arrays that are used in various drop downs\n\t    private ArrayAdapter<String> dataAdapter;\n\n\t    // Radio Group for holding Radio Buttons that enable user to select option\n\t    // for single user mode with or without white list\n\t    private RadioGroup radioGroup;\n\n\t    // Holds the position of user selected option in the settings drop down\n\t    private int settingsSpinnerPosition = 0;\n\n\t    // Holds the position of user selected option in the delete package drop\n\t    // down\n\t    private int deletePackageSpinnerPosition = 0;\n\n\t    // Holds the position of user selected option in the add package drop down\n\t    private int addPackageSpinnerPosition = 0;\n\n\t    // Set Button that is used to implement changes made by user in the\n\t    // Access Manager\n\t    private Button setButton;\n\n    So far the variables declared look like:   \n\n    ![img](images/MxAccessManagerTutorialImages/global_variables.jpg)\n\n10. We will now add the layout for this application. This layout contains required View of this application. The view contains various drop downs for system settings menu, add package and drop package features. The view also contains two Radio Buttons to enable/disable white list mode. The layout also contains two Edit Texts that allow user to enter the package names to Add and Delete applications from the white list respectively when user enables the white list option from radio button. Finally the view contains a set button that implements all the changes made by the user.\n\n>Remove all the code, inside \"res/layout/activity_main.xml\" and add following code to form a view described above.\n\n    :::xml\n    <ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\" >\n\n    <RelativeLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_margin=\"10dip\" >\n\n      <RadioGroup\n        android:id=\"@+id/radioGroupAccess\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" >\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_margin=\"10dip\"\n            android:text=\"Choose your Access Manager Option:\"\n            android:textSize=\"14sp\"\n            android:textStyle=\"bold\" />\n\n        <RadioButton\n            android:id=\"@+id/radio_without_whitelist\"\n            android:layout_width=\"279dp\"\n            android:layout_height=\"wrap_content\"\n            android:checked=\"true\"\n            android:text=\"Single User Without Whitelist\"\n            android:textSize=\"14sp\" />\n\n        <RadioButton\n            android:id=\"@+id/radio_with_whitelist\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Single User With Whitelist\"\n            android:textSize=\"14sp\" />\n      </RadioGroup>\n\n      <RelativeLayout\n        android:id=\"@+id/whitelist_layout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/radioGroupAccess\"\n        android:visibility=\"gone\" >\n\n        <Spinner\n            android:id=\"@+id/settings_access_spinner\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_margin=\"8dip\" />\n\n        <Spinner\n            android:id=\"@+id/delete_package_spinner\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@+id/settings_access_spinner\"\n            android:layout_margin=\"8dip\" />\n\n        <EditText\n            android:id=\"@+id/et_delete_package\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@+id/delete_package_spinner\"\n            android:layout_margin=\"8dip\"\n            android:hint=\"package names separated by commas\"\n            android:textSize=\"14sp\"\n            android:visibility=\"gone\" />\n\n        <Spinner\n            android:id=\"@+id/add_package_spinner\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@+id/et_delete_package\"\n            android:layout_margin=\"8dip\" />\n\n        <EditText\n            android:id=\"@+id/et_add_package\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@+id/add_package_spinner\"\n            android:layout_margin=\"8dip\"\n            android:hint=\"package names separated by commas\"\n            android:textSize=\"14sp\"\n            android:visibility=\"gone\" />\n      </RelativeLayout>\n\n       <RelativeLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/whitelist_layout\"\n        android:paddingBottom=\"20dip\" >\n\n        <Button\n            android:id=\"@+id/buttonSet\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentBottom=\"true\"\n            android:layout_centerHorizontal=\"true\"\n            android:layout_marginTop=\"30dp\"\n            android:text=\"Set\" />\n       </RelativeLayout>\n     </RelativeLayout>\n\n    </ScrollView>\n\n11. We have three drop-downs (spinners) in the UI for system settings, Add Package and Remove Package respectively. These spinners show arrays based on their selections. We need to declare these arrays in order to set them to array adapters, which are held by spinners in the next step.\n\n    Go to \"res/values\" in the project of your Eclipse with ADT. Right Click on \"values\" and create a new Android XML file.\n\n    ![img](images/MxAccessManagerTutorialImages/right_click_value.jpg)\n\n\tIf you are using Android Studio, use following screen shot as a reference by right clicking on \"values\" to create a new Android XML file.\n\n\t![img](images/MxAccessManagerTutorialImages/right_click_value_android_studio.jpg)\n\n    Provide the file name (Ex. arrays)\n\n    ![img](images/MxAccessManagerTutorialImages/new_xml_file.jpg)\n\n    Click Finish and \"arrays.xml\" file will be created under \"res/values\".\n\n    Add the following code that declare arrays in `<resources>` tag.\n\n        :::xml\n        <!-- Array for System Settings Menu -->\n        <string-array name=\"system_settings_array\">\n        <item>Full Access</item>\n        <item>Reduced Access</item>\n        </string-array>\n\n        <!-- Array for delete packages options -->\n        <string-array name=\"delete_packages_array\">\n        <item>Delete NO Packages</item>\n        <item>Delete Specified Packages(s)</item>\n        <item>Delete ALL Packages</item>\n        </string-array>\n\n        <!-- Array for Add packages options -->\n        <string-array name=\"add_packages_array\">\n        <item>Add NO Packages</item>\n        <item>Add Specified Packages(s)</item>\n        </string-array>\n\n12. Let us refer UI elements with their respective on click listeners in the `onCreate` method.\n\n        :::java\n        // Reference of Set Button\n\t\tsetButton = (Button) findViewById(R.id.buttonSet);\n\n\t\t// On Click Listener Call for Set Button\n\t\tsetButton.setOnClickListener(onClickListsner);\n\n\t\t// Reference for White List Layout\n\t\twhiteListLayout = (RelativeLayout) findViewById(R.id.whitelist_layout);\n\n\t\t// Reference for Radio Group that has Radio Buttons\n\t\tradioGroup = (RadioGroup) findViewById(R.id.radioGroupAccess);\n\n\t\t// On Checked Change Listener for Radio Buttons in a Radio Group\n\t\tradioGroup.setOnCheckedChangeListener(onCheckedChangeListener);\n\n\t\t// Reference for Add and Delete Package Edit Texts\n\t\tdeletePackageEditText = (EditText) findViewById(R.id.et_delete_package);\n\t\tAddPackageEditText = (EditText) findViewById(R.id.et_add_package);\n\n\t\t// Reference for settings, Add Package and Delete Package drop downs\n\t\tsettingsAccessSpinner = (Spinner) findViewById(R.id.settings_access_spinner);\n\t\tdeletePackageSpinner = (Spinner) findViewById(R.id.delete_package_spinner);\n\t\taddPackageSpinner = (Spinner) findViewById(R.id.add_package_spinner);\n\n\t\t// Adapter to hold the list system settings menu options\n\t\tdataAdapter = new ArrayAdapter<String>(this,\n\t\t\t\tandroid.R.layout.simple_spinner_item, getResources()\n\t\t\t\t\t\t.getStringArray(R.array.system_settings_array));\n\t\tdataAdapter\n\t\t\t\t.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\t// Set adapter to settings drop down\n\t\tsettingsAccessSpinner.setAdapter(dataAdapter);\n\n\t\t// Adapter to hold the list delete package options\n\t\tdataAdapter = new ArrayAdapter<String>(this,\n\t\t\t\tandroid.R.layout.simple_spinner_item, getResources()\n\t\t\t\t\t\t.getStringArray(R.array.delete_packages_array));\n\t\tdataAdapter\n\t\t\t\t.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\t// Set adapter to delete package drop down\n\t\tdeletePackageSpinner.setAdapter(dataAdapter);\n\n\t\t// Adapter to hold the list add package options\n\t\tdataAdapter = new ArrayAdapter<String>(this,\n\t\t\t\tandroid.R.layout.simple_spinner_item, getResources()\n\t\t\t\t\t\t.getStringArray(R.array.add_packages_array));\n\t\tdataAdapter\n\t\t\t\t.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\t// Set adapter to add package drop down\n\t\taddPackageSpinner.setAdapter(dataAdapter);\n\n\t\t// Call to common On Item Selected Listener for all drop downs based on\n\t\t// view ID.\n\t\tsettingsAccessSpinner.setOnItemSelectedListener(onItemSelectedListener);\n\t\tdeletePackageSpinner.setOnItemSelectedListener(onItemSelectedListener);\n\t\taddPackageSpinner.setOnItemSelectedListener(onItemSelectedListener);\n\n    So we have completed the `onCreate` method. Here is the screen capture of part of this method.\n\n    > Note: Please read detailed comments in the code to get significance of each attribute. \n\n    ![img](images/MxAccessManagerTutorialImages/complete_on_create.jpg)\n\n13. At this point, you will see few of errors. This is because we have not implemented respective on click listeners yet. Let us implement them one by one.\n\n    First, we will implement `OnCheckedChangeListener` on Radio Group that is used to enable/disable white list mode. So when it is enabled, the user will see a whitelist layout, which is a view that has some spinners to perform further configurations. When whitelist is disbaled, the whitelist layout is hidden to the user.\n\n        :::java\n        // On checked change listener for Radio Buttons of Radio Group\n\t    private OnCheckedChangeListener onCheckedChangeListener = new OnCheckedChangeListener() {\n\n\t\t @Override\n\t\t public void onCheckedChanged(RadioGroup group, int checkedId) {\n\t\t\tswitch (checkedId) {\n\t\t\t// Single User Mode Without White List\n\t\t\tcase R.id.radio_without_whitelist:\n\t\t\t\t// Set the white list flag to false\n\t\t\t\tisWhiteListActive = false;\n\t\t\t\t// Clear all the edit texts\n\t\t\t\tdeletePackageEditText.setText(\"\");\n\t\t\t\tAddPackageEditText.setText(\"\");\n\t\t\t\t// Hide the White List Layout\n\t\t\t\twhiteListLayout.setVisibility(View.GONE);\n\t\t\t\tbreak;\n\t\t\t// Single User Mode With White List\n\t\t\tcase R.id.radio_with_whitelist:\n\t\t\t\t// Set the white list flag to false\n\t\t\t\tisWhiteListActive = true;\n\t\t\t\t// Show the White List Layout\n\t\t\t\twhiteListLayout.setVisibility(View.VISIBLE);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t }\n\t    };\n\n    > Note: While importing, select Radio Group and not compound button widget.\n\n    The `OnCheckedChangeListener` for Radio Group looks like:\n\n    ![img](images/MxAccessManagerTutorialImages/on_checked_change_listener.jpg)\n\n14. We have implemented a `onItemSelectedListener` for all three spinners that will take respective actions based on the spinner ID.\n\n        :::java\n        // Common On Item Selected Listener for all drop downs based on View ID\n\t    private OnItemSelectedListener onItemSelectedListener = new OnItemSelectedListener() {\n\n\t\t@Override\n\t\tpublic void onItemSelected(AdapterView<?> parent, View view,\n\t\t\t\tint position, long id) {\n\t\t\t// Get View Id of user selected drop down\n\t\t\tint spinnerID = parent.getId();\n\t\t\tswitch (spinnerID) {\n\t\t\t// System Settings drop down is selected\n\t\t\tcase R.id.settings_access_spinner:\n\t\t\t\tsettingsSpinnerPosition = ++position;\n\t\t\t\tbreak;\n\t\t\t// Delete Package drop down is selected\n\t\t\tcase R.id.delete_package_spinner:\n\t\t\t\tdeletePackageSpinnerPosition = position;\n\t\t\t\t// Show/Hide delete package Edit Text based on user selection\n\t\t\t\tif (deletePackageSpinnerPosition == 1)\n\t\t\t\t\t// Show the delete package Edit Text\n\t\t\t\t\tdeletePackageEditText.setVisibility(View.VISIBLE);\n\t\t\t\telse\n\t\t\t\t\t// Hide the delete package Edit Text\n\t\t\t\t\tdeletePackageEditText.setVisibility(View.GONE);\n\t\t\t\tbreak;\n\t\t\t// Add Package drop down is selected\n\t\t\tcase R.id.add_package_spinner:\n\t\t\t\taddPackageSpinnerPosition = position;\n\t\t\t\t// Show/Hide Add package Edit Text based on user selection\n\t\t\t\tif (addPackageSpinnerPosition == 1)\n\t\t\t\t\t// Show the Add package Edit Text\n\t\t\t\t\tAddPackageEditText.setVisibility(View.VISIBLE);\n\t\t\t\telse\n\t\t\t\t\t// Hide the Add package Edit Text\n\t\t\t\t\tAddPackageEditText.setVisibility(View.GONE);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\t @Override\n\t\t public void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t }\n\t    };\n\n    The `onItemSelectedListener` for spinners looks like:\n\n    ![img](images/MxAccessManagerTutorialImages/on_item_slected_listener.jpg)\n\n15. Now we will implement the `onClickListener` for the set Button. this listener will call method `modifyAccessManagerProfileXML` that forms an XML based on users selection and sets the changes to the Profile.\n\n        :::java\n        // On Click Listener for Set Button\n\t    private OnClickListener onClickListsner = new OnClickListener() {\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tint id = view.getId();\n\t\t\tswitch (id) {\n\t\t\tcase R.id.buttonSet:\n\t\t\t\t// Call modifyAccessManagerProfileXML method to set the user\n\t\t\t\t// selected changes\n\t\t\t\tmodifyAccessManagerProfileXML(isWhiteListActive);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t }\n\t    };\n\n    The `onClickListener` for set Button looks like:\n\n    ![img](images/MxAccessManagerTutorialImages/on_click_listener.jpg)\n\n16. Finally, we will implement `modifyAccessManagerProfileXML` method. This is the method that actually implements Access Manager configurations set by the user. It prepares an xml input for the `processProfile` method based on \"value\" attribute of different Access Manager configurations. It then calls the `handleEMDKResult` method that we have already created to handle the [EMDKResults](#api-EMDKResults) and display the output.\n\n    > Note: Please refer to code comments of `modifyAccessManagerProfileXML` method to understand more about \"value\" attribute.\n    > The global integres hold these \"value\" attributes based on user selection of various Access Manager features (Enable/Disable Whitelist, System Settings, Add/Delete Packages to/from whitelist etc.).\n\n    So these global integer variables are set to the respective Access Manager attributes while forming the XML input, which is then passed to the `processProfile` method.\n\n        :::java\n        // Method to modify Access Manager settings based on user selection and set\n\t    // them in Profile Manager\n\t    private void modifyAccessManagerProfileXML(boolean isWhiteListActive) {\n\n\t\t\t// Prepare XML to modify the existing profile settings\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Check if the user has selected with/without white list option\n\t\t\t// from radio group in order to form modifyData xml accordingly.\n\t\t\tif (isWhiteListActive) {\n\t\t\t\t// User has selected Single User Mode With White list\n\t\t\t\tmodifyData[0] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t\t\t\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t\t\t\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"AccessManagerProfile\\\"/>\"\n\t\t\t\t\t\t+ \"<characteristic type=\\\"AccessMgr\\\">\"\n\t\t\t\t\t\t+ \"<parm name=\\\"OperationMode\\\" value=\\\"2\\\"/>\"\n\t\t\t\t\t\t+ \"<parm name=\\\"SystemSettings\\\" value=\\\"\"\n\t\t\t\t\t\t+ settingsSpinnerPosition + \"\\\"/>\";\n\n\t\t\t\t// Set the delete package settings to the xml based on user\n\t\t\t\t// selection from\n\t\t\t\t// delete package drop down stored in\n\t\t\t\t// deletePackageSpinnerPosition integer\n\t\t\t\t// deletePackageSpinnerPosition = 0 -> Delete No Package\n\t\t\t\t// deletePackageSpinnerPosition = 1 -> Delete Specific\n\t\t\t\t// Packages(s)\n\t\t\t\t// deletePackageSpinnerPosition = 2 -> Delete All Packages\n\t\t\t\tif (deletePackageSpinnerPosition == 1) {\n\t\t\t\t\t// Get package names to be deleted from white list\n\t\t\t\t\tmodifyData[0] = modifyData[0]\n\t\t\t\t\t\t\t+ \"<parm name=\\\"DeletePackagesAction\\\" value=\\\"1\\\"/>\"\n\t\t\t\t\t\t\t+ \"<parm name=\\\"DeletePackageNames\\\" value=\\\"\"\n\t\t\t\t\t\t\t+ deletePackageEditText.getText().toString()\n\t\t\t\t\t\t\t+ \"\\\"/>\";\n\t\t\t\t} else {\n\t\t\t\t\t// Delete No Package or Delete All Package based on\n\t\t\t\t\t// deletePackageSpinnerPosition integer\n\t\t\t\t\tmodifyData[0] = modifyData[0]\n\t\t\t\t\t\t\t+ \"<parm name=\\\"DeletePackagesAction\\\" value=\\\"\"\n\t\t\t\t\t\t\t+ deletePackageSpinnerPosition + \"\\\"/>\";\n\t\t\t\t}\n\n\t\t\t\t// Set the Add package settings to the xml based on user\n\t\t\t\t// selection from\n\t\t\t\t// Add package drop down stored in\n\t\t\t\t// addPackageSpinnerPosition integer\n\t\t\t\t// addPackageSpinnerPosition = 0 -> Add No Package\n\t\t\t\t// addPackageSpinnerPosition = 1 -> Add Specific\n\t\t\t\t// Packages(s)\n\t\t\t\tif (addPackageSpinnerPosition == 1) {\n\t\t\t\t\t// Get package names to be added in the white list\n\t\t\t\t\tmodifyData[0] = modifyData[0]\n\t\t\t\t\t\t\t+ \"<parm name=\\\"AddPackagesAction\\\" value=\\\"1\\\"/>\"\n\t\t\t\t\t\t\t+ \"<parm name=\\\"AddPackageNames\\\" value=\\\"\"\n\t\t\t\t\t\t\t+ AddPackageEditText.getText().toString() + \"\\\"/>\";\n\t\t\t\t} else {\n\t\t\t\t\t// Add No Package\n\t\t\t\t\tmodifyData[0] = modifyData[0]\n\t\t\t\t\t\t\t+ \"<parm name=\\\"AddPackagesAction\\\" value=\\\"\"\n\t\t\t\t\t\t\t+ addPackageSpinnerPosition + \"\\\"/>\";\n\t\t\t\t}\n\n\t\t\t\tmodifyData[0] = modifyData[0] + \"</characteristic>\"\n\t\t\t\t\t\t+ \"</characteristic>\";\n\t\t\t} else {\n\t\t\t\t// User has selected Single User Mode Without White list\n\t\t\t\tmodifyData[0] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t\t\t\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t\t\t\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"AccessManagerProfile\\\"/>\"\n\t\t\t\t\t\t+ \"<characteristic type=\\\"AccessMgr\\\">\"\n\t\t\t\t\t\t+ \"<parm name=\\\"OperationMode\\\" value=\\\"1\\\"/>\"\n\t\t\t\t\t\t+ \"</characteristic>\" + \"</characteristic>\";\n\t\t\t}\n\n\t\t\t// Call process profile to modify the Access Manager Profile of\n\t\t\t// specified profile\n\t\t\t// name based on modifyData XML formed above\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\t\t\t// Method call to handle EMDKResult\n\t\t\thandleEMDKResult(results);\n\n\t\t\t} else {\n\t\t\t// Show dialog of Failure\n\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\tbuilder.setMessage(\"Failed to set device clock...\")\n\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\tAlertDialog alert = builder.create();\n\t\t\talert.show();\n\t\t  }\n\t    }\n\n    The `modifyAccessManagerProfileXML` method looks like:\n\n    ![img](images/MxAccessManagerTutorialImages/modify_profile_method.jpg)\n\n    You can see all the errors are gone now. The sample XML for \"without Whitelist\" feature, which is passed to `processProfile` method looks like:\n\n        :::java\n        modifyData[0] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"MxAccessManagerProfile\\\"/>\"\n\t\t+ \"<characteristic type=\\\"AccessMgr\\\">\"\n\t\t+ \"<parm name=\\\"OperationMode\\\" value=\\\"1\\\"/>\"\n\t\t+ \"</characteristic>\" + \"</characteristic>\";         \n\nThat's it!!! We are done with all the coding and configuration part that will allow us to implement Access Manager both programmatically as well as using wizard. Now let us run and test the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug. \n\n2. Run the application.\n\n    ![img](images/MxAccessManagerTutorialImages/home_screen.png)\n\n\tYou can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message, which indicates that the app has successfully implemented settings that we had configured in the wizard. You won't see any change as we had disabled the whitelist in the wizard. \n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.  \n  \n\tNow you can see the two Radio Buttons of which first is checked. It means we are in a single user mode without whitelist. \n\n3. Click the Radio Button Single user mode with whitelist and the respective view will be visible to user\n\n    ![img](images/MxAccessManagerTutorialImages/with_whitelist.png)\n\n    Now you have enabled whitelist. It means you can now add/remove applications to/from the whitelist. Let us add few applications to the whitelist. \n\n5. Select \"Add No Packages\" drop-down and select \"Add specified packages\" option to add few applications to the whitelist.\n\n    ![img](images/MxAccessManagerTutorialImages/add_package_spinner.png)\n\n    It will display an Edit Text to provide the package names of the applications that you want to add to whitelist.\n   \n    ![img](images/MxAccessManagerTutorialImages/add_package_edit_text.png)\n\n    Provide package names of few applications separated by commas. (Ex. com.symbol.mxaccessmanagertutorial, com.allinstalledapps, com.symbol.mxgprstutorial).\n\n    ![img](images/MxAccessManagerTutorialImages/add_packages.png)\n\n    > Note: Make sure to add current application to the white list in order to set access restrictions on other applications. Otherwise user won't be able to access the current application that has access restrictions on other applications and eventually user has to perform Enterprise Reset on the device to get the default settings back.\n\n    Keep the Full Access and press the \"Set\" button. \n\n    ![img](images/MxAccessManagerTutorialImages/whitelist_mode.png)\n\n    You can see that the device is in single user mode with whitelist. It shows the three applications in the whitelist whose package names we had provided in Add Package Edit Text. The other developed apps are not visible in this mode.\n\n6. Now let us remove one application from the whitelist by going to our app and adding the package name in the delete package Edit Text.\n\n    But if you start the application, it will disable whitelist as we have set that feature in the wizard. So we have to comment some code to ensure delete package from the whitelist feature works fine.\n\n    Go to `onOpened` method and comment the highlighted code in the following snapshot.\n \n    ![img](images/MxAccessManagerTutorialImages/commented_code.jpg) \n\n    > Note: You can uncomment this code later after verifying \"Delete Package from Whitelist\" feature.   \n\n7. Run the application again.\n    Check the Radio Button \"Single User with Whitelist\" -> click \"Delete No Packages\" drop down -> Select \"Delete Specified Packages(s)\" option -> Add name of the application package in Edit Text that you want to remove from whitelist (Ex. com.allinstalledapps).\n\n    ![img](images/MxAccessManagerTutorialImages/delete_package.png)\n\n    Click \"Set\" button.\n\n    ![img](images/MxAccessManagerTutorialImages/delete_package.png)\n\n    You can see that the application with package name \"com.allinstalledapps\" has been removed from the whitelist as there are only two application whereas we had added three application previously in the whitelist.\n\n8. In this way, you can configure and test various features of Mx Access Manager on your Symbol device.      \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure access to different applications on your device through your application using Mx Access Manager, let us try to understand and implement some of the other Mx features. So in the next tutorial, we will concentrate on the \"Certificate Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxAccessManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxAppManager","name":" Application Management with AppManger Profile Feature","md":"# Application Management with AppManger Profile Feature\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will help configuring and managing device applications using the [AppManager](#guide-profiles-app) feature of EMDK Profiles. \n\nUsing this feature, a user can perform various App Management operations such as:\n \n* **Install:** - It allows you to install an android application with the user provided apk file location.\n* **Uninstall:** - This will remove the specified application from the device.\n* **Upgrade:** - This will upgrade/downgrade the specified application. The application must already exists on the device or you will receive an error (Use the Install parameter instead.\n* **Default Launcher:** - You can provide a different application launcher to enable. The launcher application must reside on the device already.\n* **Enable and Disable Application:** - Provide a package name of the applications that you want to enable or disable. Disabling an application will disable the ability to launch the application.\n* **Clear App List:** - It will clear the list of recent apps that you opened.\n* **Manage Protected List:** - You can manage which applications are on the protected list by adding and removing application from protected list.\n* **Enable and Disable App Info:** - The application info dialog shows detailed information about the application as well as allow you to perform actions like: Force Stop, Enable/Disable, Clear Data, Clear Cache. Specify the application's package name that you would like to enable or disable this feature for. \n\n    > Note: Please refer the compatibility matrix to check availability these features across various symbol devices [here](#guide-profiles-app).   \n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"EMDKMxAppManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The AppManager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"MxAppManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"App Manager\" feature from the list and click \"Right Arrow\". Using this feature you can perform various operations in your apps on the Symbol Android device. These operations could be installing apps, uninstalling apps, upgrading apps etc. as mentioned in the beginning. \n \n    ![img](images/MxAppManagerTutorialImages/select_app_manager_feature.jpg)\n  \n4. Provide name for this feature in order to modify this feature programmatically (Ex. AppManager). Now let us install an application using the install parameter of the app manager by providing the apk path and name of the application in the specified field. (For example: /storage/sdcard1/Herald.apk). Do not modify any action fields for this tutorial.\n\n\t> Note: The path of apk could be different on different devices.\n  \n    ![img](images/MxAppManagerTutorialImages/app_manager_install_value.jpg)\n  \n5.  Click Apply and Finish. \n\n    ![img](images/MxAppManagerTutorialImages/app_manager_profile_created.jpg)  \n\n6. Click \"Close\".   \n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager. So you can see the entry of the install feature of App Manager and its path on SD card as parameter that we entered earlier in the profile creation.\n\n    ![img](images/MxAppManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxAppManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxAppManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code.  \n    \n        :::java\n        //Assign the profile name used in EMDKConfig.xml  \n        private String profileName = \"MxAppManagerProfile\";  \n          \n        //Declare a variable to store ProfileManager object  \n        private ProfileManager profileManager = null;  \n          \n        //Declare a variable to store EMDKManager object  \n        private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\t\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\t\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\t\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\t\t     \n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxAppManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:  \n\n        :::java\n        this.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxAppManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxAppManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxAppManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxAppManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxAppManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxAppManagerTutorialImages/on_destroy_method.jpg) \n\n## Running the Application\n\n1. That's it, We are done with the configurations and coding. Now let's run the application.\n\n2. Connect the device (having the latest EMDK runtime) to USB port. The Herald application is not present on the device before running this application.\n\n    >Note:   \n    >Make sure the device is in USB debug.\n3. Run the application. The app displays a Toast with a success message.\n  \n\t![img](images/MxAppManagerTutorialImages/app_run.png)\n  \n4. You can see that the Herald app has now been installed on the device whose apk path we had provided earlier during profile creation.\n  \n\t![img](images/MxAppManagerTutorialImages/app_installed.png)\n\n5. Similarly we can leverage the other features (uninstall, upgrade, set as default launcher) of the App Manager by setting appropriate parameters while creating the profile.\n\n\t![img](images/MxAppManagerTutorialImages/other_app_manager_features.jpg)  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device. \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure applications in the device using Mx App Manager feature, let us try some configuring some of the other Mx feature through profile creation. So in the next tutorial, we will concentrate on the \"Power Manager\" feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDKMxAppManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxCameraManager","name":" Administer Use of Camera using Camera Manager","md":"# Administer Use of Camera using Camera Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on managing use of all cameras on your Symbol devices using [Camera Manager](#guide-profiles-camera) feature of Mx. Basically, it will let you control whether or not to allow use of Front-Camera, Rear-Camera or both.  \n\nWe will now create a tutorial to disable the use of all cameras and then enable them back on your Symbol Android device using Mx [Camera Manager](#guide-profiles-camera) feature. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: 1. Provide \"CameraManagerTutorial\" as the project name for this tutorial. 2. This feature requires Symbol device with Android KitKat 4.4. \n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\n> Note: Camera Manager feature requires Symbol devices with Android KitKat 4.4. So select `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK for this tutorial.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The Camera Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"CameraProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Camera Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxCameraManagerTutorialImages/camera_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MyCameraManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n\tCamera Manager allows you to manage the use of Front-Camera, Rear-Camera or both.\t So select the fields accordingly in Profile Wizard. Since we want to configure (Disable and then Enable back) the use of both Cameras, we will select the field \"All Cameras\" in the Profile Wizard. \n\n    So click on \"All Cameras\" drop-down in the wizard and select the option \"Disable ALL Cameras\".    \n\n    ![img](images/MxCameraManagerTutorialImages/camera_manager_details.jpg)\n\n    ![img](images/MxCameraManagerTutorialImages/camera_manager_details_selected.jpg)    \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxCameraManagerTutorialImages/camera_profile_created.jpg)\n\n6. Click Finish and your Camera profile for configuring the use of all Cameras on Symbol devices is created.\n\n    ![img](images/MxCameraManagerTutorialImages/camera_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxCameraManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxCameraManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxCameraManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"CameraProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n    ![img](images/MxCameraManagerTutorialImages/variables_added.jpg)\n\n\t![img](images/MxCameraManagerTutorialImages/on_create_added.jpg)\n\t \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager` if required.  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxCameraManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxCameraManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxCameraManagerTutorialImages/parse_xml_1.jpg) \n\t![img](images/MxCameraManagerTutorialImages/parse_xml_2.jpg)\n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxCameraManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxCameraManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxCameraManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us disable the use of all cameras on Symbol device. Now let's run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We will make sure that Camera is enabled and accessible initially.\n\n    Click on Camera application of your Symbol device and you will see that camera is enabled by default.\n\n    ![img](images/MxCameraManagerTutorialImages/camera_enabled.png) \n\n2. Run the application.\n\n    ![img](images/MxCameraManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will see the status of Camera in Symbol device. So click on the Camera application and you would see that the Camera is disabled as we have disabled the Camera permission through Profile Wizard using Camera Manager feature of Mx.\n\n    ![img](images/MxCameraManagerTutorialImages/camera_disabled.png)\n\n4. We will now enable the use of Camera through Profile Wizard. So select the \"Profile Manager\" and click \"Edit\" button.\n\n\t![img](images/MxCameraManagerTutorialImages/edit_camera_profile.jpg)\n\n5. Click \"All Cameras\" drop-down and select \"Enable ALL Cameras\" option.\n\n\t![img](images/MxCameraManagerTutorialImages/enable_camera_wizard.jpg)\n\n6. Click \"Apply\" and then \"Finish\". Close the Profile Wizard as you are done with the configurations that will enable back the use of Cameras on Symbol device.\n\n7. Run the application again. \n\n\t![img](images/MxCameraManagerTutorialImages/home_screen.png)\n\n8. Now open the Camera application and you would see that the use of Camera has been enabled back through Profile Wizard using [Camera Manager](#guide-profiles-camera) feature of Mx.\n\n\t![img](images/MxCameraManagerTutorialImages/camera_enabled.png) \n\n    This is how Camera Manager lets us Enable/Disable the use of Cameras on Symbol devices through Profile Manager Wizard using [Camera Manager](#guide-profiles-camera) feature of Mx. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure the use of Cameras using Camera Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in EMDK for Android V 3.1. So in the next tutorial, we will concentrate on the \"Power Key Manager\" feature of Mx and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/CameraManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxCellularManager","name":" Set the Roaming State using Cellular Manager","md":"# Set the Roaming State using Cellular Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on configuring roaming state of your Symbol Android device (Ex. Turn ON/OFF state of Data Roaming) using [Cellular Manager](#guide-profiles-cellular) feature of Mx. \n\nSo now we will create a tutorial to turn the state of Data Roaming ON using Mx [Cellular Manager](#guide-profiles-cellular) feature on your Symbol Android device. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"CellularManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The Cellular Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"CellularProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Cellular Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxCellularManagerTutorialImages/cellular_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MyCellularManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n\tCellular Manager also allows you to configure (Turn ON/OFF) the state of Background Data on your Symbol devices.\n\n\t> Note: If you turn \"State of Background Data\" ON, some of the apps and services won't work unless you're connected to Wi-Fi.\n\n    So as discussed, we will turn ON the state of Data Roaming using Cellular Manager feature of Mx through Profile Manager wizard. So click on \"Set the state of Data Roaming\" drop-down in the wizard and select the option \"Turn on\".    \n\n    ![img](images/MxCellularManagerTutorialImages/cellular_manager_details.jpg)\n\n    ![img](images/MxCellularManagerTutorialImages/cellular_manager_details_selected.jpg)    \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxCellularManagerTutorialImages/cellular_profile_created.jpg)\n\n6. Click Finish and your Cellular profile for configuring Roaming State is created.\n\n    ![img](images/MxCellularManagerTutorialImages/cellular_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxCellularManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxCellularManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxCellularManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"CellularProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n    ![img](images/MxCellularManagerTutorialImages/variables_added.jpg)\n\n\t![img](images/MxCellularManagerTutorialImages/on_create_added.jpg)\n\t \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxCellularManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxCellularManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxCellularManagerTutorialImages/parse_xml_1.jpg) \n\t![img](images/MxCellularManagerTutorialImages/parse_xml_2.jpg)\n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxCellularManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxCellularManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxCellularManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us turn ON the state of Data Roaming on Symbol device. Now let's run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We will make sure that Data Roaming of our Symbol device is turned OFF. \n\n    Go to device's Settings -> Mobile Networks and make sure that \"Data Roaming\" is unchecked.\n\n    ![img](images/MxCellularManagerTutorialImages/data_roaming_off.png) \n\n2. Run the application.\n\n    ![img](images/MxCellularManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will see the status of \"Data Roaming\" in the settings. So go to device's Settings -> Mobile Networks again and you would now see that \"Data Roaming\" has been turned ON by Cellular Manager that we had set in the profile wizard. \n\n    ![img](images/MxCellularManagerTutorialImages/data_roaming_on.png)\n\n    This is how Cellular Manager lets us turn ON/OFF Data Roaming of the Symbol devices using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to set Roaming State using Cellular Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in EMDK for Android V 3.1. So in the next tutorial, we will concentrate on the \"Display Manager\" feature of Mx and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/CellularManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxCertificateManager","name":" Install CA Certificate using Certificate Manager","md":"# Install CA Certificate using Certificate Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on installing certificates on your Symbol device using [Certificate Manager](#guide-profiles-cert).\n\nYou can use these installed digital certificates to identify your device for a variety of purposes, including VPN or Wi-Fi network access as well as authentication to servers by apps such as Email or Chrome. Let us create a tutorial using [Certificate Manager](#guide-profiles-cert) and install a sample CA certificate that would be useful when using WiFiConfig to configure a profile that uses EAP-TLS while adding a Wi-Fi network.\n\n>Note:  \n>We can install different types of certificates (Ex. .PEM, .PFX, .P12 etc. ) but for this tutorial, we will install a sample CA certificate (.PEM file). \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above\n* Download the sample CA Certificate from [here]() and put it on the SD card of Symbol Android device to refer it later in this tutorial.  \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"CertManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding the Certificate Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"CertificateProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Certificate Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxCertManagerTutorialImages/certificate_keystore.jpg)\n\n4. Now, We have to add the feature to install our sample CA certificate on Symbol device. But, we need to make sure that before installing or uninstalling certificates, a keystore must exist. It means, we need to initialize Android Keystore on our Symbol device. When you initialize the Android keystore you create a new keystore replacing any previously existing one. You can choose to perform this action as a separate EMDK profile or include the Certificate Manager feature multiple times in one profile. We will use Certificate Manager feature multiple times with the same profile in this tutorial. This Certificate Manager feature will be used to initialize Android Keystore.\n\n\tProvide some name in the \"Name\" field (Ex. \"MyKeystore\"). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n5. Click the \"Certificate Action\" drop-down and select \"Initialize Android Keystore\" option.\n\n\t![img](images/MxCertManagerTutorialImages/initialize_android_keystore.jpg)\n\n6. Provide the password required to initialize the Android Keystore in \"Keystore Password\" field (Ex. 1234).\n\n\t![img](images/MxCertManagerTutorialImages/keystore_password.jpg)\n\n7. As mentioned, we will add another Certificate Manager feature in the same profile to install our sample CA Certificate on Symbol device. Select the \"Certificate Manager\" feature from the list and click \"Right Arrow\". This Certificate Manager will be use to install CA Certificate on Symbol device.\n\n\t![img](images/MxCertManagerTutorialImages/certificate_feature.jpg)  \n\n    Provide some name in the \"Name\" field (Ex. MyCertificateManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    So as discussed, you can install different types of certificates (.PEM, .PFX, .P12 etc. ) on your Symbol device using Certificate Manager. Here, we will install a sample CA certificate (.PEM file) that would be useful when using WiFiConfig to configure a profile that uses EAP-TLS while adding a Wi-Fi network. \n\n    Execute following steps to proceed:\n \n\t* Click on \"Certificate Action\" drop-down in the wizard and select the option \"Install Certificate\".    \n\n    ![img](images/MxCertManagerTutorialImages/install_cert.jpg)\n\n    >Note:  \n    >To uninstall any installed certificate, select \"Uninstall Certificate\" option from \"Certificate Action\" drop-down and provide the appropriate alias name of certificate you want to uninstall.  \n\n\t* Provide some name in \"Certificate Alias\" field to refer your certificate while performing different actions on it such as uninstall (Ex. Test-Certificate).\n\n\t* Click on \"Certificate Type\" drop-down in the wizard and select the option \"CA Certificate (.PEM file)\".\n\n\t![img](images/MxCertManagerTutorialImages/cert_type.jpg)\n\n\t* Provide the SD Card path of the Sample CA Certificate that we put in the beginning (/storage/sdcard1/test.pem).\n\n\t> Note: SD Card Path may vary based on where you put your certificate.\n\n\t* Keep rest of the fields as it is and your profile wizard for Certificate Manager should look like:  \n \n    ![img](images/MxCertManagerTutorialImages/cert_manager_wizard.jpg)   \n \n8. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxCertManagerTutorialImages/certificate_profile_created.jpg)\n\n\t> Note: As you can see, we have added two Certificate Manager features in the same profile to Initialize Android Keystore and Install sample CA Certificate respectively on the Symbol device.\n\n9. Click Finish and your Certificate profile for initializing Android Keystore and installing CA Certificate is created.\n\n    ![img](images/MxCertManagerTutorialImages/certificate_manager_profile_created.jpg) \n  \n10. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n11. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxCertManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxCertManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"CertificateProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n\tSo this is how variable declaration looks like:\n\n\t![img](images/MxCertManagerTutorialImages/variables_added.jpg)\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxCertManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxCertManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxCertManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxCertManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxCertManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxCertManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxCertManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us install the sample CA certificate on Symbol Android device. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, it is recommended that the key store be cleared. (Settings -> Security -> Clear Credentials) \n\n    ![img](images/MxCertManagerTutorialImages/clear_credentials.png)\n\n\t> Note: If \"Clear Credentials\" option is disabled, you don't need to clear it.  \n\n2. Run the application.\n\n    ![img](images/MxCertManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message, which indicates that the sample CA certificate with alias name \"Test-Certificate\" has been installed.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. Let us verify this by executing following steps on your Symbol device:\n\n\t* Navigate to Settings -> Wi-Fi. \n\t* Press \"+\" button to add a Wi-Fi network.\n\n\t![img](images/MxCertManagerTutorialImages/add_network.png)\n\n\t* Tap the \"Security\" drop-down and select \"802.1x EAP\" option. \n\n    ![img](images/MxCertManagerTutorialImages/security_option.png)\n\n\t* Now scroll down and tap on \"EAP method\" drop-down. Select \"TLS\" option.\n\n\t![img](images/MxCertManagerTutorialImages/tls.png)\n\n\t* Scroll down and tap on \"CA Certificate\" option and you should see the alias name (Test-Certificate) of the Sample CA certificate that we installed using Profile wizard.\n\n\t![img](images/MxCertManagerTutorialImages/ca_certificate_installed.png)\n\n\tThe alias listed can become the value to use as the certificate when using Wi-Fi Config to configure a profile that uses EAP-TLS.\n\n4. You can also uninstall the installed certificates through Profile Manager wizard by simply selecting \"Uninstall Certificate\" option in the \"Certificate Action\" and proceed.\n\n\t![img](images/MxCertManagerTutorialImages/uninstall_certificate.jpg)\n\n5. This is how Certificate Manager lets us configure different types of certificate on the Symbol Android device using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure various types of certificates using Certificate Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"XML Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/CertManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxClock","name":" Setting The Clock With ProfileManager","md":"# Setting The Clock With ProfileManager\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will configure the device's date and time using the [Mx Clock](#guide-profiles-clock) feature through Profile Manager of the EMDK for Android.\n\nThis feature expects following attributes from user to set Clock on the symbol Android device:\n\n* **Timezone:** - TimeZone in Android supported format\n* **Date:** - UTC Date to set on the device.\n* **Time:** - UTC Time to set on Symbol device.\n* **AutoTime:** - Select this feature to use network provided time on the symbol device. \n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"EMDKMxClockTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding an Clock Profile\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"MxClockProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Clock\" feature from the list and click \"Right Arrow\". The parameter list will be populated. Using this feature you can configure the date and time of the Symbol device. \n\n    ![img](images/MxClockTutorialImages/clock_feature_parameters.jpg)\n  \n4. Enter the TimeZone, Date and Time you wish to enter. All the timings need to be in UTC. It means if you want to set the Timezone to PST, you will need to set the clock to GMT time and it will automatically change it to the local time for you. The AutoTime feature lets you use network provided time on the Symbol Android device. Keep it unchecked for this tutorial.\n\n    > Note: It means the time you enter always has to be in GMT.  \n  \n    ![img](images/MxClockTutorialImages/clock_parameters_values.jpg)\n  \n\tForEample:  \n\t* **Name**: MxClock\n\t* **TimeZone**: GMT-07:00\n\t* **Date**: 2014-12-22\n\t* **Time**: 20:00:00\n\t* **AutoTime**: Unchecked\n\n    Here , we have set the Timezone as GMT-07:00. It means if we want to set the PST time of 1PM, we have to set the GMT time as 8PM (20:00:00 in 24 hour format) and it will automatically set the PST time of 1PM for us. \n\n5.  Click Apply and Finish. \n\n    ![img](images/MxClockTutorialImages/clock_profile_created.jpg)  \n\n6. Click \"Close\".   \n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager. So you can see the entry of the clock feature and its parameters that we entered earlier in the profile creation.\n\n    ![img](images/MxClockTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxClockTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxClockTutorialImages/manifest_permissions_added.jpg)\n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code.\n\n\t>Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.  \n    \n        :::java\n        //Assign the profile name used in EMDKConfig.xml  \n        private String profileName = \"MxClockProfile\";  \n          \n        //Declare a variable to store ProfileManager object  \n        private ProfileManager profileManager = null;  \n          \n        //Declare a variable to store EMDKManager object  \n        private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";     \n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxClockTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:  \n\n\t> Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`\n\n        :::java\n        this.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to set device clock...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxClockTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxClockTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxClockTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxClockTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Device Clock set successfully...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxClockTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxClockTutorialImages/on_destroy_method.jpg)  \n\n## Running the Application\n\n1. That's it, We are done with the configurations and coding. Now let's run the application.\n2. Connect the device (having the latest EMDK runtime) to USB port.\n    >Note:   \n    >Make sure the device is in USB debug.\n3. Note the date and time of the device before running the application.\n\n\t![img](images/MxClockTutorialImages/date_time_before_running.png)\n\n4. Run the application. If everything goes well, the app will show a success message. You can now see the time of the device has been changed to the PST timezone of 1PM as we had set it to the GMT-07:00, 8PM (20:00:00 in 24 hour format) in the wizard.\n  \n\t![img](images/MxClockTutorialImages/time_after_running_app.png)\n\n\tYou can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n5. Notice that the date and time of the device has now been changed accordingly when you open the notification bar.\n  \n\t![img](images/MxClockTutorialImages/date_time.png)  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n    >Note: * Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device. \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure date and time using Mx feature, let us try some configuring some of the other Mx feature through profile creation. So in the next tutorial, we will concentrate on the \"App Manager\" feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDKMxClockTutorial.zip)."},{"key":"guide-tutorial-tutMxDefaultLauncher","name":" Set Default Launcher Application Using App Manager ","md":"# Set Default Launcher Application Using App Manager \n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on one of the functions of App Manager API, which allows user to set any launcher application as a default launcher application using App Manager API.\n\nThe tutorial would enable user to set an application as default launcher using:\n\n**1.  EMDK Profile Manager wizard:** \n\nInitially, we will configure EHS (Enterprise Home Screen) launcher application as the default launcher application using Profile Manager wizard. [Enterprise Home Screen (EHS)](https://developer.motorolasolutions.com/docs/DOC-1875) is a replacement application launcher, for Symbol Android devices, designed to allow only specified applications to be launched. So this launcher will replace the existing launcher application in the device.\n\n**2. App Manager API:**\n\nOnce the EHS has been set as the default launcher application, we will modify this setting by setting another application as default launcher through the code using App Manager API for default launcher. You can use any applicable launcher application. We will use [Galaxy Launcher](http://www.appsapk.com/galaxy-launcher/) application to set  as default launcher application through code in this tutorial.\n\nThis allows you to understand how to configure parameters using Profile Manager and modify it using App Manager API.   \n\t\n \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above\n* Download and install the required launcher applications before getting started with the tutorial. \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Downloading required Launcher Applications:\nAs discussed above, we will now download and install the two launcher applications ([EHS](https://developer.motorolasolutions.com/docs/DOC-1875) and [Galaxy Launcher](http://www.appsapk.com/galaxy-launcher/)).\n\n* You can download Enterprise Home Screen application [here](https://portal.motorolasolutions.com/Support/US-EN/Resolution?solutionId=92627&redirectForm=search&searchQuery=%3FsearchType%3Dsimple%26searchTerm%3DDownload%20EHS). Unzip the file to get the APK to install.\n* You can download Galaxy Launcher application [here](http://www.appsapk.com/galaxy-launcher/).\n\nOnce downloaded, you can put them in SD card of the the device and install both of these launcher applications.\n\nThe App Manager API requires the Android *package name* of the application that you want to set as default launcher. If we know the package name then we can specify it in the field, but in this case we don't know as we have downloaded theses APK files from different sources.\n\n   >Note:\n   >Android device does not provide package names of the installed applications.\n\nSo we have [created an application](https://s3.amazonaws.com/emdk/Tutorials/AllInstalledApps-Source.zip) that finds all the installed applications programmatically and displays their package names along with the application name in a list.\n\nYou can [download](https://s3.amazonaws.com/emdk/Tutorials/AllInstalledApps.apk) the application and install it - or modify the [source](https://s3.amazonaws.com/emdk/Tutorials/AllInstalledApps-Source.zip) to your liking. Once installed, open the app and you can find the package names of both the applications.\n\nSo, the Package name for EHS Launcher App is **com.motorolasolutions.enterprisehomescreen**\n\n   ![img](images/MxDefaultLauncherTutorialImages/ehs_app.jpg) \n\nPackage name for Galaxy Launcher App is **com.epic.launcher.tw**\n\n   ![img](images/MxDefaultLauncherTutorialImages/galaxy_launcher_app.jpg) \n\n## Creating The Project\n\n> Note: Provide \"MxDefaultLauncherTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The AppManager Profile \n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"DefaultLauncherProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"App Manager\" feature from the list and click \"Right Arrow\". Using this feature you can perform various operations in your apps on the Symbol Android device. These operations could be installing apps, uninstalling apps, upgrading apps and setting specific app as default launcher. We will be concentrating on Default Launcher feature in this tutorial.       \n \n4. Click on the App Manager feature. The parameter list will be populated.  \n  \n    ![img](images/MxDefaultLauncherTutorialImages/select_app_manager_feature.jpg)\n\n5. Now Click on the drop-down of the action field to see the supported features by App Manager. Select \"Set as Default Launcher\" feature.\n\n    ![img](images/MxDefaultLauncherTutorialImages/app_manager_features.jpg)\n\n    ![img](images/MxDefaultLauncherTutorialImages/feature_default_launcher.jpg)\n  \n6. Keep the 'Name' field empty. Now let us set earlier installed EHS launcher application as default launcher application. So provide the previously found package name of EHS application  (com.motorolasolutions.enterprisehomescreen) in the field \"Package Name\". Keep the last to \"Action\" fields as it is.\n\n\t> Note: If you have a different launcher application then provide the package name accordingly.\n  \n    ![img](images/MxDefaultLauncherTutorialImages/app_manager_install_value.jpg)\n  \n7. Click Apply and Finish. \n\n    ![img](images/MxDefaultLauncherTutorialImages/app_manager_profile_created.jpg)\n  \n8. Click \"Close\".   \n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n9. You can inspect the \"EMDKConfig.xml\" to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager. So you can see the entry of the 'Set Default Launcher' feature of App Manager and the package name of the launcher application that we entered earlier in the profile creation.\n\n    ![img](images/MxDefaultLauncherTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxDefaultLauncherTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxDefaultLauncherTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code.\n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        //Assign the profile name used in EMDKConfig.xml  \n        private String profileName = \"DefaultLauncherProfile\";  \n          \n        //Declare a variable to store ProfileManager object  \n        private ProfileManager profileManager = null;  \n          \n        //Declare a variable to store EMDKManager object  \n        private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\t\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\t\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\t\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";     \n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxDefaultLauncherTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    >Note:\n    >Set the name of the method argument to `emdkManager`  \n\n        :::java\n        this.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:  \n\n        :::java\n        if (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the\n\t\t\t// profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t    if (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\t\t\t} else {\n\t\t\t\t// Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to set Default Launcher...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t    (DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\t\t}\n\n\tThis `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method. So we will call a method `handleEMDKResult` to handle this [EMDKResults](#api-EMDKResults), which we will create in the next step.\n\n\t\t:::java\n\t\t// Method call to handle EMDKResult\n\t\thandleEMDKResult(results);  \n\n    Your onOpened method should now look like this:\n    \n    ![img](images/MxDefaultLauncherTutorialImages/on_opened_method.jpg)\n\n3. It shows error as we have not yet declared `handleEMDKResult` method. So let us create this method, which would get the XML String response from [EMDKResults](#api-EMDKResults), call the `parseXML` method to parse it and eventually call `displayResults` method to display output in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html), which we would be declaring in coming steps. \n\n\t\t:::java\n\t\t// Method to handle EMDKResult by extracting response and parsing it\n\t\tpublic void handleEMDKResult(EMDKResults results) {\n\t\t\t// Get XML response as a String\n\t\t\tString statusXMLResponse = results.getStatusString();\n\t\n\t\t\ttry {\n\t\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t\t// for the parser\n\t\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t\t// Call method to parse the response\n\t\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\n\t\t\t// Method call to display results in a dialog\n\t\t\tdisplayResults();\n\t\t}\n\n\tYour `handleEMDKResult` method should now look like this:\n    \n    ![img](images/MxDefaultLauncherTutorialImages/handle_emdk_result.jpg)\n\n4. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxDefaultLauncherTutorialImages/parse_xml.jpg) \n\n5. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxDefaultLauncherTutorialImages/build_failure_message.jpg)\n\n6. In this step, we will add `displayResults` method to display the result of profile operation. If the Profile is successfully applied, we will display a [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html) with a success message and in case of any errors, we will display a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with the corresponding error details.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\n\t\t\t Toast.makeText(MainActivity.this,\n\t\t\t\t\t\"Default Launcher changed successfully...\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\n\t\t  } else {\n\t\t\t // Alert Dialog to display the error details while Profile creation\n\t\t\t // operation of MX features\n\t\t\t AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\t\tMainActivity.this);\n\t\t\t // set title\n\t\t\t alertDialogBuilder.setTitle(status);\n\t\t\t // call buildFailureMessage() method to set failure message in\n\t\t\t // dialog\n\t\t\t alertDialogBuilder.setMessage(buildFailureMessage());\n\t\t\t alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t // create alert dialog\n\t\t\t AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t\t // show it\n\t\t\t alertDialog.show();\n\t\t  }\n\t    }\n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxDefaultLauncherTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n7. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxDefaultLauncherTutorialImages/on_destroy_method.jpg) \n\n    Settings at this point would allow you to apply EHS (Enterprise Home Screen) as the default launcher of your Mototrola Android device when we run the application.\n\n    But we also want to set the another launcher application (Galaxy Launcher) as the default launcher programmatically. So we will add the required code to implement it.\n\n8. Remove the default \"TextView\", inside \"res/layout/activity_main.xml\".\n\n9. Add the following code that has an Edittext to enter the package name of the launcher application and a button to implement operation.\n\n        :::xml\n        <TextView\n        android:id=\"@+id/label\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\"\n        android:text=\"Enter Package Name:\"\n        android:textSize=\"18sp\"\n        android:textStyle=\"bold\" />\n\n        <EditText\n        android:id=\"@+id/package_name\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/label\" android:hint=\"Package Name\"\n        android:layout_margin=\"20dip\" />\n\n        <Button\n        android:id=\"@+id/btn_set_default_launcher\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/package_name\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_margin=\"5dip\"\n        android:text=\"Set Default Launcher\" />\n\n    The layout file 'activity_main.xml' inside \"res/layout/\" should now look like:\n\n    ![img](images/MxDefaultLauncherTutorialImages/activity_main.jpg)\n\n10. Now, In the Main activity make an entry of these UI elements using following code:\n\n        :::java\n\t\t// Edit Text ro enter the package name of the launcher application\n\t    private EditText packageNameEditText;\n\t\n\t    // Button to set the application as default launcher\n\t    private Button setDefaultLauncherButton;\n\n    So far the code looks like:\n\n\t![img](images/MxDefaultLauncherTutorialImages/ui_element_reference.jpg) \n\n11. Get the reference of these UI elements in `onCreate` method.\n\n        :::java\n        packageNameEditText = (EditText) findViewById(R.id.package_name);\t\t\n\t\tsetDefaultLauncherButton = (Button) findViewById(R.id.btn_set_default_launcher);\n \n     The `onCreate` method now looks like:\n\n    ![img](images/MxDefaultLauncherTutorialImages/reference_on_create.jpg)\n\n12. In this step, we will write a function that takes package name of the launcher application as input parameter and programmatically sets that application as the default launcher application.\n\n    This method prepares the xml input for the `processProfile` method by accepting the package name of the launcher application provided by the user. It then calls the `handleEMDKResult` method that we have already created to handle the [EMDKResults](#api-EMDKResults) and display the output.\n\n    The `processProfile` method then sets the changes to `Profile Manager` and returns the result to the `EMDKResults` as follows:\n\n        :::xml\n        // Method that takes package name of the launcher application and\n\t    // programmatically sets that application as the default launcher.\n\t    public void setLauncherApplication(String packageName) {\n\n\t\t\t// Prepare XML to modify the existing profile\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\tmodifyData[0] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t\t\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t\t\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"DefaultLauncherProfile\\\"/>\"\n\t\t\t\t\t+ \"<characteristic type=\\\"AppMgr\\\">\"\n\t\t\t\t\t+ \"<parm name=\\\"Action\\\" value=\\\"SetDefaultLauncher\\\"/>\"\n\t\t\t\t\t+ \"<parm name=\\\"Package\\\" value=\\\"\" + packageName + \"\\\"/>\"\n\t\t\t\t\t+ \"</characteristic>\" + \"</characteristic>\";\n\n\t\t\t// Call process profile to modify the profile of specified profile\n\t\t\t// name\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\t\t\t// Method call to handle EMDKResult\n\t\t\thandleEMDKResult(results);\n\t\t    } else {\n\t\t\t// Show dialog of Failure\n\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\tbuilder.setMessage(\"Failed to set Default Launcher...\")\n\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\tAlertDialog alert = builder.create();\n\t\t\talert.show();\n\t\t  }\n\t    }\n\n    The method `setLauncherApplication` method should look like: \n\n    ![img](images/MxDefaultLauncherTutorialImages/set_launcher_app_method.jpg) \n\n13. Let us call this method by implementing on click listener of the `setDefaultLauncherButton` button. This listener will get the package name entered by user from the Edit Text and call the `setLauncherApplication` method for a valid package name as follows:\n\n        :::java\n        // On Click Listener for the button\n\t\tsetDefaultLauncherButton.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t// TODO Auto-generated method stub\n\n\t\t\t\t// Get the package name entered by user from the Edit Text\n\t\t\t\tString packageName = packageNameEditText.getText().toString();\n\n\t\t\t\tif (TextUtils.isEmpty(packageName))\n\t\t\t\t\t// Invalid Package Name\n\t\t\t\t\tToast.makeText(MainActivity.this,\n\t\t\t\t\t\t\t\"Please enter a valid package name...\",\n\t\t\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\t\telse\n\t\t\t\t\t// Call the method to set launcher application as default\n\t\t\t\t\t// launcher\n\t\t\t\t\tsetLauncherApplication(packageName);\n\n\t\t\t}\n\t\t}); \n\n    Finally the `onCreate` method should look like:\n\n    ![img](images/MxDefaultLauncherTutorialImages/final_on_create_method.jpg)\n\nThat's it!!! We are done with all the coding and configuration part. Now let us run the application.\n \n\n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n    \n    The device currently has its own default launcher. Before Running the application, make sure that the two launcher applications (EHS and Galaxy Launcher) are already installed in the device.\n\n    The default launcher of TC 55 device looks like:\n\n    ![img](images/MxDefaultLauncherTutorialImages/default_launcher.png)\n\n2. Run the application. The app sets the EHS (Enterprise Home Screen) application as the default launcher application as we had provided its package name while profile creation.\n\n    The app automatically closes by displaying a success message as the launcher is changed. \n  \n\t![img](images/MxDefaultLauncherTutorialImages/ehs_launcher.png)\n  \n4. Now we will set Galaxy Launcher as the default launcher application. In order to do that, press and hold the menu key.\n\n    ![img](images/MxDefaultLauncherTutorialImages/device_home_key.png)\n\n    Select the \"MxDefaultLauncherTutorial\" app and the app will open.\n  \n\t![img](images/MxDefaultLauncherTutorialImages/mx_default_launcher_app.png)\n\n5. Enter the package name of Galaxy Launcher application that we had obtained previously **(com.epic.launcher.tw)**.\n \n\t![img](images/MxDefaultLauncherTutorialImages/enter_package_name.png)\n\n6. Click `Set Default Launcher` button. The app will now set Galaxy Launcher as the default launcher application. The app will close automatically displaying a success message.\n\n    ![img](images/MxDefaultLauncherTutorialImages/galaxy_launcher.png)\n\n    > Note:\n    > In case of failure, the app will display a failure message in an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) and no change will take place.  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device. \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure applications in the device using Mx App Manager feature, let us try some configuring some of the other Mx feature through profile creation. So in the next tutorial, we will concentrate on the \"Power Manager\" feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDKMxDefaultLauncherTutorial.zip). You can also [download](https://s3.amazonaws.com/emdk/Tutorials/AllInstalledApps.apk) the Package Name helper application and install it - or modify the [source](https://s3.amazonaws.com/emdk/Tutorials/AllInstalledApps-Source.zip) to your liking.\n"},{"key":"guide-tutorial-tutMxDevAdminManager","name":" Allow installation of apps from unknown sources using DevAdmin Manager.","md":"# Allow installation of apps from unknown sources using DevAdmin Manager.\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on  whether to allow or not the installation of apps from unknown sources on your Symbol Android device using [DevAdmin Manager](#guide-profiles-devadmin) feature of Mx.\n\n> Note: Your phone and personal data are more vulnerable to attack by apps from unknown sources. You agree that you are solely responsible for any damage to your phone or loss of data that may result from using these apps. \n\nSo we will now create a tutorial to allow the installation of apps from unknown sources on Symbol devices using Mx [DevAdmin Manager](#guide-profiles-devadmin) feature.\n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"DevAdminTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The DevAdmin Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"DevAdminProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Dev Admin\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxDevAdminManagerTutorialImages/devadmin_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MyDevAdminManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n\tDevAdmin Manager also provides other features that you can try out are setting the Screen-Lock Timeout Interval, after which the screen-lock would occur and configuring Device Administration on your Symbol device by providing package name and class name of Device Administrator.\n\n    So as discussed, we will allow installation of apps from unknown sources using DevAdmin feature of Mx through Profile Manager wizard. So click on \"Install App from Unknown Sources\" drop-down in the wizard and select the option \"Turn on\".    \n\n    ![img](images/MxDevAdminManagerTutorialImages/devadmin_manager_details.jpg)\n\n    ![img](images/MxDevAdminManagerTutorialImages/devadmin_manager_details_selected.jpg)    \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxDevAdminManagerTutorialImages/devadmin_profile_created.jpg)\n\n6. Click Finish and your DevAdmin profile for allowing apps from unknown sources is created.\n\n    ![img](images/MxDevAdminManagerTutorialImages/devadmin_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxDevAdminManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxDevAdminManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxDevAdminManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"DevAdminProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n    ![img](images/MxDevAdminManagerTutorialImages/variables_added.jpg)\n\n\t![img](images/MxDevAdminManagerTutorialImages/on_create_added.jpg)\n\t \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager` if required.  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxDevAdminManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxDevAdminManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxDevAdminManagerTutorialImages/parse_xml_1.jpg) \n\t![img](images/MxDevAdminManagerTutorialImages/parse_xml_2.jpg)\n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxDevAdminManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxDevAdminManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxDevAdminManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us allow installation of apps from unknown sources on Symbol device. Now let's run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We will make sure that \"Install App from Unknown Sources\" feature is turned OFF. \n\n    Go to device's Settings -> Security and see \"Unknown Sources\". This feature is turned OFF by default.\n\n    ![img](images/MxDevAdminManagerTutorialImages/unknown_sources_off.png) \n\n2. Run the application.\n\n    ![img](images/MxDevAdminManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will see the status of \"Unknown Sources\" in device settings. So go to device's Settings -> Security and you would now see that \"Unknown Sources\" that allow installation of App from unknown sources has been turned ON by DevAdmin Manager that we had set in the profile wizard. \n\n    ![img](images/MxDevAdminManagerTutorialImages/unknown_sources_on.png)\n\n    This is how DevAdmin Manager allows us to install applications from Unknown Sources on Symbol device using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to allow installation of applications from unknown sources using DevAdmin Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in EMDK for Android V 3.1. So in the next tutorial, we will concentrate on the \"Power Key Manager\" feature of Mx and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/DevAdminTutorial.zip)."},{"key":"guide-tutorial-tutMxDisplayManager","name":" Configure Screen Off Timeout Interval using Display Manager.","md":"# Configure Screen Off Timeout Interval using Display Manager.\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on setting the screen off timeout interval of your Symbol Android device. The timeout interval indicates that your device's screen would be turned off after a certain time interval of inactivity that you specify using [Display Manager](#guide-profiles-display) feature of Mx. This option is popularly known as \"Sleep Interval\" and is present in the Settings -> Display of your Symbol device. \n\nSo now we will create a tutorial and set a specific Timeout Interval (Ex. 30 Seconds) using Mx [Display Manager](#guide-profiles-display) feature on your Symbol Android device. It means the screen of your Symbol device would be turned off automatically after 30 seconds of inactivity once this feature is applied through Profile Wizard.\n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"DisplayManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The Display Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"DisplayProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Display Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxDisplayManagerTutorialImages/display_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MyDisplayManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    So as discussed, we will set the Screen Off Timeout Interval to 30 seconds. Click on \"Set the Screen Off Timeout Interval\" drop-down in the Profile Wizard and select \"30 seconds\".    \n\n    ![img](images/MxDisplayManagerTutorialImages/display_manager_details.jpg)\n\n    ![img](images/MxDisplayManagerTutorialImages/display_manager_details_selected.jpg)    \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxDisplayManagerTutorialImages/display_profile_created.jpg)\n\n6. Click Finish and your Display profile for configuring screen off timeout interval of your Symbol Android device is created.\n\n    ![img](images/MxDisplayManagerTutorialImages/display_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxDisplayManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxDisplayManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxDisplayManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"DisplayProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n    ![img](images/MxDisplayManagerTutorialImages/variables_added.jpg)\n\n\t![img](images/MxDisplayManagerTutorialImages/on_create_added.jpg)\n\t \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxDisplayManagerTutorialImages/on_opened_method_1.jpg) \n\n\n    ![img](images/MxDisplayManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxDisplayManagerTutorialImages/parse_xml_1.jpg) \n\t![img](images/MxDisplayManagerTutorialImages/parse_xml_2.jpg)\n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxDisplayManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Timeout Interval Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxDisplayManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxDisplayManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us set the Screen Off Timeout Interval to \"30 seconds\". So after inactivity of 30 seconds the screen of the symbol device would be turned off. Now let's run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, let's checkout the default Screen off Timeout Interval (Sleep Interval) of the Symbol device. \n\n    Go to device's Settings -> Display and check \"Sleep\" Option\n\n    ![img](images/MxDisplayManagerTutorialImages/default_sleep_time.png)\n\n\tYou can see that its \"15 seconds\" by default. \n\n2. Now, Run the application.\n\n    ![img](images/MxDisplayManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. Now we will see the status of Sleep Interval again. So go to device's Settings -> Display and check \"Sleep\" option and you would see the interval set to \"30 seconds\" that we had applied through the profile wizard. \n\n    ![img](images/MxDisplayManagerTutorialImages/default_sleep_changed.png)\n\n    This is how Display Manager allows us to set, Screen Off Timeout Interval (Sleep Interval) of Symbol devices using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure Screen Off Timeout Interval of Symbol devices using Display Manager through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"Power Key Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/DisplayManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxEncryptManager","name":" Creating Encrypted File System (EFS) using Encrypt Manager","md":"# Creating Encrypted File System (EFS) using Encrypt Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. This tutorial will focus on creating Encrypted File System (EFS) for storing application data on the internal/external storage using [Encrypt Manager](#guide-profiles-encrypt) feature of Mx. Encrypted File System (EFS) enables files to be transparently encrypted to protect confidential data from attackers with physical access to the device. On the other hand [Encrypt Manager](#guide-profiles-encrypt) enables you, as a developer to set encryption policies on device through MX XML.   \n\nSo now we will create a tutorial to install a new Encryption Key and use this key while creating Encrypted File System (EFS) on the external storage of your Symbol device using Mx [Encrypt Manager](#guide-profiles-encrypt) feature through Profile Wizard.\n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.1 and above\n* Make sure you have an external SD Card in the device if you are using external storage option for creating EFS.\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: 1. Provide \"EncryptManagerTutorial\" as the project name for this tutorial. \n> 2. This feature requires Symbol device with Android KitKat 4.4. \n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\n> Note: Encrypt Manager feature requires Symbol devices with Android KitKat 4.4. So select `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK for this tutorial.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The Encrypt Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"EncryptProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Encrypt Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxEncryptManagerTutorialImages/encrypt_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MyEncryptManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    So as discussed, we will create an Encrypted File System (EFS) that uses a newly installed Encryption Key. Click Install Key drop-down under Install Key section and select option \"Install Key\". Provide Install Key Name (Ex. SampleKey). When installing a key, the value is optional. A provided key value should be a HEX string with a length of 64 bytes. If a value is not provided, a random key will be generated for a given key name. Let's keep the \"Install Key Value\" field empty for this tutorial.\n\n\t![img](images/MxEncryptManagerTutorialImages/install_key.jpg)\n\n5. Now, select \"Create EFS\" drop-down and select field \"Create EFS\" and you would see something like this:\n\n\t![img](images/MxEncryptManagerTutorialImages/create_efs_option.jpg)\n\n6. Provide \"EFS Name\" (Ex. SampleEFS). Provide \"EFS encryption Key Name\" with the same name we are using to install (Ex. Sample Key). Select the \"EFS Location\" to \"SD Card\" Storage as we would be creating EFS on the external SD Card. Provide the \"Mount Path for EFS\" where EFS should be mounted (Ex. \"/external\"). This path belongs to external SD Card storage in this tutorial since we selected the \"EFS Location\" as \"SDCard\". Provide size of the EFS in MB (Ex. 5MB).\n\n\t> Note:  EFS size must be at least 1MB and cannot exceed 4096MB.\n\n\tThe Profile Wizard for Encrypt Manager should now look like:\n\n    ![img](images/MxEncryptManagerTutorialImages/efs_profile.jpg)       \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxEncryptManagerTutorialImages/encrypt_profile_created.jpg)\n\n6. Click Finish and your Encrypt profile for creating an Encrypted File System (EFS) on the SD Card (External Storage) of Symbol device would be created.\n\n    ![img](images/MxEncryptManagerTutorialImages/encrypt_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxEncryptManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxEncryptManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxEncryptManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKManager.EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"EncryptProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n    ![img](images/MxEncryptManagerTutorialImages/variables_added.jpg)\n\n\t![img](images/MxEncryptManagerTutorialImages/on_create_added.jpg)\n\t \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager` if required.  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxEncryptManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxEncryptManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxEncryptManagerTutorialImages/parse_xml_1.jpg) \n\t![img](images/MxEncryptManagerTutorialImages/parse_xml_2.jpg)\n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxEncryptManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxEncryptManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxEncryptManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us create an encrypted file system (EFS) of 5MB with an encryption key on the SD Card (External Storage) of Symbol device using [Encrypt Manager](#guide-profiles-encrypt) feature of Mx. Now let's run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n2. Run the application.\n\n    ![img](images/MxEncryptManagerTutorialImages/home_screen.png)\n\n\t> Note: The process of creating the EFS takes time. Access to the EFS will be denied during the creation process.\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now check in the SD Card (External Storage) of the device whether it has created the \"SampleEFS\" or not.\n\n\tSo go to File Browser -> EFS Path. In our tutorial, EFS path is \"/external\". You will see a directory called \"efsstorage\".\n\n    ![img](images/MxEncryptManagerTutorialImages/efs_directory.png)\n\n4. Open this directory and you would see the Encrypted File System of size 5MB that we created (SampleEFS) through Profile Wizard.\n\n\t![img](images/MxEncryptManagerTutorialImages/efs_created.png)\n\n\n    This is how you can create Encrypted File System (EFS) along with the installation of Encryption Key on the internal/external SD Card storage using [Encrypt Manager](#guide-profiles-encrypt) feature on Symbol devices through Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to create Encrypted File System (EFS) on the internal/external storage of SD Card using [Encrypt Manager](#guide-profiles-encrypt) on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in EMDK for Android V 3.1. So in the next tutorial, we will concentrate on the \"Threat Manager\" feature of Mx and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EncryptManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxErrors","name":" Errors When Processing Profiles","md":"# Errors When Processing Profiles\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will analyze MX errors that we get while using MX features that are declared in Profile creation. These MX errors may occur due to some invalid input while creating a profile or some incorrect device configuration.\n\nIn this tutorial we would be deliberately producing errors by providing invalid inputs in some of the MX features while profile creation, just to see the errors using `getStatusDocument` or `getStatusString` of `EMDKResults`. We would obtain the error description by parsing the resulting XML response and compare the output with the usual working case. \n\nThe goal here is to make you understand how to find errors and correct them if there are any.\t\n \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxErrorsTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding the MX Errors Profile that includes Clock feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"MxErrorsProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select \"Clock\" feature from the list and click \"Right Arrow\". The parameter list will be populated.    \n  \n    ![img](images/MxErrorsTutorialImages/select_clock_feature.jpg)\n\n\tUsing this feature, we will configure the device clock. But we will provide incorrect values while setting Clock parameters and in the code we will parse the XML response and display the result in a dialog.\n\n4. Enter the Clock parameters such as Timezone, Date and Time. The parameters need to be in a certain format mentioned in the wizard for each field. But we will enter incorrect value in the \"Timezone\" field (For Example \"MMT\" which is not a valid TimeZone) and proceed.  \n\n    > Note:\n    > Keep the \"Name\" field empty and AutoTime field unchecked. \n\n    ![img](images/MxErrorsTutorialImages/clock_features.jpg)\n  \n5.  Click Apply and Finish. \n\n    ![img](images/MxErrorsTutorialImages/error_profile_created.jpg)  \n\n6. Click \"Close\".   \n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager. An entry of \"Clock\" feature is created in EMDKConfig.xml file with the attributes that we had set while profile creation. \n\n    ![img](images/MxErrorsTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxErrorsTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxErrorsTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code.\n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        //Assign the profile name used in EMDKConfig.xml  \n        private String profileName = \"MxErrorsProfile\";  \n          \n        //Declare a variable to store ProfileManager object  \n        private ProfileManager profileManager = null;  \n          \n        //Declare a variable to store EMDKManager object  \n        private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\t\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\t\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\t\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";     \n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxErrorsTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    >Note:\n    >Set the name of the method argument to `emdkManager`  \n\n        :::java\n        this.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxErrorsTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxErrorsTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxErrorsTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxErrorsTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxErrorsTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.      \n                            \n6. Now let's override the `onDestroy` method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxErrorsTutorialImages/on_destroy_method.jpg) \n\n\nThat's it!!! We are done with all the coding and incorrect configuration. Now let us run the application and we should get the error in a dialog.\n \n\n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n2. Run the application. \n\n    We get the following XML response as a return of `results.getStatusString()` in the `onOpened` method, which was saved in a `statusXMLResponse` String.\n\n        :::xml\n\t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<wap-provisioningdoc>\n\t      <characteristic type=\"status\">\n\t\t\t<parm name=\"code\" value=\"6\"/>\n\t\t\t<parm name=\"description\" value=\"Review the XML for details\"/>\n\t\t  </characteristic>\n\t\t  <characteristic type=\"Clock\" version=\"4.2\">\n\t\t    <parm name=\"AutoTime\" value=\"false\"/>\n\t\t\t<parm-error name=\"TimeZone\" value=\"MMT\" desc=\"Invalid TimeZone\"/>\n\t\t\t<parm name=\"Date\" value=\"2014-06-27\"/>\n\t\t\t<parm name=\"Time\" value=\"15:00:00\"/>\n\t\t  </characteristic>\n\t\t</wap-provisioningdoc>\n\n    Since the response contains `<parm-error>` tag, the EMDK fails to set the clock. This is because we had set an incorrect value for \"TimeZone\" field (\"MMT\" instead of something like \"GMT+05:30\"). So when we parsed the response we looked for this `parm-error` tag and parsed `name` and `desc` fields of this error tag. Finally we displayed these field in an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) to the user.     \n  \n\t![img](images/MxErrorsTutorialImages/failed_to_set_clock.png)\n\n3. Now let's correct the parameters and get the valid output that can change the clock settings with the parameters that we declared during profile creation.\n\n    So first we will go to profile manager and edit it with the valid \"TimeZone\" value (\"GMT+05:30\" instead of \"MMT\").\n\n    ![img](images/MxErrorsTutorialImages/correct_date.jpg)\n\n    Click \"Apply\", \"Finish\" and then \"Close\".\n\n4. Run the application again.\n\n    Now since we provided valid inputs, we get a valid XML response without errors.\n\n        :::xml\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<wap-provisioningdoc>\n\t\t  <characteristic type=\"status\">\n\t\t    <parm name=\"code\" value=\"6\"/>\n\t\t    <parm name=\"description\" value=\"Review the XML for details\"/>\n\t\t  </characteristic>\n\t\t  <characteristic type=\"Clock\" version=\"4.2\">\n\t\t\t<parm name=\"AutoTime\" value=\"false\"/>\n\t\t\t<parm name=\"TimeZone\" value=\"GMT+05:30\"/>\n\t\t\t<parm name=\"Date\" value=\"2014-06-27\"/>\n\t\t\t<parm name=\"Time\" value=\"15:00:00\"/>\n\t\t  </characteristic>\n\t\t</wap-provisioningdoc>\n\n    As you can see its a valid XML response since it does not contain any `<characteristic-error>` or `<parm-error>` tag. Moreover, the clock parameters that we set during profile creation are also applied successfully to the device. \n\n    ![img](images/MxErrorsTutorialImages/clock_settings_changed.png)\n\n7. In such a way, you can use EMDKResults API with its methods to identify any kind of errors in all the MX features that you used while profile creation. This helps in debugging your application to figure out invalid parameters.            \n  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on a Symbol device will fail because of missing shared library on the device. \n\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxErrorsTutorial.zip).\n"},{"key":"guide-tutorial-tutMxGPRSManager","name":" Configure Access Points using Mx GPRS Manager","md":"# Configure Access Points using Mx GPRS Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on configuring Access Points of the mobile networks present in your Symbol Android device using [GPRS Manager](#guide-profiles-gprs) feature of Mx. [GPRS Manager](#guide-profiles-gprs) allows you to perform following operations on Access Points of your device's mobile network: \n\n**1. Add/Replace named APN:**\n\nUsing this feature, user can add a new APN (Access Point Name) or replace an existing APN on your device's Mobile Network. User can also set a specific APN as default. The EMDK wizard for GPRS Manager requires various inputs such as GPRS Carrier (ATT, T-Mobile or Custom), APN Name and supply details for APN (Access Point, User Name and Password).\n\n   > Note: For ATT and T-Mobile option the user and password filed are required. \n\n**2. Remove existing named APN:**\n\nThis removes a specific named APN from the list of APN's in the device's mobile network. The user just have to provide \"APN Name\" and it will remove that particular named APN from your device's mobile network. \n\n**3. Remove all existing APN's:**  \n\nThis GPRS Manager feature allows user to remove all the existing APN's from the device's mobile network. The user does not need to provide any additional input except selecting the APN Action as \"Remove all existing APN's\".\n\n\nSo now we will create a tutorial to demonstrate how to configure Access Points in the device's mobile Network by creating GPRS Profile in the EMDK Wizard.\n\n   > Note: The device should have network carrier to test GPRS Manager Tutorial.     \n   \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above\n* Symbol Android Device should have Network Carrier. \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxGPRSTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The GPRS Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"GPRSProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Since this is GPRS Manager Tutorial, select the \"GPRS Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxGPRSManagerTutorialImages/gprs_feature.jpg)\n\n    So as discussed earlier we would now try the GPRS features one by one, by changing the \"APN Action\" attribute (Add/Replace, Remove, Remove All) in the wizard. In this step let us add a named APN by performing following actions. \n\n    * Provide some name in the Name field (Ex. MyGPRS). This helps in modifying a particular GPRS Manager of that name programmatically.\n    * Select APN Action as \"Add/Replace named APN\"\n    * Select GPRS Carrier from the drop-down menu. You can choose ATT, T-Mobile or Custom Carrier. As of now select \"ATT\".\n    * Provide APN Name (Ex. ATT_APN_1)\n    * Check the checkbox \"Replace if Exixts?\". This will replace APN with the same name from the list if exists.\n    * Keep the \"Make Default APN?\" field as it is. (keep it unchecked).\n    * Provide Access Point (Ex. wap.cingular)\n    * Provide User Name (Ex. WAP@CINGULARGPRS.COM)\n    * Enter Password (Ex. CINGULAR1)\n\n    ![img](images/MxGPRSManagerTutorialImages/att_gprs_details.jpg)   \n \n4. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxGPRSManagerTutorialImages/att_profile_created.jpg)\n\n5. Click Finish and your GPRS profile for adding an APN is created.\n\n    ![img](images/MxGPRSManagerTutorialImages/att_gprs_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxGPRSManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxGPRSManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxGPRSManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"GPRSProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxGPRSManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxGPRSManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxGPRSManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxGPRSManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxGPRSManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxGPRSManagerTutorialImages/display_results.jpg)\n\t\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxGPRSManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us Add/Replace a named APN. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n    > Make sure the device has Network Carrier\n\n    Before running the application, We will see the Access Points that are already present in the device's Mobile Network.\n\n    Go to device's Settings -> More (in Wireless & Networks) -> Mobile Networks -> Access Point Names\n\n    ![img](images/MxGPRSManagerTutorialImages/existing_access_points.png)\n\n    You can see there are two T-Mobile Access Points already present. After running this application, the ATT Access Point will be added in this list that we had created in GPRS Manager Wizard earlier.  \n\n2. Run the application.\n\n    ![img](images/MxGPRSManagerTutorialImages/home_screen.png)\n\n\tYou can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n\n    Now again go to device's Settings -> More (in Wireless & Networks) -> Mobile Networks -> Access Point Names \n  \n\t![img](images/MxGPRSManagerTutorialImages/att_access_point_added.png)\n\n    You can see that the ATT Access Point that we created has been added successfully to the APN's list.\n\n    > Note: The ATT Access Point is added but not selected as default because we kept \"Make Default APN?\" field unchecked in the Profile Creation Wizard.\n  \n3. In this step we will remove an existing named APN. So select the project \"MxGPRSTutorial\" and click EMDK button at the top-bar to go to \"Profile Manager\" option just like we did earlier.\n\n    ![img](images/MxGPRSManagerTutorialImages/att_gprs_profile_created.jpg)  \n\n4. Click Edit button and you will see our previous configuration of Add/Replace APN:\n\n    ![img](images/MxGPRSManagerTutorialImages/first_edit.jpg)\n\n    Select \"Remove existing named APN\" option from the \"APN Action\" drop down.\n\n    ![img](images/MxGPRSManagerTutorialImages/remove_apn.jpg)\n\n    Provide the unique name of the APN that you had set while Adding that named APN (Ex. ATT_APN_1)\n\n    ![img](images/MxGPRSManagerTutorialImages/remove_att_apn.jpg)\n\n    Click Apply, Finish and then Close. The Profile has now been edited successfully to remove an existing named APN.\n\n6. Run the application again. \n \n\t![img](images/MxGPRSManagerTutorialImages/home_screen.png)\n\n\tYou can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n\n    Go to device's Settings -> More (in Wireless & Networks) -> Mobile Networks -> Access Point Names\n\n    ![img](images/MxGPRSManagerTutorialImages/existing_access_points.png)\n\n    You can see that the named APN \"ATT_APN_1\" has been successfully removed from the device's APN list. \n\n6. Finally, we would test the third feature of GPRS Manager that allows us to remove all the existing APN's.\n\n    Select the project \"MxGPRSTutorial\", go to the Profile Manager and click edit button as we did in previous steps.\n\n    Select \"Remove all existing APN's\" feature from the \"APN Action\" drop-down of GPRS Profile.\n\n    ![img](images/MxGPRSManagerTutorialImages/remove_all_apn.jpg)\n\n    Click Apply, Finish and then Close buttons.\n\n7. Now Run the application for the final time to ensure all APN's are removed from the device's APN list.\n\n    ![img](images/MxGPRSManagerTutorialImages/home_screen.png)\n\n\tYou can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n\n    To verify, go to device's Settings -> More (in Wireless & Networks) -> Mobile Networks -> Access Point Names \n  \n\t![img](images/MxGPRSManagerTutorialImages/all_apn_removed.png)\n\n    You can now see that all the APN's have been successfully removed from the device's APN list.\n\n    This is how the GPRS manager lets us configure Access Points of the Symbol device.\n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol Android device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure the Access Points on your Symbol Android devices through applications, let us try to understand and implement some of the other Mx features. So in the next tutorial, we will concentrate on the \"Access Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxGPRSTutorial.zip)."},{"key":"guide-tutorial-tutMxPersistManager","name":" Persist MX configurations using Persist Manager API","md":"# Persist MX configurations using Persist Manager API\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on [Persist Manager](#guide-profiles-persistence) API, which allows user to persist configuration XML's. These XML's contain various Mx device configuration settings that user may want to persist even after performing Factory Reset or Enterprise Reset on the device. The persisted settings are applied by default when we Factory or Enterprise Reset the device so that user does not have to apply them manually again and again. This is the main purpose of Mx Persist Manager feature. Overall, the Persist Manager API supports following features:   \n\n**1. Adding XML to be Persisted:**\n\nUsing this feature, user can create a new XML to be persisted that has specific configuration settings. (Ex. Mx Clock details)\n\n   > Note: The profile feature \"Data Capture Manager\" will not be persisted.\n\n**2. Removing a Persisted XML:**\n\nUser can remove a specific persisted XML through wizard or API query.\n\n**3. Query to Receive List of all Persisted XML's:**  \n\nThis feature allows user to use EMDK V 2.1 API to query Persist Manager in order to receive a list of all persisted XML's.\n\n**4. Query based on Parameters:** \n \nUsing this feature, user can find a specific persisted XML based on Persist Manager attributes that were used while persisting the XML. These attributes are:\n\n* PersistAsVersion\n* PersistAsOrder\n* PersistIfError\n\n**5. Apply Persisted XML settings after Enterprise Reset:**\n\nThis feature re-sends the persisted XML's to the Mx Framework after an Enterprise Reset. This helps in re-applying configuration settings back to the device for which user had Persisted these XML's.\n\n   > Note: \n   > In order for associated files to survive an \"Enterprise Reset\" they must be placed in the Enterprise Folder on the device. A \"Factory Reset\" will not persist any profiles features.  \n\n\nSo now we will create a tutorial to demonstrate how the configuration XML's are persisted and retrieved using Persist Manager API. Moreover we would perform an enterprise reset on the device and see how the configuration settings are re-applied to the device by designing our tutorial in following steps:\n\n* We would store a Clock and App Manager's install configuration settings and create Persist Manager to store XML for each setting.\n* It means we would change the Clock timing using Mx Clock and install any application using App Manager install feature, which will be stored by Persist Manager. \n* We would then deliberately change the Clock timings and uninstall the application that we had installed.\n* We will then perform an Enterprise Reset on Symbol Android device (Ex. TC55 in this Tutorial)\n* Finally we will ensure how the persisted Clock and App Manager settings are re-applied automatically. It means you would see the Clock is reset to the time you had set and the application installed back to the device from the path provided.     \n   \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above\n* Download the APK for sample App from [here](https://s3.amazonaws.com/emdk/Tutorials/AllInstalledApps.apk)\n* Download the respective Enterprise Reset package (zip file) according to your device OS version from [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Handheld+Computers/TC55) and copy that file in SD card/Internal memory of the device.\n\n    > Note: This above link provides the Update Packages of TC55 device only, which we have used in this tutorial. If you are using some other Symbol Android device then download the respective update package from [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Handheld+Computers)\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxPersistManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The Persist Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"PersistManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n   \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. We will persist two XML's for two Mx features in this tutorial. The first feature is Clock. So select the \"Clock\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxPersistManagerTutorialImages/clock_feature.jpg)\n\n    Set the Clock details by providing Timezone, Date and Time values. All the timings need to be in UTC. It means if you want to set the Timezone to PST, you will need to set the clock to GMT time and it will automatically change it to the local time for you.\n\n    > Note: It means the time you enter always has to be in GMT.\n\n    ForEample:  \n\t* **Name**: MxClock\n\t* **TimeZone**: GMT-07:00\n\t* **Date**: 2014-08-15\n\t* **Time**: 20:00:00\n\n    Here , we have set the Timezone as GMT-07:00. It means if we want to set the PST time of 1PM, we have to set the GMT time as 8PM (20:00:00 in 24 hour format) and it will automatically set the PST time of 1PM for us.\n\n    ![img](images/MxPersistManagerTutorialImages/clock_details.jpg)   \n \n4. Click Apply and your Clock profile is created.    \n  \n    ![img](images/MxPersistManagerTutorialImages/clock_profile_created.jpg)\n\n5. So now we will persist the Clock settings by creating a Persist Manager for Clock. To proceed with this, select \"Persistence Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxPersistManagerTutorialImages/persist_manager.jpg) \n\n6. Provide some name in the Name field (Ex. PersistClock). Select Persist Action as \"Add current XML as a persistent profile\". Select Persist as Name field and a Name Selector dialog will appear. If you want to remove any persisted XML, select Persist Action as \"Remove the specified persistent profile\". \n\n    ![img](images/MxPersistManagerTutorialImages/name_selector_clock.jpg)\n\n    Select Name Type as Generic/Absolute from the drop-down option and provide Generic/Absolute Name in the field (Ex. clock_profile). \n\n    ![img](images/MxPersistManagerTutorialImages/name_selector_clock_details.jpg)\n\n7. Click OK. Enter 1 for \"Persist As Version\". Enter 1 for \"Persist As Order\". Check the \"Persist if Error\" field. This field will persist the XML even if Profile Creation returns error.\n\n    ![img](images/MxPersistManagerTutorialImages/persist_clock_completed.jpg)\n\n    Click Apply and the persist settings for the Clock feature will be added. \n\n    ![img](images/MxPersistManagerTutorialImages/clock_profile_added.jpg)\n\n8. So far we have added the Persist configurations for Clock feature. Now its time to persist App Manager feature as discussed earlier. We will follow similar steps as we did for Clock. Select \"App Manager\" feature and Click \"Right Arrow\". It will show \"App Manager\" parameter list.\n\n    ![img](images/MxPersistManagerTutorialImages/app_manager_parameter_list.jpg)\n\n9. Provide some name in the Name field (Ex. MxAppManager). Select Action as \"Install\" and Provide the APK path to the SD Card of the application that we had downloaded earlier (Ex. /storage/sdcard1/AllInstalledApps.apk). So this feature will install the app in the device from the provided APK file.\n\n    > Note: The SD Card path may be different on different devices.\n\n    ![img](images/MxPersistManagerTutorialImages/app_manager_details.jpg)\n\n10. We will add another Persist Manager to persist the App Manager settings. So select \"Persistence Manager\" from the feature list and click \"Right Arrow\".\n\n    ![img](images/MxPersistManagerTutorialImages/persist_app_manager.jpg)\n\n11. Provide some name in the Name field (Ex. PersistAppManager). Select Persist Action as \"Add current XML as a persistent profile\". If you want to remove any persisted XML, select Persist Action as \"Remove Persistent the specified persistent profile\". Select the \"Persist As Name\" field and provide Absolute/Generic path as we did earlier for the Clock (Ex. PersistAppManager). Enter 1 for \"Persist As Version\". Enter 1 for \"Persist As Order\". Check the \"Persist if Error\" field. This field will persist the XML even if Profile Creation returns error.\n\n    ![img](images/MxPersistManagerTutorialImages/persist_app_manager_completed.jpg)  \n  \n12. Click Apply and Finish. \n\n    ![img](images/MxPersistManagerTutorialImages/persist_manager_profile_created.jpg)  \n\n13. Click \"Close\". This will create our Persist Manager Profile that is ready to Persist details for Clock and App manager features of Mx.   \n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n14. You can inspect the \"EMDKConfig.xml\" to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxPersistManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxPersistManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxPersistManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code.\n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"PersistManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxPersistManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to persist profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxWirelessManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxWirelessManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxPersistManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxPersistManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxPersistManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxPersistManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Check the Date-Time of the phone before running the app\n\n    ![img](images/MxPersistManagerTutorialImages/before_running_app.png)\n  \n2. Run the application. The Clock and and App Manager configurations are applied and persisted in the device. It means you can now see the Clock Date-Time has been changed to the one we had set in the wizard. You can also see that EMDK App Manager has installed the application \"AllInstalledApps\" whose APK path we had provided in the wizard earlier. \n  \n\t![img](images/MxPersistManagerTutorialImages/xml_persisted.png)\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n\n    Now check the Date-Time of the device. You could see that it has changed to the one we set in the wizard during Profile Creation.\n\n    ![img](images/MxPersistManagerTutorialImages/date_time_updated.png)\n\n    You can also see that APK path of the application we had provided in the wizard during Profile creation has been installed successfully on the device using App Manager's install feature.\n\n    ![img](images/MxPersistManagerTutorialImages/app_installed.png)\n  \n3. These configurations were implemented and applied by the respective Mx feature (Clock and App Manager) but the settings are persisted in the XML file by the Persist Manager. If you open the File browser of TC 55 and go to \"/enterprise/usr/persist/mxframework/persistmgr\", you will find the two XML's persisted that were created using Persist Manager for Clock and App Manager features of Mx. \n\n    ![img](images/MxPersistManagerTutorialImages/persist_path.png)\n\n5. Now we will see how these Clock and App Manager settings are re-applied automatically after performing Enterprise Reset on the device.\n\n    > Note: Enterprise Reset erases all the user installed applications and resets the Clock to the default time. But in our case system will read the details from Persisted XML files and apply changes to the device.\n    > Make sure that the Enterprise Reset package (zip file) is present in the device's SD Card.\n\n6. Let us perform Enterprise Reset on the TC55 Android device. Simultaneously press the Power, Programmable and Volume Up buttons \n \n\t![img](images/MxPersistManagerTutorialImages/reset_process.jpg)\n\n    The TC55 shuts down and then reboots. Now select the Enterprise Reset Package (Zip File) stored in the SD Card by navigating to the path. It will complete the Enterprise Reset by erasing data and reboot the device with the default configurations.\n\n6. Once the Enterprise Reset is completed, Persist Manager resends the persisted XML's to the Mx Framework, which is captured by the device. These settings are then re-applied to the device. This is how the Persist Manager works in order to Persist and apply the Mx device configuration features.\n\n    ![img](images/MxPersistManagerTutorialImages/after_reset.png)\n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol Android device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure and persist device configuration XML's using Persist Manager on your Symbol devices through applications, let us try to understand and implement some of the other Mx features. So in the next tutorial, we will concentrate on the \"GPRS Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxPersistManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxPowerKeyManager","name":" Disable Airplane Mode Menu Option using Power Key Manager","md":"# Disable Airplane Mode Menu Option using Power Key Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on configuring Power Key Manager parameters such as Airplane Mode, Touch Panel, Safe Mode and Auto Screen Lock using [Power Key Manager](#guide-profiles-powerkey) feature of Mx.\n\nThe PowerKey Manager feature allows your application to control which options appear on the power menu on the device. Out of different available power key parameters, we would control Airplane Mode in this tutorial.  \n\nSo now we will create a tutorial to disable the \"Airplane Mode\" option from the Power Key Menu using Mx [Power Key Manager](#guide-profiles-powerkey) feature on your Symbol Android device. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: 1. Provide \"PowerKeyManagerTutorial\" as the project name for this tutorial. 2. This feature requires Symbol device with Android KitKat 4.4.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\n> Note: Power Key Manager feature requires Symbol devices with Android KitKat 4.4. So select `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK for this tutorial.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The Power Key Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"PowerKeyProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Power Key Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxPowerKeyManagerTutorialImages/power_key_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MyPowerKeyManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n\tPower Key Manager allows you to configure following options in the Menu Option:\n\n\t* **Airplane Mode** - Select whether the Airplane Mode option should appear on the Power Key Menu.\n\n\t* **Touch Panel** - Select whether the Touch Panel option should appear on the Power Key Menu.\n\n\t* **Safe Mode** - Select whether the Safe Mode option should appear on the Power Key Menu.\n\n\t* **Auto Screen Lock Option** - Select whether Power button instantly Locks option should appear on Settings UI.\n\n\t* **Auto Screen Lock State** - Select whether screen lock should automatically be required if the device is powered OFF using the Power Key.  \n\n    So as discussed, we will disable the \"Airplane Mode\" option from the Power Key Menu through Profile Manager Wizard using Power Key Manager feature of Mx. By doing so, the user will not be able to access Airplane Mode option unless it is enabled back through Profile Manager. So click on \"Airplane Mode Power Key Menu Option\" drop-down in the wizard and select \"Do not Show Menu Option\".\n\n    ![img](images/MxPowerKeyManagerTutorialImages/power_key_manager_details.jpg)\n\n    ![img](images/MxPowerKeyManagerTutorialImages/power_key_manager_details_selected.jpg)    \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxPowerKeyManagerTutorialImages/power_key_profile_created.jpg)\n\n6. Click Finish and your Power Key profile for disabling Airplane Mode Menu Option is created.\n\n    ![img](images/MxPowerKeyManagerTutorialImages/power_key_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxPowerKeyManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxPowerKeyManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxPowerKeyManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"PowerKeyProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n    ![img](images/MxPowerKeyManagerTutorialImages/variables_added.jpg)\n\n\t![img](images/MxPowerKeyManagerTutorialImages/on_create_added.jpg)\n\t \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager` if required.  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxPowerKeyManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxPowerKeyManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxPowerKeyManagerTutorialImages/parse_xml_1.jpg) \n\t![img](images/MxPowerKeyManagerTutorialImages/parse_xml_2.jpg)\n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxPowerKeyManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxPowerKeyManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxPowerKeyManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us disable Airplane Mode Power Key Menu Option through Profile Manager Wizard using Power Key Manager feature of Mx.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We will see the status of Airplane Mode Menu Option and make sure it is enabled. \n\n    Go to device's Settings -> More...  and you can see that Airplane Mode Power Key Menu Option is enabled, which means user can edit it.\n\n    ![img](images/MxPowerKeyManagerTutorialImages/airplane_mode_enabled.png) \n\n2. Run the application.\n\n    ![img](images/MxPowerKeyManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now see the status of \"Airplane Mode\" in the settings. So go to device's Settings -> More... and you would see that \"Airplane Mode\" has been disabled by Mx Admin through Profile Manager Wizard using Power Key Manager.  \n\n    ![img](images/MxPowerKeyManagerTutorialImages/airplane_mode_disabled.png)\n\n4. You can enable this option again through Profile Manager Wizard by applying respective settings.\n\n\t![img](images/MxPowerKeyManagerTutorialImages/airplane_mode_reenable.jpg)\n\n    This is how Power Key Manager lets us configure Airplane Mode Power Key Menu Option on Symbol devices using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to disable Airplane Mode Power Key Option using Power Key Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in EMDK for Android V 3.1. So in the next tutorial, we will concentrate on the \"SD Card Manager\" feature of Mx and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/PowerKeyManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxPowerManager","name":" Power Management using Power Manager API","md":"# Power Management using Power Manager API\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on [Power Manager](#guide-profiles-power) API, which allows user to perform Power Management operations on Symbol Android devices. Theses operations include setting the device in sleep mode, rebooting the device and updating device Operating System as follows:\n\n**1. Sleep Mode:**\n\nThis feature allows device to enter the sleep mode in order to conserve power.\n\n**2. Device Reboot:**\n\nDevice Reboot feature restarts the Symbol device from the app itself.\n\n**3. OS Update:**  \n\nThis Power Manager feature allows you to update the operating system of your Symbol Android device. The user needs to provide path of update package (zip file) that resides in the device's external SD Card. Based on the package (zip file), the user can perform following operations using OS Update feature:\n\n   > Note: Copy the update package to external SD Card in order to make update OS work. If you copy update package to the internal SD card of the device, the OS Update feature won't work.  \n\n* **Enterprise Reset:** Resets the device data except Mx Enterprise Packages.\n* **Factory Reset:** Resets the device data.\n* **Full Device Wipe:** Performs a full device wipe. Supported on Symbol devices with KitKat version. \n* **OS Upgrade:** Upgrades/Downgrades device's Operating System.\n \nIn this tutorial, We would be implementing all three features of Power Manager to understand how they work. \n \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above\n* Download the respective OS update/Factory Reset/Enterprise Reset package (zip file) from [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Handheld+Computers/TC55) and copy that file to external SD card of the device.\n\n    > Note: This above link provides the Update Packages of TC55 device only, which we have used in this tutorial. If you are using some other Symbol Android device then download the respective update package from [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Handheld+Computers)\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxPowerManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK. \n\n## Adding The Power Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"PowerManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Power Manager\" feature from the list and click \"Right Arrow\". Using this feature you can perform various Power Management operations through your apps on the Symbol device. These operations include setting the device into sleep mode , rebooting the device and updating OS of the Symbol Android devices as explained earlier.\n\n4. Click on the Power Manager feature. The parameter list will be populated.  \n  \n    ![img](images/MxPowerManagerTutorialImages/select_power_manager_feature.jpg)\n\n5. Now Click on the drop-down of the action field to see the supported features by Power Manager.\n\n    ![img](images/MxPowerManagerTutorialImages/power_manager_features.jpg)\n\n    There are different features shown in the drop down as explained earlier. As the name suggests, the feature `Do Nothing` does nothing. We would be configuring above mentioned three features from the application itself. Hence let us select the `Reset Action` in the wizard as `Do Nothing`.\n\n    > Note: You could select any option you want in the wizard and the application will implement that feature on the launch.\n\n    ![img](images/MxPowerManagerTutorialImages/feature_do_nothing.jpg)\n\n    > Note: Provide some name in the Name field (Ex. MyPowerManager) in order to refer that specific feature of Profile.\n    > You can also keep Name field empty.\n  \n6.  Click Apply and Finish. \n\n    ![img](images/MxPowerManagerTutorialImages/power_manager_profile_created.jpg)  \n\n7. Click \"Close\".   \n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n8. You can inspect the \"EMDKConfig.xml\" to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager. So you can see the entry of the 'Reset Action' parameter of Power Manager feature and the value assigned to it is 0.\n\n    Now there are specific values that are assigned to the parameters in Power Manager feature:\n\n    * 0 - Do Nothing\n    * 1 - Sleep Mode\n    * 4 - Reboot\n    * 5 - Enterprise Reset\n    * 6 - Factory Reset\n    * 7 - Full Device Wipe\n    * 8 - OS Update\n\n    Based on user selection, these values would be assigned against these parameters of the Power Manager feature in EMDKConfig file.\n\n    > Note: These values are useful when we modify Profile from the application using EMDK API, which we will see shortly in this tutorial.\n\n    ![img](images/MxPowerManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxPowerManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxPowerManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager. We will also create global variables to hold the UI elements and values that are required in this application. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"PowerManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t    // Text View for displaying status of EMDK operations\n\t    private TextView statusTextView = null;\n\n\t    // Radio Group to hold Radio Buttons for Power Manager Options\n\t    private RadioGroup pwrRadioGroup = null;\n\n\t    // Edit Text that allows user to enter the path of the update package from\n\t    // external SD Card\n\t    private EditText zipFilePathEditText;\n\n\t    // String that gets the path of the OS Update Package from Edit Text\n\t    private String zipFilePath;\n\n\t    // Initial Value of the Power Manager options to be executed in the\n\t    // onOpened() method when the EMDK is ready. Default Value set in the wizard\n\t    // is 0.\n\t    // 0 -> Do Nothing\n\t    // 1 -> Sleep Mode\n\t    // 4 -> Reboot\n\t\t// 5 -> Enterprise Reset\n\t\t// 6 -> Factory Reset\n\t\t// 7 -> Full Device Wipe\n\t    // 8 -> OS Update\n\t    private int value = 0;\n\n\t    // Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    So the code looks like:\n\n    ![img](images/MxPowerManagerTutorialImages/global_variable_entry.jpg)\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxPowerManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. Hence we will update the status in the `statusTextView`. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tstatusTextView.setText(\"EMDK open success.\");\n\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:  \n\n        :::java\n        if (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the\n\t\t\t// profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t    if (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\t\t\t} else {\n\t\t\t\t// Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t    (DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\t\t}\n\n\tThis `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method. So we will call a method `handleEMDKResult` to handle this [EMDKResults](#api-EMDKResults), which we will create in the next step.\n\n\t\t:::java\n\t\t// Method call to handle EMDKResult\n\t\thandleEMDKResult(results);  \n\n    Your onOpened method should now look like this:\n    \n    ![img](images/MxPowerManagerTutorialImages/on_opened_method.jpg)\n\n3. It shows error as we have not yet declared `handleEMDKResult` method. So let us create this method, which would get the XML String response from [EMDKResults](#api-EMDKResults), call the `parseXML` method to parse it and eventually call `displayResults` method to display output in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html), which we would be declaring in coming steps. \n\n\t\t:::java\n\t\t// Method to handle EMDKResult by extracting response and parsing it\n\t\tpublic void handleEMDKResult(EMDKResults results) {\n\t\t\t// Get XML response as a String\n\t\t\tString statusXMLResponse = results.getStatusString();\n\t\n\t\t\ttry {\n\t\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t\t// for the parser\n\t\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t\t// Call method to parse the response\n\t\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\n\t\t\t// Method call to display results in a dialog\n\t\t\tdisplayResults();\n\t\t}\n\n\tYour `handleEMDKResult` method should now look like this:\n    \n    ![img](images/MxPowerManagerTutorialImages/handle_emdk_result.jpg)\n\n4. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxPowerManagerTutorialImages/parse_xml.jpg)\n\n5. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxPowerManagerTutorialImages/build_failure_message.jpg)\n\n6. In this step, we will add `displayResults` method to display the result of profile operation. If the Profile is successfully applied, it will proceed with the respective power manager operation and in case of any errors, we will display a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with the corresponding error details.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog in case of any errors\n\t\tpublic void displayResults() {\n\n\t\t  // Display dialog in case of errors else proceed.\n\t\t  if (!TextUtils.isEmpty(errorDescription)) {\n\t\t   \t// Alert Dialog to display the status of the Profile creation\n\t\t\t// operation of MX features\n\t\t\tAlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\t\tMainActivity.this);\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\n\t\t\talertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t// create alert dialog\n\t\t\tAlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t\t// show it\n\t\t\talertDialog.show();\n\t\t  }\n\t    }\n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxPowerManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n7. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxPowerManagerTutorialImages/on_destroy_method.jpg) \n\n8. Let us set the required layout/View for this tutorial. Remove all the code, inside \"res/layout/activity_main.xml\".\n\n9. Add the following code that has three radio buttons that enable user to select a specific Power Manager feature, an Edit Text that allows user to enter the external SD Card path to the OS update package (zip file), a Text View that displays the status of every operation the user performs and a Button that triggers the user selected Power Manager feature and configures the device based on that.\n\n\t> Note: Copy the update package to external SD Card in order to make update OS work. If you copy update package to the internal SD card of the device, the OS Update feature won't work.  \n\n\t    :::xml\n\t    <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    android:layout_margin=\"20dip\"\n\t    tools:context=\".MainActivity\" >\n\t\n\t      <LinearLayout\n\t      android:id=\"@+id/linearLayout1\"\n\t      android:layout_width=\"wrap_content\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:layout_alignParentLeft=\"true\"\n\t      android:layout_alignParentRight=\"true\"\n\t      android:layout_alignParentTop=\"true\"\n\t      android:orientation=\"vertical\" >\n\t      </LinearLayout>\n\t\n\t      <TextView\n\t      android:id=\"@+id/textView1\"\n\t      android:layout_width=\"wrap_content\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:layout_alignLeft=\"@+id/linearLayout1\"\n\t      android:layout_alignRight=\"@+id/linearLayout1\"\n\t      android:layout_below=\"@+id/buttonSet\"\n\t      android:layout_marginTop=\"20dp\"\n\t      android:text=\"Status:\" />\n\t\n\t      <RadioGroup\n\t      android:id=\"@+id/radioGroupPwr\"\n\t      android:layout_width=\"wrap_content\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:layout_alignLeft=\"@+id/linearLayout1\"\n\t      android:layout_alignTop=\"@+id/linearLayout1\" >\n\t\n\t      <TextView\n\t      android:layout_width=\"wrap_content\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:layout_margin=\"10dip\"\n\t      android:text=\"Choose your Power Manager Option:\"\n\t      android:textSize=\"16sp\"\n\t      android:textStyle=\"bold\" />\n\t\n\t      <RadioButton\n\t      android:id=\"@+id/radioSuspend\"\n\t      android:layout_width=\"279dp\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:text=\"Suspend (sleep mode)\" />\n\t\n\t      <RadioButton\n\t      android:id=\"@+id/radioReset\"\n\t      android:layout_width=\"match_parent\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:text=\"Perform reset (reboot)\" />\n\t\n\t      <RadioButton\n\t      android:id=\"@+id/radioOSUpdate\"\n\t      android:layout_width=\"match_parent\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:text=\"Perform OS Update\" />\n\t\n\t      <TextView\n\t      android:layout_width=\"wrap_content\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:layout_margin=\"10dip\"\n\t      android:text=\"Specify Path and Name of the Zip file in the file system for OS Update\"\n\t      android:textSize=\"16sp\" />\n\t\n\t      <EditText\n\t      android:id=\"@+id/et_zip_file_path\"\n\t      android:layout_width=\"match_parent\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:hint=\"Path and Name of Zip file\"\n\t      android:maxLines=\"2\" />\n\t      </RadioGroup>\n\t\n\t      <Button\n\t      android:id=\"@+id/buttonSet\"\n\t      android:layout_width=\"wrap_content\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:layout_below=\"@+id/radioGroupPwr\"\n\t      android:layout_centerHorizontal=\"true\"\n\t      android:layout_marginTop=\"32dp\"\n\t      android:text=\"Set\" />\n\t\n\t      <TextView\n\t      android:id=\"@+id/textViewStatus\"\n\t      android:layout_width=\"wrap_content\"\n\t      android:layout_height=\"wrap_content\"\n\t      android:layout_alignLeft=\"@+id/textView1\"\n\t      android:layout_alignRight=\"@+id/textView1\"\n\t      android:layout_below=\"@+id/textView1\" />\n\t\n\t    </RelativeLayout>\n\n\tThe layout file 'activity_main.xml' should now look like:\n\n\t![img](images/MxPowerManagerTutorialImages/activity_main.jpg)\n\n10. Get the reference of UI elements and make a call to 'addSetButtonListener' method in 'onCreate' method. We would add this method in the next step. The method 'addSetButtonListener' creates on Click Listener for the Set Button that implements Power Manager settings selected by user. \n\n        :::java\n        // References of the UI elements\n\t\tstatusTextView = (TextView) findViewById(R.id.textViewStatus);\n\t\tpwrRadioGroup = (RadioGroup) findViewById(R.id.radioGroupPwr);\n\t\tzipFilePathEditText = (EditText) findViewById(R.id.et_zip_file_path);\n\n\t\t// Set on Click listener to the set button to execute Power Manager\n\t\t// operations\n\t\taddSetButtonListener();\n \n     So the complete `onCreate` method looks like:\n\n    ![img](images/MxPowerManagerTutorialImages/complete_on_create.jpg)\n\n11. It shows an error on the method call of 'addSetButtonListener' because we have not yet added this method. We would now add the 'addSetButtonListener' method that implements on click listener of the radio buttons that are assigned to each of the Power Manager feature. As explained earlier, it sets an integer code (1-Sleep, 4-Reboot or 8-OS Update) in the variable 'value' and then calls 'modifyProfile_XMLString' method that actually modifies the Profile settings based on this value and configures the device against that Power Manager feature.\n\n        :::java\n        // Method to set on click listener on the Set Button\n\t    private void addSetButtonListener() {\n\n\t\t // Get Reference to the Set Button\n\t\t Button setButton = (Button) findViewById(R.id.buttonSet);\n\n\t\t // On Click Listener\n\t\t setButton.setOnClickListener(new OnClickListener() {\n\n\t\t \t@Override\n\t\t\tpublic void onClick(View arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\n\t\t\t\t// Get Reference to the Radio Buttons that show various Power\n\t\t\t\t// Manager Options\n\t\t\t\tint radioid = pwrRadioGroup.getCheckedRadioButtonId();\n\n\t\t\t\tif (radioid == R.id.radioSuspend)\n\t\t\t\t\tvalue = 1; // 1 - Suspend/ Sleep Mode (Set device to the\n\t\t\t\t\t\t\t\t// sleep mode)\n\n\t\t\t\tif (radioid == R.id.radioReset)\n\t\t\t\t\tvalue = 4; // 4 - Perform Reset/Reboot (Reboot Device)\n\n\t\t\t\tif (radioid == R.id.radioOSUpdate)\n\t\t\t\t\tvalue = 8; // 8 - Perform OS Update\n\n\t\t\t\t// Apply Settings selected by user\n\t\t\t\tmodifyProfile_XMLString();\n\t\t\t}\n\t\t });\n\n\t    }\n\n    So the method looks like:\n\n    ![img](images/MxPowerManagerTutorialImages/add_set_button_listener.jpg)\n   \n12. The above code would display error at the call of `modifyProfile_XMLString` method as we have not added that method yet. This is the method that actually modifies the Power Manager Profile Settings and configures the device with the user selected Power Manager feature (Sleep Mode, Reboot or OS Update). This method prepares the xml input for the `processProfile` method based on \"value\" attribute. If the value is 1 or 4 (Sleep Mode or Reboot), then the XML input remains the same except value attribute. If the value is 8 (OS Update), we need to add path to the OS Update package in XML input. So the XML input for this case would be different as explained in the `If-Else` condition of the code. We would capture that path from the Edit Text and store it to the `zipFilePath` variable. It then calls `handleEMDKResult` method and sets the profile by following similar steps as explained in case of `onOpened` method.\n\n    Following is an example of XML input for OS Update feature of Power Manager where the `zipFilePath` variable contains the path of the update package.\n\n        :::java\n        modifyData[0] = <?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"PowerManagerProfile\\\"/>\"\n\t\t+ \"<characteristic type=\\\"PowerMgr\\\">\"\n\t\t+ \"<parm name=\\\"ResetAction\\\" value=\\\"\" + value\n\t\t+ \"\\\"/>\" + \"<characteristic type=\\\"file-details\\\">\"\n\t\t+ \"<parm name=\\\"ZipFile\\\" value=\\\"\" + zipFilePath\n\t\t+ \"\\\"/>\" + \"</characteristic>\" + \"</characteristic>\"\n\t\t+ \"</characteristic>\n\n    The `processProfile` method then sets the changes to `Profile Manager` and returns the result to the `EMDKResults`.\n\n        :::java\n        // Method that applies the modified settings to the EMDK Profile based on\n\t    // user selected options of Power Manager feature.\n\t    private void modifyProfile_XMLString() {\n\n\t\t  // Prepare XML to modify the existing profile\n\t\t  String[] modifyData = new String[1];\n\t\t  if (value == 8) {\n\t\t\tzipFilePath = zipFilePathEditText.getText().toString();\n\t\t\t// If the OS Package path entered by user is empty then display\n\t\t\t// a Toast\n\t\t\tif (TextUtils.isEmpty(zipFilePath)) {\n\t\t\t\tToast.makeText(MainActivity.this, \"Incorrect File Path...\",\n\t\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Modified XML input for OS Update feature that contains path\n\t\t\t// to the update package\n\t\t\tmodifyData[0] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t\t\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t\t\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"PowerManagerProfile\\\"/>\"\n\t\t\t\t\t+ \"<characteristic type=\\\"PowerMgr\\\">\"\n\t\t\t\t\t+ \"<parm name=\\\"ResetAction\\\" value=\\\"\" + value + \"\\\"/>\"\n\t\t\t\t\t+ \"<characteristic type=\\\"file-details\\\">\"\n\t\t\t\t\t+ \"<parm name=\\\"ZipFile\\\" value=\\\"\" + zipFilePath + \"\\\"/>\"\n\t\t\t\t\t+ \"</characteristic>\" + \"</characteristic>\"\n\t\t\t\t\t+ \"</characteristic>\";\n\t\t  } else {\n\t\t\t// Modified XML input for Sleep and Reboot feature based on user\n\t\t\t// selected options of radio button\n\t\t\t// value = 1 -> Sleep Mode\n\t\t\t// value = 4 -> Rebbot\n\t\t\tmodifyData[0] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t\t\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t\t\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"PowerManagerProfile\\\"/>\"\n\t\t\t\t\t+ \"<characteristic type=\\\"PowerMgr\\\">\"\n\t\t\t\t\t+ \"<parm name=\\\"ResetAction\\\" value=\\\"\" + value + \"\\\"/>\"\n\t\t\t\t\t+ \"</characteristic>\" + \"</characteristic>\";\n\t\t  }\n\n\t\t  // Call process profile to modify the profile of specified profile\n\t\t  // name\n\t\t  EMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t  if (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\t\t\t// Method call to handle EMDKResult\n\t\t\thandleEMDKResult(results);\n\t\t  } else {\n\t\t\t// Show dialog of Failure\n\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\tbuilder.setMessage(\"Failed to apply profile...\").setPositiveButton(\n\t\t\t\t\t\"OK\", new DialogInterface.OnClickListener() {\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\tAlertDialog alert = builder.create();\n\t\t\talert.show();\n\t\t  }\n\t    }\n\n    You can see that the error is gone once we add this method.\n    The method `modifyProfile_XMLString` method should look like: \n\n    ![img](images/MxPowerManagerTutorialImages/modifyProfile_XMLString.jpg) \n\n13. If the EMDK is closed abruptly, a callback method `onClosed` gets called, where you could release your `EMDKManager`.\n\nThat's it!!! We are done with all the coding and configuration part. Now let us run the application.\n \n\n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n2. Run the application. Since we have set `Do Nothing` parameter in the Profile Manager wizard, the app just loads and performs no operations. So you can see the main page with three radio button options (Sleep Mode, Reboot and OS Update).\n  \n\t![img](images/MxPowerManagerTutorialImages/home_screen.png)\n  \n4. Now we will select these options one by one. So select \"Suspend\" radio button and press the \"Set\" button. This will put your device into sleep mode by locking it.\n\n    ![img](images/MxPowerManagerTutorialImages/sleep_mode.png)\n\n    As you can see, the device has been locked. So unlock it and the app will be resumed.\n  \n\t![img](images/MxPowerManagerTutorialImages/sleep_mode_resumed.png)\n\n5. So now select second option (Reboot) and press the \"Set\" button. This should reboot your Symbol Android device.\n \n\t![img](images/MxPowerManagerTutorialImages/reboot_mode.png)\n\n6. As the device was rebooted in the previous step, open the app again and select the third option (OS Update). Provide the path in the Edit Text to the external SD card where the OS Update Package is located. This package should be a zip file downloaded from [this link](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Handheld+Computers/TC55) (Ex. /sdcard/T55N0JB0VRUEN17400.zip).\n\n    > Note: This above link provides the Update Packages of TC55 device only. If you are using some other Symbol Android device then download the respective update package from [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Handheld+Computers)\n\n    This package could be an OS upgrade, Factory Reset or Enterprise Reset package as this feature allows you to perform all these operations. We will be using an update Package that has been downloaded from above link for TC55 device. \n\n    ![img](images/MxPowerManagerTutorialImages/os_update_path.png)\n\n    Once the \"Set\" button is pressed, the phone will shut down for performing OS update with the respective update package.\n\n    > Note:\n    > In case of failure due to incorrect path, the app will display a failure message in the status Text View at the bottom.\n\n    ![img](images/MxPowerManagerTutorialImages/performing_os_update.png)\n\n    Finally the device reboots to configure and apply the OS update changes.\n\n    ![img](images/MxPowerManagerTutorialImages/after_os_update.png)   \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure and perform Power Management operations on your Symbol Android devices through applications using Mx Power Manager feature, let us try to understand and implement some of the other Mx features. So in the next tutorial, we will concentrate on the \"Persist Manager\" feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxPowerManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxSDCardManager","name":" Configure the use of SD Card using SD Card Manager","md":"# Configure the use of SD Card using SD Card Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. This tutorial will focus on configuring SD Card by allowing you to Enable/Disable the use of it using [SD Card Manager](#guide-profiles-sdcard) feature of Mx. \n\nSo now we will create a tutorial to disable the use of external SD Card and then enable it back using Mx [SD Card Manager](#guide-profiles-sdcard) feature through Profile Wizard on your Symbol device. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.1 and above \n* Make sure you have an external SD Card in the device\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: 1. Provide \"SDCardManagerTutorial\" as the project name for this tutorial. \n> 2. This feature requires Symbol device with Android KitKat 4.4. \n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\n> Note: SD Card Manager feature requires Symbol devices with Android KitKat 4.4. So select `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK for this tutorial.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The SD Card Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"SDCardProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"SD Card Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxSDCardManagerTutorialImages/sd_card_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MySDCardManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    So as discussed, we will disable the use of SD Card in the Symbol device using SD Card Manager feature of Mx through Profile Manager wizard. So click on \"Enable or Disable use of SdCard\" drop-down in the wizard and select the option \"Disable\".    \n\n    ![img](images/MxSDCardManagerTutorialImages/sd_card_manager_details.jpg)\n\n    ![img](images/MxSDCardManagerTutorialImages/sd_card_manager_details_selected.jpg)    \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxSDCardManagerTutorialImages/sd_card_profile_created.jpg)\n\n6. Click Finish and your SD Card profile for disabling the use of SD Card is created.\n\n    ![img](images/MxSDCardManagerTutorialImages/sd_card_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxSDCardManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxSDCardManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxSDCardManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"SDCardProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n    ![img](images/MxSDCardManagerTutorialImages/variables_added.jpg)\n\n\t![img](images/MxSDCardManagerTutorialImages/on_create_added.jpg)\n\t \n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager` if required.  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxSDCardManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxSDCardManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxSDCardManagerTutorialImages/parse_xml_1.jpg) \n\t![img](images/MxSDCardManagerTutorialImages/parse_xml_2.jpg)\n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxSDCardManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxSDCardManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxSDCardManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us disable external SD Card using [SD Card Manager](#guide-profiles-sdcard) feature of Mx. Now let's run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We need to make sure that we have an external SD card enabled in the device. \n\n    Go to device's File Browser -> external, and you would see that SD Card is enabled at this stage.\n\n    ![img](images/MxSDCardManagerTutorialImages/sd_card_enabled.png) \n\n2. Run the application.\n\n    ![img](images/MxSDCardManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now see the status of external SD Card by again going into device's File Browser -> external directory.\n\n    ![img](images/MxSDCardManagerTutorialImages/sd_card_disabled.png)\n\n4. You will see an empty \"external\" directory. It means the SD card has been successfully disabled. Now lets enable the SD Card in order to view the content in \"external\" directory of device's File Browser. So open the Profile Manager and Click \"Edit\" button.\n\n\t![img](images/MxSDCardManagerTutorialImages/edit_profile_manager.jpg)\n\n5. Click on \"Enable or Disable use of SDCard\" drop-down and select option \"Enable\".\n\n\t![img](images/MxSDCardManagerTutorialImages/sd_card_re_enabled.jpg)\n\n\tClick \"Apply\", \"Finish\" and \"Close\".\n\n6. Now Run the application again and this time you will see that the SD Card has been successfully enabled back by checking File Browser -> external directory of the device.\n\n\t![img](images/MxSDCardManagerTutorialImages/sd_card_enabled.png)\n\n    This is how you can Enable/Disable the use of SD Card using [SD Card Manager](#guide-profiles-sdcard) on Symbol devices using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure the use of SD Card (Enable/Disable) using [SD Card Manager](#guide-profiles-sdcard) on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in EMDK for Android V 3.1. So in the next tutorial, we will concentrate on the \"Encrypt Manager\" feature of Mx and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/SDCardManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxSettingsManager","name":" Invoke Enterprise Reset in Settings UI","md":"# Invoke Enterprise Reset in Settings UI\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on the ability to configure Enterprise Reset option in Settings UI on your Symbol device using [Settings Manager](#guide-profiles-settings) feature of Mx. \n\nSo now we will create a tutorial and disable the ability to invoke Enterprise Reset in Settings UI of your Symbol Android device using Mx [Settings Manager](#guide-profiles-settings) feature. A typical use case for this could be to prevent user by accidentally pressing \"Enterprise Reset\" option.  \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxSettingsManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The Settings Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"SettingsManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.   \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Settings Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxSettingsManagerTutorialImages/settings_feature.jpg)\n\n    Provide some name in the \"Name\" field (Ex. MySettingsManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    Since we want to disable the Enterprise Reset option in Settings UI, select \"Disable\" in \"Ability to invoke Enterprise Reset in Settings UI\" drop-down. You can see that Settings Manager also offers some additional features such as turning ON/OFF Wi-Fi, UnknownSources and Airplane Mode on Settings UI.  \n\n    > Note: You can Enable, Disable or keep the existing settings based on your selection from the drop-down.     \n\n    ![img](images/MxSettingsManagerTutorialImages/settings_manager_details.jpg)\n\n    ![img](images/MxSettingsManagerTutorialImages/settings_manager_details_selected.jpg)    \n \n4. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxSettingsManagerTutorialImages/settings_profile_created.jpg)\n\n5. Click Finish and your Settings Manager profile for disabling Enterprise Reset option on Settings UI is created.\n\n    ![img](images/MxSettingsManagerTutorialImages/settings_manager_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" created under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxSettingsManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxSettingsManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:   \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxSettingsManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code.\n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"SettingsManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxSettingsManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it retuns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxSettingsManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxSettingsManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxSettingsManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxSettingsManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxSettingsManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxSettingsManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us **disable** Enterprise Reset in Settings UI on our Symbol Android device. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.  \n\n2. Now, Run the application.\n\n    ![img](images/MxSettingsManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message, which indicates that the app has successfully disabled the Enterprise Reset option in Settings UI.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now verify this by going into the device's Settings.\n\n    ![img](images/MxSettingsManagerTutorialImages/device_settings.bmp)\n\n\t![img](images/MxSettingsManagerTutorialImages/reset_disabled.bmp)\n\n\tYou can see that the Enterprise Reset option is disabled from settings UI.\n\nThis is how Settings Manager is used to configure Enterprise Reset option in Settings UI of your Symbol device using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure Settings UI with Enterprise Reset option using Settings Manager on your Symbol Android devices through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"USB Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxSettingsManagerTutorial.zip)"},{"key":"guide-tutorial-tutMxTouchManager","name":" Specify Touch Mode using Mx Touch Manager","md":"# Specify Touch Mode using Mx Touch Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on configuring touch mode of your Symbol Android device using [Touch Manager](#guide-profiles-touch) feature of Mx. \n\nSo now we will create a tutorial and configure the touch of your Symbol Android device by specifying touch mode using Mx [Touch Manager](#guide-profiles-touch) feature. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxTouchManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The Touch Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"TouchManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.   \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Touch Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxTouchManagerTutorialImages/touch_feature.jpg)\n\n    Provide some name in the \"Name\" field (Ex. MyTouchManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    The drop-down \"Touch Action\" provides different modes that you can choose to set the Touch of your Symbol Android device. You can select \"Stylus and Finger\", \"Glove and Finger\" or keep the existing setting. We will select \"Glove and Finger\" option as the Touch Mode. \n\n    > Note: So if we select \"Glove and Finger\" option, we will not be able to use stylus to interact with the device.     \n\n    ![img](images/MxTouchManagerTutorialImages/touch_manager_details.jpg)\n\n    ![img](images/MxTouchManagerTutorialImages/touch_manager_details_selected.jpg)    \n \n4. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxTouchManagerTutorialImages/touch_profile_created.jpg)\n\n5. Click Finish and your Touch Manager profile for specifying touch mode is created.\n\n    ![img](images/MxTouchManagerTutorialImages/touch_manager_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" created under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxTouchManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxTouchManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxTouchManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"TouchManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n        // Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxTouchManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxTouchManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxTouchManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxTouchManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxTouchManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxTouchManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxTouchManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us set the touch mode to \"Glove and Finger\" on our Symbol Android device. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We will see the existing touch mode on the Symbol Android device. \n\n    Go to device's Settings -> Display -> Touch Mode.\n\n    You can see the default Touch Mode is \"Stylus and Finger\", which we will now change to \"Glove and Finger\" using Touch Manager feature of Mx. \n\n    ![img](images/MxTouchManagerTutorialImages/touch_mode.png) \n\n2. Run the application.\n\n    ![img](images/MxTouchManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message, which implies that the Touch Mode has been successfully set to \"Glove and Finger\".\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now verify this by going into the device's Settings -> Display -> Touch Mode.\n\n    ![img](images/MxTouchManagerTutorialImages/touch_mode_changed.png)\n\n    This is how Touch Manager is used to set the Touch Mode of your Symbol Android device using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure Touch Mode using Touch Manager on your Symbol Android devices through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"Settings Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxTouchManagerTutorial.zip)"},{"key":"guide-tutorial-tutMxUIManager","name":" Configure Clipboard using Mx UI Manager","md":"# Configure Clipboard using Mx UI Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on configuring Clipboard of your Symbol Android device using [UI Manager](#guide-profiles-ui) feature of Mx. \n\nSo now we will create a tutorial and configure the Clipboard (Enable/Disable and clear Clipboard) of your Symbol Android device using Mx [UI Manager](#guide-profiles-ui) feature. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxUIManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The UI Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"UIManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"UI Manager\" feature from the list and click \"Right Arrow\".\n\n\t![img](images/MxUIManagerTutorialImages/new_features_4.3.jpg)\n\n    Provide some name in the \"Name\" field (Ex. MyUIManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    So as discussed, you can enable, disable or clear the clipboard of your Symbol device using UI Manager feature of Mx. We will enable and clear the clipboard so that when we run the application, there is nothing saved in clipboard. Click on Clipboard drop-down in the wizard and select the option \"Enable\". Check the \"Clear Clipboard?\" checkbox to enable clearing. \n\n\tYou can also see some additional sub-features under \"UI Manager\" such as Enabling/Disabling AutoCorrect, HomeKey, Bluetooth Pairing Popup, setting current locale, default input method etc which could be configured as well.    \n\n    ![img](images/MxUIManagerTutorialImages/ui_manager_details.jpg)\n\n    ![img](images/MxUIManagerTutorialImages/ui_manager_details_selected.jpg)    \n \n4. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxUIManagerTutorialImages/ui_profile_created.jpg)\n\n5. Click Finish and your Wireless profile for configuring Bluetooth is created.\n\n    ![img](images/MxUIManagerTutorialImages/ui_manager_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" created under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxUIManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxUIManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxUIManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"UIManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxUIManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxUIManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxUIManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxUIManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxUIManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxUIManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxUIManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us enable the Clipboard first and then clear it of our Symbol Android device. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We will make sure that something is copied on the Clipboard before clearing it up. \n\n    Go to device's Messages and copy any text on the clipboard.\n\n    ![img](images/MxUIManagerTutorialImages/copy_text_to_clipboard.png) \n\n2. Run the application.\n\n    ![img](images/MxUIManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message. It means the Clipboard has been enabled and cleared.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now verify this by opening messages. Clear the existing message, long click on Edit Text and press the paste button.\n\n    Since the Clipboard has been cleared using UI Manager, it will not paste anything. \n\n    ![img](images/MxUIManagerTutorialImages/paste_data.png)\n\n    ![img](images/MxUIManagerTutorialImages/no_data.png)\n\n    This is how UI Manager lets us enable, disable and clear Clipboard of the Symbol Android device using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure Clipboard using Wireless Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"Touch Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxUIManagerTutorial.zip)"},{"key":"guide-tutorial-tutMxUSBManager","name":" Manage USB Configurations","md":"# Manage USB Configurations\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on managing USB configurations on your Symbol Android device using [USB Manager](#guide-profiles-usb) feature of Mx.\n \nSo now we will create a tutorial and configure (Enable/Disable) the [ADB](http://developer.android.com/tools/help/adb.html) mode of the Symbol Android device using Mx [USB Manager](#guide-profiles-usb) feature. ADB mode allows you to communicate with an emulator instance or connected Android-powered device in order to run your Android applications on them.   \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxUSBManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The USB Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"USBManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n    \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"USB Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxUSBManagerTutorialImages/usb_feature.jpg)\n\n    Provide some name in the \"Name\" field (Ex. MyUSBManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    You can see number of options for configuring different USB settings. Some of them are dependent on each other. We can configure every option in the profile editor window for USB Manager. As mentioned above we will configure the ADB mode (USB Debugging Mode) in this tutorial. Since we want to run our application on Symbol device, the ADB mode (USB Debugging Mode) is ON. So let us configure \"USB ADB Usage\" option. If you disable this option, you will not be able to run any Android application on the device as there will not be any communication between your machine and device. If you enable this option, the USB degugger will be turned ON and you can run your application on device again. So as of now we will keep \"USB ADB Usage\" option to \"Do not change\", which will keep the existing settings (In our case it is already ON). We will configure it programmatically by providing options (Enable/Disable) to the user on User Interface in coming steps.   \n\n    > Note: If this option is disabled through Profile Wizard, you cannot enable this option manually by going into settings unless performed Factory Reset on it. So configure this feature programmatically to enable and disable ADB USB Usage in your application.      \n\n    ![img](images/MxUSBManagerTutorialImages/usb_manager_details.jpg)\n\n    ![img](images/MxUSBManagerTutorialImages/usb_manager_details_selected.jpg)    \n \n4. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxUSBManagerTutorialImages/usb_profile_created.jpg)\n\n5. Click Finish and your USB Manager profile for configuring USB options is created.\n\n    ![img](images/MxUSBManagerTutorialImages/usb_manager_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" created under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxUSBManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxUSBManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:   \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxUSBManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager ProfileManager with a status variable while applying the profile. It contains [RadioGroup](http://developer.android.com/reference/android/widget/RadioGroup.html) to hold [Radio Buttons](http://developer.android.com/guide/topics/ui/controls/radiobutton.html), which allow user to select option to Enable or Disable ADB USB Usage. It also has a variable that contains user selected [Radio Button](http://developer.android.com/guide/topics/ui/controls/radiobutton.html) value for further processing. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"USBManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\t\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\t\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\t\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n\tDeclaration of global variables look like:\n\n\t![img](images/MxUSBManagerTutorialImages/global_variables.jpg)\n\n2. Let us add the required User Interface for this tutorial that will have two [Radio Buttons](http://developer.android.com/guide/topics/ui/controls/radiobutton.html) to Enable and Disable ADB USB Usage. The User Interface will also have a [Button](http://developer.android.com/reference/android/widget/Button.html) to apply changes selected by the user. \n\nSo go inside \"res/layout/activity_main.xml\" of the project and remove all the code. Add following code for the desired User Interface.\n  \n\t\t  \t\t\n\t:::xml\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    tools:context=\"${relativePackage}.${activityClass}\" >\n\t\n\t    <TextView\n\t        android:id=\"@+id/textView1\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_above=\"@+id/radioGroupADB\"\n\t        android:layout_margin=\"15dip\"\n\t        android:layout_marginBottom=\"20dp\"\n\t        android:text=\"Select your USB ADB Usage Option:\"\n\t        android:textSize=\"16sp\"\n\t        android:textStyle=\"bold\" />\n\t\n\t    <RadioGroup\n\t        android:id=\"@+id/radioGroupADB\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_centerInParent=\"true\" >\n\t\n\t        <RadioButton\n\t            android:id=\"@+id/radioEnableADB\"\n\t            android:layout_width=\"279dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:text=\"Enable USB ADB Usage\" />\n\t\n\t        <RadioButton\n\t            android:id=\"@+id/radioDisableADB\"\n\t            android:layout_width=\"match_parent\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:text=\"Disable USB ADB Usage\" />\n\t    </RadioGroup>\n\t\n\t    <Button\n\t        android:id=\"@+id/buttonSet\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_below=\"@+id/radioGroupADB\"\n\t        android:layout_centerHorizontal=\"true\"\n\t        android:layout_marginTop=\"20dip\"\n\t        android:text=\"Set\" />\n\t\n\t</RelativeLayout>\n\nThe layout file 'activity_main.xml' should now look like:\n\n![img](images/MxUSBManagerTutorialImages/activity_main_1.jpg)\n\nhere is the remaining part:\n\n![img](images/MxUSBManagerTutorialImages/activity_main_2.jpg)   \n\t\n3. Now come back to \"MainActivity.java\". In  `onCreate` method, we will get the references for UI element that we created in previous step followed by the listener for \"Set\" button. We will then call `getEMDKManager` so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        // Add reference to UI elements\n\t\tadbRadioGroup = (RadioGroup) findViewById(R.id.radioGroupADB);\n\n\t\t// Call the listener for Set Button to update user selected settings\n\t\taddSetButtonListener();\n\n\t\t// The EMDKManager object will be created and returned in the callback.\n\t\tEMDKResults results = EMDKManager.getEMDKManager(\n\t\t\t\tgetApplicationContext(), this);\n\n\t\t// Check the return status of getEMDKManager\n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n    The `onCreate` method should look like:\n     \n     ![img](images/MxUSBManagerTutorialImages/on_create_added.jpg)\n\n4. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);\n\n\tYour complete `onOpened` method should now look like:\n    \n    ![img](images/MxUSBManagerTutorialImages/on_opened_method.jpg) \n\n5. It displays an error as we have not added the listener method for \"Set\" button. So let us add `addSetButtonListener` by using following code:\n\n\t\t:::java\n\t\t// Set Button On Click Listener\n\t\t\tprivate void addSetButtonListener() {\n\t\t\t\tButton setButton = (Button) findViewById(R.id.buttonSet);\n\t\t\t\tsetButton.setOnClickListener(new OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View arg0) {\n\t\t\n\t\t\t\t\t\tint radioid = adbRadioGroup.getCheckedRadioButtonId();\n\t\t\n\t\t\t\t\t\tif (radioid == R.id.radioEnableADB)\n\t\t\t\t\t\t\tvalue = 1; // 1 - Enable USB ADB Usage\n\t\t\n\t\t\t\t\t\tif (radioid == R.id.radioDisableADB)\n\t\t\t\t\t\t\tvalue = 2; // 2 - Disable USB ADB Usage\n\t\t\n\t\t\t\t\t\tupdateUSBSettings();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\tThe code sets variable `value` based on the [Radio Button](http://developer.android.com/guide/topics/ui/controls/radiobutton.html) option selected by the user. This variable will be used to update the profile settings.\n\n\t`value` = 1 -> Enable USB ADB Usage\n\n\t`value` = 2 -> Disable USB ADB Usage\n\n\tThe `addSetButtonListener` method should look like:\n     \n    ![img](images/MxUSBManagerTutorialImages/add_set_button_listener.jpg)\n\n6. Let us declare the `updateUSBSettings` method that will enable or disable ADB USB based on `value` attribute that gets updated depending on user selected option from Radio Button. This method prepares the xml input for the `processProfile` method based on `value` attribute.\n\n\tThis `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method. So the method `updateUSBSettings` has following code.\n\n\t\t:::java\n\t\t// Updates ADB USB settings by setting the profile based on user selected\n\t\t// option on UI\n\t\tpublic void updateUSBSettings() {\n\t\t\t// Reset values\n\t\t\terrorName = \"\";\n\t\t\terrorType = \"\";\n\t\t\terrorDescription = \"\";\n\t\t\tstatus = \"\";\n\t\t\n\t\t\ttry {\n\t\t\n\t\t\t// Prepare XML to update the existing profile based on user selected\n\t\t\t// settings\n\t\t\tString[] modifyData = new String[1];\n\t\t\tmodifyData[0] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t\t\t\t\t\t\t+ \"<characteristic type=\\\"Profile\\\">\"\n\t\t\t\t\t\t\t+ \"<parm name=\\\"ProfileName\\\" value=\\\"USBManagerProfile\\\"/>\"\n\t\t\t\t\t\t\t+ \"<characteristic type=\\\"UsbMgr\\\">\"\n\t\t\t\t\t\t\t+ \"<parm name=\\\"UsbADBUsage\\\" value=\\\"\" + value + \"\\\"/>\"\n\t\t\t\t\t\t\t+ \"</characteristic>\" + \"</characteristic>\";\n\t\t\n\t\t\t// Call processPrfoile with profile name and SET flag to create\n\t\t\t// the\n\t\t\t// profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\t\t\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\t\t\n\t\t\t// Get XML response as a String\n\t\t\tString statusXMLResponse = results.getStatusString();\n\t\t\n\t\t\ttry {\n\t\t\t  // Create instance of XML Pull Parser to parse the\n\t\t\t  // response\n\t\t\t  XmlPullParser parser = Xml.newPullParser();\n\t\t\t  // Provide the string response to the String Reader that\n\t\t\t  // reads\n\t\t\t  // for the parser\n\t\t\t  parser.setInput(new StringReader(statusXMLResponse));\n\t\t\t  // Call method to parse the response\n\t\t\t  parseXML(parser);\n\t\t\t  } catch (XmlPullParserException e) {\n\t\t\t    e.printStackTrace();\n\t\t\t  }\n\t\t\n\t\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\t\t// Method call to display success results in a dialog\n\t\t\t\tdisplayResults(\"Success\", \"Profile Successfully Applied...\");\n\t\t\t  } else {\n\t\t\t    // Method call to display failure results in a dialog\n\t\t\t\t\t\t\tdisplayResults(status, buildFailureMessage());\n\t\t\t  }\n\t\t\n\t\t\t  } else {\n\t\t\t\t// Method call to display failure results in a dialog\n\t\t\t\tdisplayResults(\"Failure\", \"Failed to apply profile...\");\n\t\t\t  }\n\t\t\t} catch (Exception ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t}\n\n\tThe `updateUSBSettings` method should look like:\n     \n    ![img](images/MxUSBManagerTutorialImages/update_usb_settings_1.jpg)\n\n\tand the remaining part of this method looks like:\t\n\n\t![img](images/MxUSBManagerTutorialImages/update_usb_settings_2.jpg)\n\n7. It displays few errors as we have not declared them. So let us declare them one by one. Once the response is received in string, we will call `parseXML` method to parse it and eventually call `displayResults` method to display output in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The `parseXML` method uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors. \n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\t\tint event;\n\t\t\ttry {\n\t\t\t\tevent = myParser.getEventType();\n\t\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\t\tString name = myParser.getName();\n\t\t\t\t\tswitch (event) {\n\t\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\t\"desc\");\n\t\n\t\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t\t// parm-error\n\t\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlPullParser.END_TAG:\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tevent = myParser.next();\n\t\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\tYour complete `parseXML` method should now look like:\n    \n    ![img](images/MxUSBManagerTutorialImages/parse_xml.jpg)\n\n8. Once the response is parsed, we prepare status and error detail messages to handle errors using `buildFailureMessage` method. , in order to display to the user. \n\n\tIn this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxUSBManagerTutorialImages/build_failure_message.jpg)\n\n9. You will still see few errors as we have not yet declared `displayResults` method. So we now declare this generic method that takes two string arguments viz. `title` and `description` and displays them in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) so that the user understands the status of its ADB USB operation. The field `title` represents the status of Profile Manager operation, which could be Success or Failure. The field `description` describes the respective status.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description if any) in a\n\t\t// dialog\n\t\tpublic void displayResults(String title, String description) {\n\t\t\t// Alert Dialog to display the status of the Profile creation\n\t\t\t// operation of MX features\n\t\t\tAlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\t\tMainActivity.this);\n\t\n\t\t\talertDialogBuilder.setTitle(title);\n\t\t\talertDialogBuilder.setMessage(description);\n\t\t\talertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t\t\t// Cancels the dialog\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t// create alert dialog\n\t\t\tAlertDialog alertDialog = alertDialogBuilder.create();\n\t\t\t// show it\n\t\t\talertDialog.show();\n\t\t}\n\n\tThe method `displayResults` method looks like:\n    \n    ![img](images/MxUSBManagerTutorialImages/display_results.jpg)  \n       \n\tYou can see that all the errors are gone.  \n    \n10. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxUSBManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us configure (Enable/Disable) the USB ADB Usage on Symbol Android device. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, we will make sure that USB ADB mode is ON so that we can run this tutorial. So go to Settings -> Developer Options. Make sure that \"USB debugging\" (ADB Mode) option is ON.\n\n    ![img](images/MxUSBManagerTutorialImages/adb_mode_on.png)\n\n2. Run the application.\n\n    ![img](images/MxUSBManagerTutorialImages/home_screen.png)\n\n3. Now select your USB ADB option (We will select \"Disable\") and press \"Set\" button. \n\n\tYou can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message, which indicates that the app has successfully disabled USB ADB Mode.\n\n\t![img](images/MxUSBManagerTutorialImages/success.png)\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n\n3. In other words, the USB debugging option on your Symbol device is turned OFF and you will not be able to run any Android application on this Symbol device. \n\n    ![img](images/MxUSBManagerTutorialImages/adb_mode_off.png)\n\n\tYou can select the enable option and press \"Set\" button to turn USB ADB Usage ON.\n\n\tThis is how USB Manager is used to configure USB ADB Mode on your Symbol Android device using Profile Wizard. \n    \n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to Manage USB configurations using USB Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"XML Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxUSBManagerTutorial.zip)"},{"key":"guide-tutorial-tutMxWiFiManager","name":" Configure Wi-Fi settings and Network Profiles using Mx Wi-Fi:","md":"# Configure Wi-Fi settings and Network Profiles using Mx Wi-Fi:\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on [Wi-Fi Manager](#guide-profiles-wifi) API, which allows you to manage your device's Wi-Fi settings as well as manage the network profiles to be used for connecting and remembering networks. Overall, Wi-Fi Manager supports following features:\n\n* **[Wi-Fi Enable/Disable](https://developer.motorolasolutions.com/docs/DOC-2290#wifi-enable)**\n* **[Country Selection Auto/Manual](https://developer.motorolasolutions.com/docs/DOC-2290#country-selection-automanual)**\n* **[Country to use for Wi-Fi regulatory setting](https://developer.motorolasolutions.com/docs/DOC-2290#country)**\n* **[RF Bands to use](https://developer.motorolasolutions.com/docs/DOC-2290#rf-band)**\n* **[Wi-Fi Channels](https://developer.motorolasolutions.com/docs/DOC-2290#wifi-channel)**\n* **[Wi-Fi Sleep Policy](https://developer.motorolasolutions.com/docs/DOC-2290#sleep-policy)**\n* **[Network Notification](https://developer.motorolasolutions.com/docs/DOC-2290#network-notification)**\n* **[Network Action](https://developer.motorolasolutions.com/docs/DOC-2290#network-action)**\n* **[Wi-Fi Profiles](https://developer.motorolasolutions.com/docs/DOC-2290#wifi-profiles)**\n* **[Encryption Details](https://developer.motorolasolutions.com/docs/DOC-2290#encryption-details)**\n* **[Authentication Details](https://developer.motorolasolutions.com/docs/DOC-2290#authentication-details)**\n* **[Advanced Options](https://developer.motorolasolutions.com/docs/DOC-2290#advanced-options)**\n\n\n> Note: In order to apply these settings, Wi-Fi must be enabled. If you do not specify Wi-Fi Enable in the profile you will get an error when attempting to apply other settings if the device's Wi-Fi is not already enabled.\n\n \nAll of the above features can be configured the way you want through EMDK Profile Wizard as well as programmatically using Wi-Fi Manager API. In this tutorial, We would be implementing some of the these features through EMDK Wizard.\n\n> Note: In this tutorial, we will be implementing everything through EMDK Wizard. Programmatic change using API is not in the scope of this tutorial.\n\nThe tutorial will be designed to configure Wi-Fi settings with following features and the sequence:\n\n* Enable Wi-Fi\n* Add Network \n* Connect to an existing network\n* Disconnect from an existing network\n* Remove an existing Network\n   \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 2.1 and above\n* Wi-Fi of your Symbol Android device must be enabled.\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"WiFiManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The Wi-Fi Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"WiFiProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n   \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Wi-Fi\" feature from the list and click \"Right Arrow\". Using this feature you can manage your device's Wi-Fi settings as well as the network profiles to be used for connecting and remembering networks as explained earlier.\n  \n\tClick on the Wi-Fi feature. The parameter list will be populated.  \n  \n    ![img](images/MxWiFiManagerTutorialImages/select_wifi_feature.jpg)\n\n4. You can see various settings of Wi-Fi feature in the wizard as mentioned initially. You can configure all these settings the way you want in the wizard as well as programmatically.\n\n    Provide some name in the \"Name\" field (Ex. MyWiFi). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n    \n    So lets start implementing the settings one by one as mentioned earlier. Currently, the Wi-Fi of the device is disabled. Before configuring any settings, we must enable the Wi-Fi first. So we will start with the first step by enabling Wi-Fi. Select Wi-Fi Enable drop-down and click \"Enable\" option. This will enable your device's Wi-Fi.  \n\n    ![img](images/MxWiFiManagerTutorialImages/wifi_enable_dropdown.jpg)\n\n    ![img](images/MxWiFiManagerTutorialImages/wifi_enabled.jpg)\n    \n5. Now we will add a new Wi-Fi network. In order to do that, select \"Network Action\" drop-down in the \"Manage Wi-Fi Radio-Specific Settings\" section. This drop-down will display various network operations that could be performed on your device's Wi-Fi.\n\n    > Note: Keep other settings unchanged. Although you can configure any settings if you wish to.\n\n    ![img](images/MxWiFiManagerTutorialImages/network_action_dropdown.jpg)\n\n    Click on \"Add a New Network\" option and it will show configurable settings related to this option.  \n\n    ![img](images/MxWiFiManagerTutorialImages/add_new_network.jpg)\n    \n6. You can select different types of \"Security Mode\" (Open, Personal, Enterprise) and configure settings associated with each type. For this tutorial, we will keep the \"Security Mode\" as \"Personal\".  \n  \n    ![img](images/MxWiFiManagerTutorialImages/personal_network.jpg)\n\n    Now enter the details for the fields provided. Provide SSID as \"rholink-ap\". Select \"WPA Mode\" as WPA. Enter the passphrase, which is the password for authentication on your network. Check the \"Protect Key?\" checkbox so that the passphrase is protected. Keep the other settings unchanged. \n\n    > Note: The configurations may very depending on the network you add.\n\n    ![img](images/MxWiFiManagerTutorialImages/personal_network_details_added.jpg)  \n  \n7.  Click Apply and Finish. \n\n    ![img](images/MxWiFiManagerTutorialImages/wifi_profile_created.jpg)  \n\n8. Click \"Close\".   \n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n9. You can inspect the \"EMDKConfig.xml\" created under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager. So you can see the entry of all elements in EMDKConfig.xml file that we configured.\n\n    ![img](images/MxWiFiManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxWiFiManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxWiFiManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. We will also create global variables to hold the UI elements and values that are required in this application. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"WiFiProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxWiFiManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tstatusTextView.setText(\"EMDK open success.\");\n\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxWiFiManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxWiFiManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the reponse, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxWiFiManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxWiFiManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxWiFiManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxWiFiManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will allow us to Enable the Wi-Fi and add a network specified in the EMDK Profile Wizard.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n2. Before running the application, We will make sure that Wi-Fi is disabled. Go to \"Settings\" and disable the Wi-Fi by toggling the status. \n  \n\t![img](images/MxWiFiManagerTutorialImages/disable_wifi.png)\n  \n4. Run the application. If the configurations in the wizard are successfully applied, the app will display a success [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html).\n\n    ![img](images/MxWiFiManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) displayed with a success message. It means it enabled the Wi-Fi and added a network named \"rholink-ap\" that we had configured in the wizard earlier in this tutorial.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n\n    To verify, go to Settings. You can see the Wi-Fi is enabled now. \n  \n\t![img](images/MxWiFiManagerTutorialImages/wifi_on.png)\n\n    Tap on Wi-Fi option and you can see that the \"rholink-ap\" network has been successfully added in the list of available networks. The lock icon near Wi-Fi image indicates that it is a secured password protected network.\n\n    ![img](images/MxWiFiManagerTutorialImages/rho_link_added.png)\n\n    > Note: This setting has just added a new network. We are not yet connected to this new network that we added.  \n\n5. Now we will connect to an existing Wi-Fi network. You can connect to any of the existing Wi-Fi network but we will connect to the one we just added (rholink-ap). So open the profile manager by selecting our project just like we did earlier for adding a network. \n \n\t![img](images/MxWiFiManagerTutorialImages/wifi_profile_created.jpg)\n\n    Click on \"Edit\" button and it will display profile editor window to edit previous configurations.\n\n    ![img](images/MxWiFiManagerTutorialImages/edit_profile.jpg)\n\n    Choose \"Network Action\" as \"Connect to an Existing Network\" from the drop-down.\n\n    ![img](images/MxWiFiManagerTutorialImages/connect_existing_network.jpg)\n\n    Enter SSID of the network you want to connect to. In this tutorial we will connect to network with SSID \"rholink-ap\" that we created earlier.\n \n    ![img](images/MxWiFiManagerTutorialImages/ssid_provided.jpg)\n\n    Click Apply, Finish and Close to save the configurations.  \n\n6. Run the application again.\n\n    ![img](images/MxWiFiManagerTutorialImages/home_screen.png)\n\n    The app displayed a success message. So to verify, go to Settings -> Wi-Fi. You can see that Wi-Fi is successfully connected to the network with SSID \"rholink-ap\", which we provided in the wizard.\n   \n    ![img](images/MxWiFiManagerTutorialImages/wifi_connected.png)\n\n7. We will now disconnect the Wi-Fi from an existing network through wizard. Go to Profile Manager and click Edit button just like we did in previous operations.\n\n    This time select the \"Network Action\" as \"Disconnect from an Existing Network\". Enter the SSID of the network you wish to disconnect from. In this tutorial we will enter the SSID as \"rholink-ap\" to which we are currently connected.\n\n    ![img](images/MxWiFiManagerTutorialImages/disconnect_from_network.jpg)\n\n    Click Apply, Finish and Close.\n\n8. Run the application. \n\n    ![img](images/MxWiFiManagerTutorialImages/home_screen.png)\n\n    The success [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html) indicates that the operation was successful.\n\n    Let us verify that. Go to Settings -> Wi-Fi and you will see that the device has successfully disconnected from the network \"rholink-ap\".\n\n    ![img](images/MxWiFiManagerTutorialImages/disconnected_from_network.png)\n\n9. Finally, we will remove an existing network through the EMDK Profile wizard. So again go to Profile Manager and click on \"Edit\" button. Select \"Network Action\" as \"Remove an Existing Network\". This time we will provide some other SSID just for variation. \n\n    ![img](images/MxWiFiManagerTutorialImages/ssid_to_remove.png)\n\n    In the above screen, you can see a network with SSID \"Deven\". Let us remove this network from the list by providing SSID \"Deven\" in the wizard.\n\n    ![img](images/MxWiFiManagerTutorialImages/remove_existing_network.jpg)\n\n    Click Apply, Finish and Close.\n\n10. Run the application. \n\n    ![img](images/MxWiFiManagerTutorialImages/home_screen.png)\n\n    The success message indicates that the network was removed successfully. So go to Settings -> Wi-Fi and you will not see the network with SSID \"Deven\" in the list of available networks.\n\n    ![img](images/MxWiFiManagerTutorialImages/network_removed.png)\n\n    > Note: If the network is within the range then it might appear again in the list as device scans periodically.\n\n    So these are some of the configurations we implemented using Wi-Fi Manager feature of Mx. You can try any configurations and manage your device's Wi-Fi settings as well as network profiles.\n\n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure your device's Wi-Fi settings as well as network profiles on your Symbol Android devices through applications using Mx Wi-Fi feature, let us try to understand and implement some of the other Mx features. So in the next tutorial, we will concentrate on the \"Certificate Manager\" feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/WiFiManagerTutorial.zip)."},{"key":"guide-tutorial-tutMxWirelessManager","name":" Configure Bluetooth using Mx Wireless Manager","md":"# Configure Bluetooth using Mx Wireless Manager\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on configuring wireless configurations on your Symbol Android device (Ex. Configure device's Bluetooth) using [Wireless Manager](#guide-profiles-wireless) feature of Mx. \n\nSo now we will create a tutorial and configure (Enable/Disable) the Bluetooth of your Symbol Android device using Mx [Wireless Manager](#guide-profiles-wireless) feature. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html)) \n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"MxWirelessManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.  \n\n \n## Adding The Wireless Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"WirelessProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"Wireless Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxWirelessManagerTutorialImages/wireless_feature.jpg)   \n\n4. Provide some name in the \"Name\" field (Ex. MyWirelessManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n\tYou can see some additional sub-features under \"Wireless Manager\" such as turning ON/OFF NFC, GPS, WWAN etc.\n\n    So as discussed, you can configure Bluetooth of your Symbol Android device in Wireless Manager feature of Mx. So we will enable Bluetooth of the device by configuring Wireless Manager through wizard. So click on Bluetooth drop-down in the wizard and select the option \"Enable\".    \n\n    ![img](images/MxWirelessManagerTutorialImages/wireless_manager_details.jpg)\n\n    ![img](images/MxWirelessManagerTutorialImages/wireless_manager_details_selected.jpg)    \n \n5. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxWirelessManagerTutorialImages/wireless_profile_created.jpg)\n\n6. Click Finish and your Wireless profile for configuring Bluetooth is created.\n\n    ![img](images/MxWirelessManagerTutorialImages/wireless_manager_profile_created.jpg) \n  \n7. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n  \n8. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxWirelessManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxWirelessManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxWirelessManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"WirelessProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxWirelessManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it returns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxWirelessManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxWirelessManagerTutorialImages/on_opened_method_2.jpg) \n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxWirelessManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxWirelessManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxWirelessManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.\n           \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxWirelessManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us enable Bluetooth of Symbol Android device. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n\n    Before running the application, We will make sure that Bluetooth of our Android device is disabled. \n\n    Go to device's Settings -> Bluetooth and make sure it is OFF.\n\n    ![img](images/MxWirelessManagerTutorialImages/bluetooth_off.png) \n\n2. Run the application.\n\n    ![img](images/MxWirelessManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now see the status of Bluetooth in the settings. So go to device's Settings and you will now see that Bluetooth is enabled by Wireless Manager that we had set in the profile wizard. \n\n    ![img](images/MxWirelessManagerTutorialImages/bluetooth_on.png)\n\n    This is how Wireless Manager lets us enable Bluetooth of the Symbol Android device using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure Bluetooth using Wireless Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"UI Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/MxWirelessManagerTutorial.zip)"},{"key":"guide-tutorial-tutMxXMLManager","name":" Manage MX Processing Behavior","md":"# Manage MX Processing Behavior\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use some new Mx features introduced in EMDK for Android API to perform device configurations. Mx represents a suite of Enterprise Features on top of standard, commercially available Android Open Source Project. So this tutorial will focus on managing the XML processing by specifying the XML processing mode to use on your Symbol Android device using [XML Manager](#guide-profiles-xml) feature of Mx.\n\nThe XML Manager supports following XML processing Modes:\n\n* Execute all to end\n* Execute until error, then stop\n* Try until error, then Skip to Catch\n* Catch error, Execute remainder\n\nLet us create a tutorial and configure the XML processing mode on your Symbol Android device using Mx [XML Manager](#guide-profiles-xml) feature. \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.0 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"XMLManagerTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API. \n\n## Adding The XML Manager Profile Feature\n1. Click [here](#guide-tutorial-tutAddProfileManagerFeature) to see how to add a specific feature to the Profile Manager.\n\n2. Provide \"XMLManagerProfile\" as the Profile Name for this tutorial.\n\n\t> Note: You can provide any Profile Name but make sure to access it with the similar name in the Android code.  \n  \n3. Now, you can see all these MX features on the left hand side of the Profile Editor window. Select the \"XML Manager\" feature from the list and click \"Right Arrow\".\n\n    ![img](images/MxXMLManagerTutorialImages/xml_feature.jpg)\n\n    Provide some name in the \"Name\" field (Ex. MyXMLManager). The \"Name\" field is used to identify each feature, which is required when editing features programmatically. You can also keep the \"Name\" field empty.\n\n    The drop-down \"XML Processing Mode\" provides different modes of processing XML that you can choose for your Symbol Android device. Select the XML processing mode of your choice. Let us select the first XML processing mode \"Execute all to end\".         \n\n    ![img](images/MxXMLManagerTutorialImages/xml_manager_details.jpg)\n\n    ![img](images/MxXMLManagerTutorialImages/xml_manager_details_selected.jpg)    \n \n4. Click Apply to apply the settings we provided    \n  \n    ![img](images/MxXMLManagerTutorialImages/xml_profile_created.jpg)\n\n5. Click Finish and your XML Manager profile for specifying XML processing mode to use is created.\n\n    ![img](images/MxXMLManagerTutorialImages/xml_manager_profile_created.jpg) \n  \n6. Click \"Close\".\n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n  \n7. You can inspect the \"EMDKConfig.xml\" created under \"\\assets\" folder to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/MxXMLManagerTutorialImages/emdk_config_file_entries.jpg)    \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.\n  \n    ![img](images/MxXMLManagerTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/MxXMLManagerTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n\t\timport android.widget.Toast;    \n\n    Then you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager with a status variable while applying the profile. Some of the variables are used to hold the name, type and description in case of any errors. These variables would be used throughout the code. \n\n    >Note:\n    >Verify the Profile name in the code with the one created in the Profile Manager. They both should be identical.    \n    \n        :::java\n        // Assign the profile name used in EMDKConfig.xml\n\t    private String profileName = \"XMLManagerProfile\";\n\n\t    // Declare a variable to store ProfileManager object\n\t    private ProfileManager profileManager = null;\n\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\n\t\t// Contains the parm-error name (sub-feature that has error)\n\t\tprivate String errorName = \"\";\n\n\t\t// Contains the characteristic-error type (Root feature that has error)\n\t\tprivate String errorType = \"\";\n\n\t\t// contains the error description for parm or characteristic error.\n\t\tprivate String errorDescription = \"\";\n\n\t\t// contains status of the profile operation\n\t\tprivate String status = \"\";\n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// EMDKManager object creation success\n\n\t\t} else {\n\n\t\t\t// EMDKManager object creation failed\n\n\t\t}\n\n\n    So far your code should look like:\n     \n     ![img](images/MxXMLManagerTutorialImages/on_create_added.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. The EMDKListener interface must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n\n    > Note: \n    > Rename the argument of `onOpened` method from `arg0` to `emdkManager`  \n\n        :::java\n        // This callback will be issued when the EMDK is ready to use.\n\t\tthis.emdkManager = emdkManager;\n\n\t\t// Get the ProfileManager object to process the profiles\n\t\tprofileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\n\t\t:::java\n\t\tif (profileManager != null) {\n\t\t\tString[] modifyData = new String[1];\n\n\t\t\t// Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.CHECK_XML) {\n\n\n\t\t\t} else {\n\t\t\t  // Show dialog of Failure\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setTitle(\"Failure\");\n\t\t\t\tbuilder.setMessage(\"Failed to apply profile...\")\n\t\t\t\t\t\t.setPositiveButton(\"OK\",\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t\tpublic void onClick\t\t\t\t\t\t\t\t\t\t\t\t\t(DialogInterface dialog,\n\t\t\t\t\t\t\t\t\t\t\tint id) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\n\t\t}\n\n    This `processProfile` method returns the result of applying a particular profile that we set using EMDK Profile Wizard in [EMDKResults](#api-EMDKResults) reference. If the profile is successfully processed, it reruns the status as `CHECK_XML` and then we go on and parse the response to get further details whether the profile was applied successfully or not. Otherwise we display a Failure message in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html).\n\n\t> Note: 1. There is a difference between processing a profile successfully and applying a profile successfully.\n\n\t> Note: 2. If the status is other than `CHECK_XML`, we are simply displaying a failure message. You can actually go ahead and check different types of status and display the appropriate message accordingly, which is not in the scope of this sample tutorial.\n\n\n\tIn case of `CHECK_XML` status, We retrieve  XML response string from the result using `getStatusString` method.\n\n\t\t:::java\n\t\t// Get XML response as a String\n\t\tString statusXMLResponse = results.getStatusString();\n\n\tFurther, we would parse this XML response string using [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) in order to get the status and error parameters if any. XML Pull Parser is an interface that defines parsing functionality provided in [XMLPULL V1 API](http://www.xmlpull.org/) (visit this website to learn more about API and its implementations). In the parsing we would be looking for specific status tags (Error Name, Error Type and Error Description) in case of any errors and if found, we would get those values in the respective global variables that we have declared in previous step.\n\n\t\t:::java\n\t\ttry {\n\t\t\t// Create instance of XML Pull Parser to parse the response\n\t\t\tXmlPullParser parser = Xml.newPullParser();\n\t\t\t// Provide the string response to the String Reader that reads\n\t\t\t// for the parser\n\t\t\tparser.setInput(new StringReader(statusXMLResponse));\n\t\t\t// Call method to parse the response\n\t\t\tparseXML(parser);\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t> Note: Here we have called the method `parseXML` to parse XML response string. We will declare the method in the next step. \n\n\tOnce the response is parsed, we would display the result of applying this profile in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html) by calling `displayResults` method, which we would declare in coming steps.\n\n\t\t:::java\n\t\t// Method call to display results in a dialog\n\t\tdisplayResults();\n\n    Your complete `onOpened` method should now look like:\n    \n    ![img](images/MxXMLManagerTutorialImages/on_opened_method_1.jpg) \n\n    ![img](images/MxXMLManagerTutorialImages/on_opened_method_2.jpg)\n\n3. You will see few errors as we have not declared the respective methods to parse the response and display result. Lets do it one by one. In this step, we will create a method `parseXML` that uses [XML Pull Parser](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html) to parse the XML string response and set the status and error parameters if any.\n\n\tIn the response, we are supposed to capture `name` and `desc` for `parm-error` tag, `type` and `desc` for `characteristic-error` tag in case of any errors.\n\n\t\t:::java\n\t\t// Method to parse the XML response using XML Pull Parser\n\t\tpublic void parseXML(XmlPullParser myParser) {\n\t\tint event;\n\t\ttry {\n\t\t\tevent = myParser.getEventType();\n\t\t\twhile (event != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tString name = myParser.getName();\n\t\t\t\tswitch (event) {\n\t\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\t\t// Get Status, error name and description in case of\n\t\t\t\t\t// parm-error\n\t\t\t\t\tif (name.equals(\"parm-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorName = myParser.getAttributeValue(null, \"name\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\n\t\t\t\t\t\t// Get Status, error type and description in case of\n\t\t\t\t\t\t// parm-error\n\t\t\t\t\t} else if (name.equals(\"characteristic-error\")) {\n\t\t\t\t\t\tstatus = \"Failure\";\n\t\t\t\t\t\terrorType = myParser.getAttributeValue(null, \"type\");\n\t\t\t\t\t\terrorDescription = myParser.getAttributeValue(null,\n\t\t\t\t\t\t\t\t\"desc\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase XmlPullParser.END_TAG:\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = myParser.next();\n\n\t\t\t  }\n\t\t    } catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t    }\n\t\t}\n\n    Your complete `parseXML` method should now look like:\n    \n    ![img](images/MxXMLManagerTutorialImages/parse_xml.jpg) \n\n4. You will still see one error as we need to declare `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). Before displaying the results, we should form the content of the result to be shown first, specifically in case of errors. This could be done by creating `buildFailureMessage` method.\n \n    In this method, the error message in case of error is formed using following way: \n\n    * Name and description of error if the response contains `parm-error`.\n    * Type and description of error if the response contains `characteristic-error`.\n    * Name, type and description of error if the response contains both `parm-error` and `characteristic-error`.\n\n\tThe `buildFailureMessage` method would have following code to match the above mentioned criteria.  \n\n\t\t:::java\n\t\t// Method to build failure message that contains name, type and\n\t\t// description of respective error (parm, characteristic or both)\n\t\tpublic String buildFailureMessage() {\n\t\t  String failureMessage = \"\";\n\t\t  if (!TextUtils.isEmpty(errorName) && !TextUtils.isEmpty(errorType))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorType + \" :\" + \"\\n\"\n\t\t\t\t\t+ errorDescription;\n\t\t  else if (!TextUtils.isEmpty(errorName))\n\t\t\t failureMessage = errorName + \" :\" + \"\\n\" + errorDescription;\n\t\t  else\n\t\t\t failureMessage = errorType + \" :\" + \"\\n\" + errorDescription;\n\t\t  return failureMessage;\n\n\t\t}\n\n    `buildFailureMessage` method should look like:\n    \n    ![img](images/MxXMLManagerTutorialImages/build_failure_message.jpg)\n\n5. In this step, we will add `displayResults` method to display the result of profile operation in a [dialog](http://developer.android.com/reference/android/app/AlertDialog.html). The dialog would display status as `Success` or `Failure` with corresponding message based on the response of profile operation.\n\n\t\t:::java\n\t\t// Method to display results (Status, Error Name, Error Type, Error\n\t\t// Description) in a\n\t\t// dialog\n\t\tpublic void displayResults() {\n\t\t  // Alert Dialog to display the status of the Profile creation\n\t\t  // operation of MX features\n\t\t  AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(\n\t\t\t\tMainActivity.this);\n\n\t\t  if (TextUtils.isEmpty(errorDescription)) {\n\t\t\talertDialogBuilder.setTitle(\"Success\");\n\t\t\talertDialogBuilder.setMessage(\"Profile Successfully Applied...\");\n\t\t  } else {\n\t\t\t// set title\n\t\t\talertDialogBuilder.setTitle(status);\n\t\t\t// call buildFailureMessage() method to set failure message in\n\t\t\t// dialog\n\t\t\talertDialogBuilder.setMessage(buildFailureMessage());\n\t\t  }\n\n\t\t  alertDialogBuilder.setCancelable(false).setPositiveButton(\"OK\",\n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t  // create alert dialog\n\t\t  AlertDialog alertDialog = alertDialogBuilder.create();\n\n\t\t  // show it\n\t\t  alertDialog.show();\n\n\t    }  \n\n    The method `displayResults` should look like:\n    \n    ![img](images/MxXMLManagerTutorialImages/display_results.jpg)\n\n\tYou can see that all the errors are gone.  \n    \n6. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/MxXMLManagerTutorialImages/on_destroy_method.jpg) \n\nThat's it!!! We are done with all the coding and configuration part that will let us configure XML processing mode on our Symbol Android device. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having the latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug. \n\n2. Run the application.\n\n    ![img](images/MxXMLManagerTutorialImages/home_screen.png)\n\n    You can see an [Alert Dialog](http://developer.android.com/reference/android/app/AlertDialog.html) with a success message, which implies that the XML processing mode has been applied successfully.\n\n\t> Note: In case of any errors, you will see a Failure status with respective error message in that dialog.\n  \n3. We will now verify this by going into the device's Settings -> Display -> Touch Mode.\n\n    ![img](images/MxXMLManagerTutorialImages/touch_mode_changed.png)\n\n    This is how XML Manager is used to specify XML processing mode on your Symbol Android device using Profile Wizard. \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned how to configure XML Processing Mode using XML Manager on your Symbol devices through applications, let us try to understand and implement some of the other new Mx features introduced in V 3.0. So in the next tutorial, we will concentrate on the \"Wireless Manager\" Mx feature and try to explore this feature by creating a tutorial.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/XMLManagerTutorial.zip)"},{"key":"guide-tutorial-tutScanAndPairAPI","name":" Pairing Remote Device by Scanning its Bluetooth Name or Address using ScanAndPair APIs","md":"# Pairing Remote Device by Scanning its Bluetooth Name or Address using ScanAndPair APIs\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use [ScanAndPair APIs](#guide-reference-EMDKList?ScanAndPair%20APIs) introduced in EMDK V 3.1, to perform pairing of any remote Scanning device by Scanning its Bluetooth Name or Bluetooth Address. The API uses [Scan and Pair Manager](#api-ScanAndPairManager), which is the primary object that allows pairing with remote scanning devices.\n\nIn this tutorial, we will explore the [ScanAndPair APIs](#guide-reference-EMDKList?ScanAndPair%20APIs) by using it for developing a basic application that will scan Bluetooth Name/Address of a Remote Scanning device (Ex. [MC40](https://www.zebra.com/content/dam/msi-new/assets/web/Business/Products/Mobile%20Computers/Handheld%20Computers/MC40/_Documents/Static_Files/MC40_Specifications.pdf)) and pair itself with this device through bluetooth name or address scanned by discovering it.\n\n> Note: The [ScanAndPair API](#guide-reference-EMDKList?ScanAndPair%20APIs) does not use Profile Wizard to scan and pair remote device and everything needs to be configured programmatically through code.   \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.1 and above \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n\n> Note: Provide \"ScanAndPairTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK to scan the barcodes.\n  \n    ![img](images/ScanAndPairTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\" /> \n\n    Then you must enable the library for EMDK:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/ScanAndPairTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.EMDKManager;\n\t\timport com.symbol.emdk.scanandpair.ScanAndPairManager;\n\t\timport com.symbol.emdk.scanandpair.StatusData;  \n\n    Then you must make the activity to implement [EMDKListener](#api-EMDKManager-EMDKListener). Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.\n\n    After that you also need to implement [ScanAndPairManager.StatusListener](#api-ScanAndPairManager-StatusListener), which is an interface for informing client applications to notify Scan and Pair or Scan and Unpair events. Override its `onStatus` function. The `onStatus` is a callback method that would be called when a scan and pair or unpair status event occurs. \n\n\t> Note: If you are using Android Studio, press CTRL+ALT+O or CMD+ALT+O to organize imports.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+O or CMD+SHFT+O to organize imports.\n    \n        :::java\n        public class MainActivity extends Activity implements EMDKManager.EMDKListener,\n        ScanAndPairManager.StatusListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override\n    \t\tpublic void onOpened(EMDKManager emdkManager) {\n\n    \t\t}\n\n    \t\t@Override\n    \t\tpublic void onClosed() {\n\n    \t\t}\n\n    \t\t@Override\n    \t\tpublic void onStatus(StatusData statusData) {\n\n    \t\t}  \n          \n        }      \n    \n\tWe will now create some global variables to hold the instance objects of EMDKManager and ScanAndPairManager. These variables would be used throughout the code.\n\n    We will then add some UI elements starting with a [TextView](http://developer.android.com/reference/android/widget/TextView.html) to display the status of Scan and Pair operation and then [EditText](http://developer.android.com/reference/android/widget/EditText.html) that will display the scanned Bluetooth Name/Address of Remote Scanning device or allow user to enter Bluetooth Name/Address of Remote Scanning device with which your Symbol device needs to be paired using [Scan and Pair APIs](#guide-reference-EMDKList?ScanAndPair%20APIs). The UI would have a [Spinner](http://developer.android.com/guide/topics/ui/controls/spinner.html) that would specify what type of data (Bluetooth Name or Bluetooth Address) of Remote Scanning device, the client application needs to scan prior to pairing with that Remote device. The User Interface would also have two [Check Boxes](http://developer.android.com/reference/android/widget/CheckBox.html) that would be explained later while adding UI code. Of course, the UI will have [Buttons](http://developer.android.com/guide/topics/ui/controls/button.html) to apply settings and start operation of Scan and Pair or Unpair.       \n \n    \n        :::java\n        // Text View to hold Bluetooth Name of Remote Scanning device to pair with.\n\t    private EditText btName = null;\n\t\n\t    // Text View to hold Bluetooth Address of Remote Scanning Device to pair with.\n\t    private EditText btAddress = null;\n\t\n\t    // Select whether to use Hard Scan or Soft Scan option to Scan\n\t    // Bluetooth Name/Address of Remote Scanning device to pair with.\n\t    private CheckBox checkboxHardTrigger = null;\n\t\n\t    // CheckBox to indicate whether to perform a scan to get Bluetooth Name/Address of\n\t    // Remote Scanning device or allow user to enter Bluetooth Name/Address of Remote\n\t    // Scanning device to pair with.\n\t    private CheckBox checkBoxAlwaysScan = null;\n\t\n\t    // Button to Pair the client application device with Remote Scanning device.\n\t    private Button scanAndPairButton = null;\n\t\n\t    // Button to Unpair the client application device with Remote Scanning device.\n\t    private Button scanAndUnpairButton = null;\n\t\n\t    // Spinner to display type of data (Bluetooth Name/Address) of Remote Scanning\n\t    // device will be used to pair.\n\t    private Spinner scandataType = null;\n\t\n\t    // Text view to display status of Scan and Pair or Unpair Operations\n\t    private TextView statusView = null;\n\t\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\t\n\t    // Declare a variable to store ScanAndPair object\n\t    ScanAndPairManager scanAndPairMgr = null;\n\t\n\t    // An interface for notifying client applications to notify scan and pair or unpair events.\n\t\tcom.symbol.emdk.scanandpair.ScanAndPairManager.StatusListener statusCallbackObj = this;\n\n    The code till here looks like:\n\n    ![img](images/ScanAndPairTutorialImages/variables_added_1.jpg)\n\t![img](images/ScanAndPairTutorialImages/variables_added_2.jpg) \n\n2. Now, let us design a simple UI that has components explained above.\n\n    So, remove all the code, inside \"res/layout/activity_main.xml\" and add following XML layout code for UI.\n\n        :::xml\n        <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    android:orientation=\"vertical\"\n\t    android:paddingBottom=\"16dp\"\n\t    android:paddingLeft=\"16dp\"\n\t    android:paddingRight=\"16dp\"\n\t    android:paddingTop=\"@dimen/activity_vertical_margin\"\n\t    tools:context=\"com.symbol.scanandpairsample1.MainActivity\" >\n\t\n\t\t    <LinearLayout\n\t\t        android:layout_width=\"wrap_content\"\n\t\t        android:layout_height=\"wrap_content\"\n\t\t        android:orientation=\"horizontal\" >\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/nameTitle\"\n\t\t            android:layout_width=\"119dp\"\n\t\t            android:layout_height=\"match_parent\"\n\t\t            android:text=\"Bluetooth Name:\" />\n\t\t\n\t\t        <EditText\n\t\t            android:id=\"@+id/name\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"match_parent\"\n\t\t            android:singleLine=\"true\"\n\t\t            android:hint=\"MPOS-64001019\"\n\t\t            android:text=\"\" />\n\t\t\n\t\t    </LinearLayout>\n\t\t\n\t\t    <LinearLayout\n\t\t        android:layout_width=\"wrap_content\"\n\t\t        android:layout_height=\"wrap_content\"\n\t\t        android:orientation=\"horizontal\" >\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/addressTitle\"\n\t\t            android:layout_width=\"119dp\"\n\t\t            android:layout_height=\"match_parent\"\n\t\t            android:text=\"Bluetooth Address:\" />\n\t\t\n\t\t        <EditText\n\t\t            android:id=\"@+id/address\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"match_parent\"\n\t\t            android:singleLine=\"true\"\n\t\t            android:hint=\"8C:DE:52:12:A2:56\"\n\t\t            android:text=\"\" />\n\t\t\n\t\t    </LinearLayout>\n\t\t\n\t\t    <LinearLayout\n\t\t        android:layout_width=\"wrap_content\"\n\t\t        android:layout_height=\"wrap_content\"\n\t\t        android:orientation=\"horizontal\" >\n\t\t\n\t\t        <CheckBox\n\t\t            android:id=\"@+id/alwaysscan\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:checked=\"true\"\n\t\t            android:text=\"Always Scan\" />\n\t\t\n\t\t        <CheckBox\n\t\t            android:id=\"@+id/triggerType\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:checked=\"true\"\n\t\t            android:text=\"Hard Trigger\" />\n\t\t\n\t\t    </LinearLayout>\n\t\t\n\t\t    <LinearLayout\n\t\t        android:layout_width=\"wrap_content\"\n\t\t        android:layout_height=\"wrap_content\"\n\t\t        android:orientation=\"horizontal\" >\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/scanDataTitle\"\n\t\t            android:layout_width=\"119dp\"\n\t\t            android:gravity=\"center_vertical\"\n\t\t            android:layout_height=\"match_parent\"\n\t\t            android:text=\"ScanData Type:\" />\n\t\t\n\t\t        <Spinner\n\t\t            android:id=\"@+id/scanDataType\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"36dp\" />\n\t\t\n\t\t    </LinearLayout>\n\t\t\n\t\t    <LinearLayout\n\t\t        android:layout_width=\"match_parent\"\n\t\t        android:layout_height=\"wrap_content\"\n\t\t        android:layout_marginTop=\"20dp\"\n\t\t        android:orientation=\"horizontal\" >\n\t\t\n\t\t        <Button\n\t\t            android:id=\"@+id/scanandpair\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_weight=\"0.5\"\n\t\t            android:focusable=\"true\"\n\t\t            android:text=\"Pair\" >\n\t\t            <requestFocus />\n\t\t        </Button>\n\t\t\n\t\t        <Button\n\t\t            android:id=\"@+id/scanandunpair\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:layout_weight=\"0.5\"\n\t\t            android:text=\"Unpair\" />\n\t\t\n\t\t    </LinearLayout>\n\t\t\n\t\t    <ScrollView\n\t\t        android:id=\"@+id/scrollView1\"\n\t\t        android:layout_width=\"match_parent\"\n\t\t        android:layout_height=\"match_parent\"\n\t\t        android:layout_marginTop=\"20dp\" >\n\t\t\n\t\t        <TextView\n\t\t            android:id=\"@+id/logs\"\n\t\t            android:layout_width=\"match_parent\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:text=\"Status:\" />\n\t\t    </ScrollView>\n\n\t\t</LinearLayout>\n\n    > Note: If you are using Android Studio, press CTRL+ALT+I or CMD+ALT+I to auto indent lines.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+F or CMD+SHFT+F to auto indent lines     \n \n3. In the `onCreate` method, we take reference of UI elements that are declared in \"res/layout/activity_main.xml\" in order to use them in our [Activity](http://developer.android.com/reference/android/app/Activity.html). We then call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. We will then set the [ArrayAdapter](http://developer.android.com/reference/android/widget/ArrayAdapter.html) that has a list of [Scan data types](#api-ScanAndPairConfig?ScanAndPairConfig.ScanDataType) of the Remote Scanner device to the Spinner.\n\n\tFinally, we would add methods calls to handle buttons and check boxes events.  \n\n        :::java\n        // References for UI elements\n        btName = (EditText) findViewById(R.id.name);\n        btAddress = (EditText) findViewById(R.id.address);\n        checkBoxAlwaysScan = (CheckBox) findViewById(R.id.alwaysscan);\n        checkboxHardTrigger = (CheckBox) findViewById(R.id.triggerType);\n        scanAndPairButton = (Button) findViewById(R.id.scanandpair);\n        scanAndUnpairButton = (Button) findViewById(R.id.scanandunpair);\n        statusView = (TextView) findViewById(R.id.logs);\n        scandataType = (Spinner)findViewById(R.id.scanDataType);\n        statusView.setText(\"\\n\");\n\n        // Initially disable both Bluetooth Name and Address Checkboxes\n        btName.setEnabled(false);\n        btAddress.setEnabled(false);\n\n        // The EMDKManager object creation and object will be returned in the callback.\n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);\n\n        // Check the return status of getEMDKManager ()\n        if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n            statusView.setText(\"Please wait, initialization in progress...\");\n        } else {\n            statusView.setText(\"Initialization failed!\");\n        }\n\n        // Add supported scan types to an ArrayList\n        ArrayList<ScanAndPairConfig.ScanDataType> scanDataTypes = new ArrayList<ScanAndPairConfig.ScanDataType>();\n        scanDataTypes.add(ScanAndPairConfig.ScanDataType.MAC_ADDRESS);\n        scanDataTypes.add(ScanAndPairConfig.ScanDataType.DEVICE_NAME);\n        scanDataTypes.add(ScanAndPairConfig.ScanDataType.UNSPECIFIED);\n\n        // Set the scan types list to an Array Adapter and set that Adapter to the Spinner\n        ArrayAdapter<ScanAndPairConfig.ScanDataType> arrayAdapter =\n                new ArrayAdapter<ScanAndPairConfig.ScanDataType>(getApplicationContext(),\n                        R.layout.simple_spinner_item, scanDataTypes);\n        scandataType.setAdapter(arrayAdapter);\n\n        // Method call to register onClick listeners of both Pair and Unpair buttons\n        registerForButtonEvents ();\n\n        // Method call to register onChecked listener of both checkboxes.\n        addCheckBoxListener();\n\n    So the complete `onCreate` method looks like:\n     \n    ![img](images/ScanAndPairTutorialImages/on_create_added_1.jpg)\n\t![img](images/ScanAndPairTutorialImages/on_create_added_2.jpg)\n\n4. Get the [EMDK Manager](#api-EMDKManager) in the `onOpened` method and update the `StatusView` TextView with a message by adding following code in `onOpened` method.\n\n\t\t:::java\n\t\t// Get EMDK Manager\n        this.emdkManager = emdkManager;\n        // Update StatusView TextView with a message on UI thread\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                statusView.setText(\"Application Initialized.\");\n            }\n        });\n\n\tThe `onOpened` method should look like: \n\t\n\t![img](images/ScanAndPairTutorialImages/on_opened_method.jpg)\n\n5. You will see few errors as we have not created the layout for ArrayAdapter and also not created onClick and onChecked listener methods. Let us resolve the errors by first creating the layout for Array Adapter.\n\n\tSo go to res -> layout and add a new file `simple_spinner_item.xml` file. Add following code to this file.\n\n\t\t:::xml\n\t\t<TextView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t     android:layout_width=\"wrap_content\"\n\t     android:layout_height=\"wrap_content\"\n\t     android:textSize=\"20sp\"\n\t     android:textColor=\"@android:color/black\"\n\t     android:gravity=\"center\"\n\t     android:text=\"Option\"\n\t    />\n\n\tThis should look like:\t\n\n\t![img](images/ScanAndPairTutorialImages/adapter_layout_added.jpg)\n\n6. Lets add the `addCheckBoxListener` method that would handle check box event for \"Always Scan\" checkbox. If this check box is checked, we will disable the Bluetooth Name and Address EditTexts so that these two parameters can be provided by scanning Remote Scanning device and not by the user. If \"Always Scan\" check box is unchecked, we will enable the Bluetooth Name and Address EditTexts because user will have to enter these details of Remote Scanning device prior to pairing. This checkbox is related to `scanAndPairMgr.config.alwaysScan` field of `ScanAndPair` API that would be explained later.\n\n\t\t:::java\n\t\t// Listener for Always Scan checkbox\n\t    private void addCheckBoxListener() {\n\t\n\t        checkBoxAlwaysScan.setOnCheckedChangeListener\n\t                (new CompoundButton.OnCheckedChangeListener() {\n\t\n\t            @Override\n\t            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t                if (isChecked) {\n\t                    btName.setEnabled(false);\n\t                    btAddress.setEnabled(false);\n\t                }\n\t                else {\n\t                    btName.setEnabled(true);\n\t                    btAddress.setEnabled(true);\n\t                }\n\t            }\n\t        });\n\t    }\n\n\tThis method should look like:\n\n\t![img](images/ScanAndPairTutorialImages/always_scan_check_box_listener.jpg)\n\n7. You can still see one error. So lets add `registerForButtonEvents` method to get rid of this error. `registerForButtonEvents` method contains onClick listener method calls of both \"Pair\" and \"Unpair\" buttons.\n\n\t\t:::java\n\t\t// Method that calls onClick listener methods for Pair and Unpair buttons.\n\t    private void registerForButtonEvents() {\n\t        addScanAndPairButtonEvents();\n\t        addScanAndUnpairButtonEvents();\n\t    }\n\n\tThe method looks like:\n\n\t![img](images/ScanAndPairTutorialImages/method_calls_for_both_buttons.jpg)\n\n8. This is the most important part of this tutorial as these two methods would allow you to pair and unpair this client application with Remote Scanning device (Ex. MC40). Lets add these two methods starting with `addScanAndPairButtonEvents`.\n\n\tFirst get the `scanAndPairButton` reference, set the onClickListener and override `onClick` method.\n\n\t![img](images/ScanAndPairTutorialImages/on_click_listener_scan_pair.jpg)\n\n\tIn case of Scan and Pair, we would get an instance of [ScanAndPairManager](#api-ScanAndPairManager) first. On this instance, set the status listener to get the status of Scan and Pair operations.\n\n\t\t:::java\n\t\tif(scanAndPairMgr == null) {\n\t\t\t\tscanAndPairMgr = (ScanAndPairManager) emdkManager.getInstance(FEATURE_TYPE.SCANANDPAIR);\n\n\t\t\t\tif(scanAndPairMgr != null) {\n\t\t\t\t\t\t\tscanAndPairMgr.addStatusListener(statusCallbackObj);\n\t\t\t\t}\n\t\t}\n\n\tWe would then set the `scanAndPairMgr.config.alwaysScan` parameter. The `ScanAndPairManager.config.alwaysScan` field determines if a scan will be performed to get the Bluetooth Name/Address of the Remote device or the user itself has to enter Bluetooth Name/Address to pair with the Remote device.\n\n\t* If ScanAndPairManager.config.alwaysScan is set to true, a scan is always performed when these methods are called. By default it is set to true. So scanning a Bluetooth barcode is required by default.\n\t* If ScanAndPairManager.config.alwaysScan is set to false, then scanning is skipped and the ScanAndPairMgr.config.bluetoothInfo.deviceName or scanAndPairMgr.config.bluetoothInfo.macAddress field provided by the user are directly taken for pairing.\n\n\t`checkBoxAlwaysScan` checkbox determines the status of `scanAndPairMgr.config.alwaysScan`. Set the [Notification Type](#api-ScanAndPairConfig?ScanAndPairConfig.NotificationType) to indicate the progress of `ScanAndPair` or `ScanAndUnpair` operations.\n\n\t\t:::java\n\t\tscanAndPairMgr.config.alwaysScan = checkBoxAlwaysScan.isChecked();\n\t\tscanAndPairMgr.config.notificationType = NotificationType.BEEPER;\n\n\t\tif(!checkBoxAlwaysScan.isChecked()) {\n\t\t\t scanAndPairMgr.config.bluetoothInfo.macAddress = btAddress.getText().toString().trim();\n\t\t\t scanAndPairMgr.config.bluetoothInfo.deviceName = btName.getText().toString().trim();\n\t\t}\n\t\n\n\tNotification Type has a specific beep sequence that lets you know the type of operation with the help of following table:\n\n\t![img](images/ScanAndPairTutorialImages/notification_table.jpg)\t \n\n\tIf `checkBoxAlwaysScan` checkbox is checked, we would perform a scan to get the Bluetooth Name/Address of the Remote device for pairing. So set the timeout that specifies the duration within which a Bluetooth Barcode should be scanned (Ex. 5 seconds). Later if the `checkboxHardTrigger` is checked, we would set `TriggerType.HARD` as trigger type, else set trigger type as `TriggerType.SOFT`.\n\n\t\t:::java\n\t\tscanAndPairMgr.config.scanInfo.scanTimeout = 5000;\n\n\t\t  if(checkboxHardTrigger.isChecked()) {\n\t\t\t scanAndPairMgr.config.scanInfo.triggerType = TriggerType.HARD;\n\t\t  } else {\n\t\t\tscanAndPairMgr.config.scanInfo.triggerType = TriggerType.SOFT;\n\t\t  }\n\t\t\n\n\tSet type of data the application is going to scan (Ex. Bluetooth Name or Bluetooth Address).\n\n\t\t:::java\n\t\tscanAndPairMgr.config.scanInfo.scanDataType = (ScanDataType)scandataType.getSelectedItem();\n\n\tCall `scanAndPair` method and get the result in `ScanAndPairResults`. This is an asynchronous method. The status of the scanAndPair() method will be returned if the callback is registered. If the always scan is enabled in the configuration, this method scans a barcode to get the Bluetooth address or name of a remote device, and pairs with that remote device. If a Bluetooth address is scanned, the remote device is paired without performing a discovery. If a Bluetooth name is scanned, then a discovery is done to find the address of the device and then the pairing is done. The provided authentication PIN is used for pairing. The maximum allowed length for the authentication PIN is 15 characters.\n\n\t\t:::java\n\t\tScanAndPairResults resultCode = scanAndPairMgr.scanAndPair(\"0000\");\n\n\t> Note: We have provided \"0000\", which is a default value.\n\n\tFinally, we would update the Status of operations in `statusView` using [ScanAndPairResults](#api-ScanAndPairManager?ScanAndPairResults).\n\n\t\t:::java\n\t\tif(!resultCode.equals(ScanAndPairResults.SUCCESS))\n\t\t\tstatusView.append(resultCode.toString()+ \"\\n\\n\");\n\t\t} else {\n\t\t\tstatusView.append(\"ScanAndPairmanager initialization failed!\");\n\t\t}\n\n\tSo thats how we perform ScanAndPair operation of this client application with Remote Scanner device. Following is the entire source code for his method that you can directly copy:\n\n\t\t:::java\n\t\t// Method to perform ScanAndPair Operation\n    \tprivate void addScanAndPairButtonEvents() {\n          scanAndPairButton = (Button) findViewById(R.id.scanandpair);\n          scanAndPairButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n\n                try {\n                    statusView.setText(\"ScanAndPair started...\"+ \"\\n\");\n\n                    if(scanAndPairMgr == null) {\n                        // Get reference to ScanAndPair Manager\n                        scanAndPairMgr = (ScanAndPairManager) emdkManager.getInstance\n                                (EMDKManager.FEATURE_TYPE.SCANANDPAIR);\n\n                        if(scanAndPairMgr != null) {\n                            // Add Status Listener on ScanAndPair Manager\n                            scanAndPairMgr.addStatusListener(statusCallbackObj);\n                        }\n                    }\n\n                    if(scanAndPairMgr != null) {\n                        scanAndPairMgr.config.alwaysScan = checkBoxAlwaysScan.isChecked();\n                        // Set Notification to Beeper\n                        scanAndPairMgr.config.notificationType =\n                                ScanAndPairConfig.NotificationType.BEEPER;\n                        // If always scan checkbox is unchecked, get details from EditText\n                        if(!checkBoxAlwaysScan.isChecked()) {\n                            scanAndPairMgr.config.bluetoothInfo.macAddress =\n                                    btAddress.getText().toString().trim();\n                            scanAndPairMgr.config.bluetoothInfo.deviceName =\n                                    btName.getText().toString().trim();\n                        }\n                        else {\n                            // Else scan these details (Bluetooth Name/Address)\n                            scanAndPairMgr.config.scanInfo.scanTimeout = 5000;\n                            //Set Trigger Type for Scanning\n                            if(checkboxHardTrigger.isChecked()) {\n                                scanAndPairMgr.config.scanInfo.triggerType =\n                                        ScanAndPairConfig.TriggerType.HARD;\n                            } else {\n                                scanAndPairMgr.config.scanInfo.triggerType =\n                                        ScanAndPairConfig.TriggerType.SOFT;\n                            }\n                            // Set Scan data type the user has selected from spinner\n                            scanAndPairMgr.config.scanInfo.scanDataType =\n                                    (ScanAndPairConfig.ScanDataType)scandataType.getSelectedItem();\n                        }\n                        // Perform ScanAndPair operation\n                        ScanAndPairResults resultCode = scanAndPairMgr.scanAndPair(\"0000\");\n                        // Update the status on StatusView.\n                        if(!resultCode.equals(ScanAndPairResults.SUCCESS))\n                            statusView.append(resultCode.toString()+ \"\\n\\n\");\n\n                    } else {\n                        statusView.append(\"ScanAndPairmanager initialization failed!\");\n                    }\n                } catch (Exception e) {\n                    statusView.setText(\"ScanAndUnpair Error:\"+ e.getMessage() + \"\\n\");\n                }\n            }\n          });\n    \t}\n\n\tThe complete `addScanAndPairButtonEvents` method should now look like:\n\n\t![img](images/ScanAndPairTutorialImages/complete_scan_and_pair_button_event_method_1.jpg)\n\t![img](images/ScanAndPairTutorialImages/complete_scan_and_pair_button_event_method_2.jpg)\n\n\n9. Lets write the `addScanAndUnpairButtonEvents` method to unpair the client application from your device with the Remote Scanning device (Ex. MC40). This Scan and Unpair method would perform similar steps that were performed in Scan and Pair method explained in previous step except one thing. It would call `scanAndUnpair` method to unpair device with Remote Scanning device as:\n\n\t\t:::java\n\t\tScanAndPairResults resultCode = scanAndPairMgr.scanAndUnpair();\n\n\t`scanAndUnpair` is an asynchronous method and its status will be returned if the callback is registered. If the always scan is enabled in the configuration, this method scans a barcode to get the Bluetooth address or name of a remote device, and unpairs with that remote device. If a Bluetooth address was scanned for pairing during scanAndPair() calls, then the same address can be scanned for unpairing during the ScanAndUnPair() call.\n\n\tThis operation would be performed when the user presses `Unpair` button. Hence we would get the reference of `scanAndUnpairButton` in this method.\n\n\tSo the complete source code of this method for unpairing client application with Remote Scanning device would be:\n\n\t\t:::java\n\t\t// Method to perform ScanAndUnpair Operation\n    \tprivate void addScanAndUnpairButtonEvents() {\n          scanAndUnpairButton = (Button) findViewById(R.id.scanandunpair);\n          scanAndUnpairButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n\n                try {\n                    statusView.setText(\"ScanAndUnpair started...\"+ \"\\n\");\n                    if(scanAndPairMgr == null) {\n                        // Get reference to ScanAndPair Manager\n                        scanAndPairMgr = (ScanAndPairManager)\n                                emdkManager.getInstance(EMDKManager.FEATURE_TYPE.SCANANDPAIR);\n\n                        if(scanAndPairMgr != null) {\n                            // Add Status Listener on ScanAndPair Manager\n                            scanAndPairMgr.addStatusListener(statusCallbackObj);\n                        }\n                    }\n\n                    if(scanAndPairMgr != null) {\n                        scanAndPairMgr.config.alwaysScan = checkBoxAlwaysScan.isChecked();\n                        // Set Notification to Beeper\n                        scanAndPairMgr.config.notificationType = ScanAndPairConfig.NotificationType.BEEPER;\n                        // If always scan checkbox is unchecked, get details from EditText\n                        if(!checkBoxAlwaysScan.isChecked()) {\n                            scanAndPairMgr.config.bluetoothInfo.macAddress =\n                                    btAddress.getText().toString().trim();\n                            scanAndPairMgr.config.bluetoothInfo.deviceName =\n                                    btName.getText().toString().trim();\n                        }\n                        else {\n                            // Else scan these details (Bluetooth Name/Address)\n                            scanAndPairMgr.config.scanInfo.scanTimeout = 5000;\n                            //Set Trigger Type for Scanning\n                            if(checkboxHardTrigger.isChecked()) {\n                                scanAndPairMgr.config.scanInfo.triggerType = ScanAndPairConfig.TriggerType.HARD;\n                            } else {\n                                scanAndPairMgr.config.scanInfo.triggerType = ScanAndPairConfig.TriggerType.SOFT;\n                            }\n                            // Set Scan data type the user has selected from spinner\n                            scanAndPairMgr.config.scanInfo.scanDataType =\n                                    (ScanAndPairConfig.ScanDataType)scandataType.getSelectedItem();\n                        }\n                        // Perform ScanAndUnpair operation\n                        ScanAndPairResults resultCode = scanAndPairMgr.scanAndUnpair();\n                        // Update the status on StatusView.\n                        if(!resultCode.equals(ScanAndPairResults.SUCCESS))\n                            statusView.append(resultCode.toString()+ \"\\n\\n\");\n\n\n                    } else {\n                        statusView.append(\"ScanAndPairmanager initialization failed!\");\n                    }\n                } catch (Exception e) {\n                    statusView.setText(\"ScanAndUnpair Error:\"+ e.getMessage() + \"\\n\");\n                }\n\n            }\n          });\n    \t}\n\n\tThe complete `addScanAndUnpairButtonEvents` method should now look like:\n\n\t![img](images/ScanAndPairTutorialImages/complete_scan_and_unpair_button_event_method_1.jpg)\n\t![img](images/ScanAndPairTutorialImages/complete_scan_and_unpair_button_event_method_2.jpg)\n\n10. In this step, we would write all the possible status that could be received during ScanAndPair and ScanAndUnpair operations in the `onStatus` method. We have added status listeners in both ScanAndPair and ScanAndUnpair methods so that we can track different status when these operations are performed and display them on `statusView` to notify user. The `statusData.getState()` method provides all the states we can get during pairing and unpairing operations.\n\n\tFollowing is the code of `onStatus` that mentions all the states and display them in the `statusView` TextView on the UI thread.  \n\n\t\t:::java\n\t\t// Method to display status during ScanAndPair and ScanAndUnpair operations.\n    \t@Override\n    \tpublic void onStatus(StatusData statusData) {\n\n\t        final StringBuilder text= new StringBuilder();\n\t\n\t        boolean isUpdateAddress = false;\n\t        // Get the status and check with the supported status to display message.\n\t        switch (statusData.getState()) {\n\t            // Status Waiting\n\t            case WAITING:\n\t                text.append(\"Waiting for trigger press to scan the barcode\");\n\t                break;\n\t            // Status Scanning\n\t            case SCANNING:\n\t                text.append(\"Scanner Beam is on, aim at the barcode.\");\n\t                break;\n\t            // Status Discovering\n\t            case DISCOVERING:\n\t                text.append(\"Discovering for the Bluetooth device\");\n\t                isUpdateAddress = true;\n\t                break;\n\t            // Status Paired\n\t            case PAIRED:\n\t                text.append(\"Bluetooth device is paired successfully\");\n\t                break;\n\t            // Status Unpaired\n\t            case UNPAIRED:\n\t                text.append(\"Bluetooth device is un-paired successfully\");\n\t                break;\n\t            // Status Error\n\t            default:\n\t            case ERROR:\n\t                text.append(\"\\n\"+ statusData.getState().toString()+\": \" + statusData.getResult());\n\t                break;\n\t        }\n\t\n\t        // Update Status View with the status on main thread\n\t        final boolean isUpdateUI = isUpdateAddress;\n\t        runOnUiThread(new Runnable() {\n\t            public void run() {\n\t                statusView.setText(text + \"\\n\");\n\t                // Update Bluetooth Name and Address EditTexts\n\t                if(isUpdateUI) {\n\t                    btName.setText(scanAndPairMgr.config.bluetoothInfo.deviceName);\n\t                    btAddress.setText(scanAndPairMgr.config.bluetoothInfo.macAddress);\n\t                }\n\t            }\n\t        });\n    \t}  \n\n\tThe `onStatus` method should look like:\n\n\t![img](images/ScanAndPairTutorialImages/on_status_method_1.jpg)\n\t![img](images/ScanAndPairTutorialImages/on_status_method_2.jpg)      \n    \n11. Display an error message on `statusView` TextView in the `onClosed` method using following code:\n\n\t\t:::java\n\t\trunOnUiThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\t\t\t\t\n\t\t\t\tstatusView.setText(\"Error!! Restart the application!!\");\n\t\t\t}\n\t\t});\n\n\tThe `onClosed` method should now look like:\n\n\t![img](images/ScanAndPairTutorialImages/on_closed_method.jpg)\n\n12. Finally, we would clean up the objects created by [EMDK Manager](#api-EMDKManager) in `onDestroy` method using following code:\n\n\t\t:::java\n\t\tif (emdkManager != null) {\n            // Clean up the objects created by EMDK manager\n            emdkManager.release();\n            emdkManager=null;\n        }\n\n\tSo the `onDestroy` method should now look like:\n\n\t![img](images/ScanAndPairTutorialImages/on_destroy_method.jpg)\n  \n      \t\nThat's it!!! We are done with all the coding part that will let us scan the Bluetooth Name/Address of Remote Scanning device and pair our client application with that Remote device using  [ScanAndPair APIs](#guide-reference-EMDKList?ScanAndPair%20APIs) introduced in EMDK V 3.1. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n \n2. Run the application.\n\n    ![img](images/ScanAndPairTutorialImages/home_screen.png)\n\n    You can see a message on the \"StatusView\" that indicates EMDK Manager has been successfully initialized.\n  \n3. We want to scan and not type, the Bluetooth Address of Remote Scanning device (Ex. MC40) with which we would pair our device having this client application. So keep the \"Always Scan\" checkbox checked.\n\n4. We would scan the Bluetooth Address of Remote Scanning device. So select `MAC ADDRESS` option from \"ScanData Type\" spinner.     \n\n    ![img](images/ScanAndPairTutorialImages/mac_address_scan_data_type.png)\n\n5. We would scan the Bluetooth Address of Remote Scanning device using Hard Scanner. So keep the \"Hard Trigger\" checkbox option as checked. So eventually our configuration should look like:\n\n\t![img](images/ScanAndPairTutorialImages/config_before_scan.png)\n\n6. Now press \"Pair\" button and it would start the pairing process by notifying the intermediate status in the \"statusView\" TextView.\n\n\t![img](images/ScanAndPairTutorialImages/scan_and_pair_started.png)\n\n\t![img](images/ScanAndPairTutorialImages/waiting_for_trigger_press.png)\n\n7. Now press the Hard Scan key to scan Bluetooth Address of the Remote Scanning device.\n\n\t![img](images/ScanAndPairTutorialImages/beam_on_aim_barcode.png)\n\n8.  The following is the Barcode that has the MAC Address of Remote Scanning Device (Ex. MC40).\n\n\t![img](images/ScanAndPairTutorialImages/barcode_with_mac_address.jpg)\n\n9. Scan this Barcode and your device (Ex. TC55) would be successfully paired with the Remote Scanning Device (Ex. MC40).\n\n\t![img](images/ScanAndPairTutorialImages/discovering_device.png)\n\n\t![img](images/ScanAndPairTutorialImages/pairing_dialog.png)\n\n\tClick \"Pair\" button on both devices (Mobile and Remote Scanning Device).\n\n\t![img](images/ScanAndPairTutorialImages/device_paired.png)\n\n10. You can see the \"statusView\" with a success message. Now let's confirm this by going to device's Settings -> Bluetooth.\n\n\t![img](images/ScanAndPairTutorialImages/confirm_pairing.png)\n\n11. You can see that MC40 has been successfully paired under \"PAIRED DEVICES\" section of your device.\n\n\t\n\n\t\n\n \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n\n\n## What's Next\nNow that you have learned how to scan the Bluetooth Name/Address of Remote Scanning device and pair our client application with that Remote device using  [ScanAndPair APIs](#guide-reference-EMDKList?ScanAndPair%20APIs), in the next tutorial we would concentrate on [SimulScan APIs](#guide-reference-EMDKList?SimulScan%20APIs) and develop an application to demonstrate its use. \n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/ScanAndPairTutorial.zip)."},{"key":"guide-tutorial-tutSimulScanAPI","name":" Capture critical data from documents using SimulScan API","md":"# Capture critical data from documents using SimulScan API\n\n## Overview\n\nThis guide will walk you through creating an EMDK For Android application that will use [SimulScan APIs](#guide-reference-EMDKList?SimulScan%20APIs) introduced in EMDK V 3.1, to capture critical data from documents. This facilitates capturing fields of interest from a document and converting them into data that an end-user application can use immediately at the point of transaction.\n\nDifferent ways of capturing data from documents using [SimulScan API](#guide-reference-EMDKList?SimulScan%20APIs) are:\n\n* **Barcode** - Productivity gain by decoding multiple bar codes read with a single trigger pull.\n* **OCR (Optical Character Recognition)** - Automated data entry with character recognition [OCR].\n* **OMR (Optical Mark Recognition)** - Simplified workflow exceptions with checked mark recognition [OMR] and Signature presence detection.\n\nWe discussed [SimulScan API](#guide-reference-EMDKList?SimulScan%20APIs) is used to capture above mentioned different types of data from documents. But what types of documents are these? Well, these documents are treated as templates where you know the position of the data that you need to capture. You mark positions of the data of your interest on a template and once you capture the document, SimulScan API would access to data at the positions you mentioned on the template.\n\n**Templates:**\n\nYou can use an existing template or create your own template depending on the data that needs to be captured from the document. Click [here](https://simulscan.zebra.com) to login using your partner credentials and create your own template by uploading image of your form. Once you upload the image of your form, you can mark the fields that needs to be captured and create a new template. Now, if you load this template in your SimulScan tutorial application and capture image of the document, it would automatically recognize fields of your interest on the template that you marked, capture only those fields and populate them on UI.\n\n\n**Use Case:**\n\n![img](images/SimulScanTutorialImages/example_document.jpg)\n\nThe above document has various fields having text, barcode, signature that could be needed to capture and display on UI for an application repeatedly.\n\n![img](images/SimulScanTutorialImages/example_document_requirement.jpg)\n\nSuppose, we need to capture two highlighted fields through our application, which contains barcode and characters.\n  \n\n**Problem:**\n\nIf the required number of fields are more, it could be painful to capture each and every field individually, decode it and populate on UI.\n\n**Solution:**\n\n[SimulScan API](#guide-reference-EMDKList?SimulScan%20APIs) could come really handy here as it captures upto 10 barcodes in less than one second. So we will now create a tutorial that would use above form image to create a template and use this template to capture marked fields from that document populating on UI using [SimulScan APIs](#guide-reference-EMDKList?SimulScan%20APIs). This will let you know how to create your own template for capturing different fields from any particular document.\n \n        \n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT) ([Android Studio](http://developer.android.com/sdk/index.html)/[Eclipse with ADT](http://developer.android.com/tools/sdk/eclipse-adt.html))\n* EMDK for Android V 3.1 and above\n* SimulScan is currently supported on TC55 Rev B KitKat and TC75.\n\n> Note: As SimulScan is built into the OS image in the above devices, download the latest OS from either the extranet or SupportCentral. \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating a Template\n\n1. Log in using your partner credentials to [https://simulscan.zebra.com](https://simulscan.zebra.com).\n\n\t![img](images/SimulScanTutorialImages/template_builder_home.jpg)\n\n2. Click on \"Create Template\" button.\n\n\t![img](images/SimulScanTutorialImages/choose_document_type.jpg)\n\n3. You could see different document types based on your needs. Since we already have a document format that contains barcodes and characters, click \"Structured Targets\" button.\n\n4. Take an image of the document and provide path of this image on your machine. You should see following:\n\n\t![img](images/SimulScanTutorialImages/select_area_for_template.jpg)\n\n5. Click \"Ok\" and you would see something like this:\n\n\t![img](images/SimulScanTutorialImages/create_new_template.jpg)\n\n6. Provide the \"Template Name\" at the top left corner (Ex: MyTemplate) and press \"enter\".\n\n7. Highlight the fields that you want to read when the form is captured through our app. Provide name to each highlighted field on left side under fields section. So we would highlight two sections:\n\n\t* Shipper's VAT/GST number (Provide \"Shippers VATGST number\" as the field name). Select OCR processing with word check.\n\t\n\t![img](images/SimulScanTutorialImages/first_field.jpg)\n\t\n\t* Barcode at the top right of the document (Provide \"postal barcode\" as the field name). Select Barcode processing with any barcode type.  \n\n\t![img](images/SimulScanTutorialImages/second_field.jpg)\n\n8. Your template should now look like this:\n\n\t![img](images/SimulScanTutorialImages/template_with_both_fields.jpg)\n\n9. Click \"File\" and \"Download Template\" to download this created template on your machine.\n\n10. Downloaded template is an xml file (Ex: MyTemplate.xml). Put this template file under \"/sdcard/simulscan/templates\" on your device so that our Android application can detect this template.\n\n\t![img](images/SimulScanTutorialImages/template_on_device.png)\n\n11. This is how you can create your own template to capture any field on any document.\n\n\n## Installing your license\nIf you are using features that require a license, please follow these steps:\n\n1. Request a trial license from Product Manager (Andrew.Knight@zebra.com).\n2. Copy the License.xml file received from the licensing server to a location on the sdcard.\n3. Upgrade the TC55 or TC75 software to the latest [2.46 and above for TC55, 0901 and above for TC75].\n4. Launch the Settings app -> About Phone > Legal Information -> Symbol Licenses -> Install a\nlicense ? -> Yes -> point to the file on the sdcard.\n\nThis will install the license . For mass deployment, end customers would need to use StageNow.\n\n> Note: Post your queries on SimulScan Launchpad page so the team can assist you at the earliest. \n\n\n## Creating The Project\n\n> Note: Provide \"SimulScanTutorial\" as the project name for this tutorial.\n\nIf you are using Android Studio, click [here](#guide-tutorial-tutCreateProjectAndroidStudio).\n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutCreateProjectEclipseADT).  \n\n## Enabling the EMDK\nIf you are using Android Studio, you have already completed this step while creating the project by selecting `EMDK 3.1 (API 16) (Symbol Technologies, Inc.) (API 16)` or `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK.\n\n> Note: Select `EMDK 3.1 (API 19) (Symbol Technologies, Inc.) (API 19)` as the minimum SDK for this tutorial. \n\nIf you are using Eclipse with ADT, click [here](#guide-tutorial-tutEnableEMDKEclipseADT) for Enabling the EMDK tutorial as it would again be a common step for all of your projects that are using EMDK for Android API.   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK to scan the barcodes.\n  \n    ![img](images/SimulScanTutorialImages/manifest_file.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK': \n\n\tYou should also add a permission for accessing our template from sdcard 'android.permission.WRITE_EXTERNAL_STORAGE':\n \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\" />\n\t\t<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> \n\n    Then you must enable the library for EMDK:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n\tThen set orientation to portrait mode to restrict orientation by adding following line in the `<activity>` tag.\n\n\t\t:::xml\n\t\tandroid:screenOrientation=\"portrait\"\n\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/SimulScanTutorialImages/manifest_permissions_added.jpg) \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.EMDKManager;\n\t\timport com.symbol.emdk.simulscan.SimulScanData;\n\t\timport com.symbol.emdk.simulscan.SimulScanReader;\n\t\timport com.symbol.emdk.simulscan.SimulScanStatusData;  \n\n    Then you must make the activity to implement following interfaces: \n\t* Implement [EMDKListener](#api-EMDKManager-EMDKListener) for using EMDKManager. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`. \n\t* Implement [SimulScanReader.DataListerner](#api-SimulScanReader-DataListerner), which is an interface for notifying client applications when the scan data is available. Override its `onData` method to receive the scanned data.\n\t* Implement [SimulScanReader.StatusListerner](#api-SimulScanReader-StatusListerner), which is an interface for notifying client applications to notify scan events. Override its `onStatus` method to receive status of any SimulScan operation that would be performed in the application.\n\t* Implement [View.OnClickListener](http://developer.android.com/reference/android/view/View.OnClickListener.html) and override its `onClick` method to handle on click of buttons.\n\t* Implement [AdapterView.OnItemSelectedListener](http://developer.android.com/reference/android/widget/AdapterView.OnItemSelectedListener.html) and override its `onItemSelected` and `onNothingSelected` methods for handling spinner.\n\n\t> Note: If you are using Android Studio, press CTRL+ALT+O or CMD+ALT+O to organize imports.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+O or CMD+SHFT+O to organize imports.\n    \n        :::java\n        public class MainActivity extends Activity implements EMDKManager.EMDKListener,\n        SimulScanReader.DataListerner, SimulScanReader.StatusListerner, View.OnClickListener, AdapterView.OnItemSelectedListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override\n\t\t    public void onData(SimulScanData simulScanData) {\n\t\t\n\t\t    }\n\t\t    @Override\n\t\t    public void onOpened(EMDKManager emdkManager) {\n\t\t\n\t\t    }\n\t\t    @Override\n\t\t    public void onClosed() {\n\t\t\n\t\t    }\n\t\t    @Override\n\t\t    public void onClick(View v) {\n\t\t\n\t\t    }\n\t\t    @Override\n\t\t    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\n\t\t    }\n\t\t    @Override\n\t\t    public void onNothingSelected(AdapterView<?> parent) {\n\t\t\n\t\t    }\n\t\t    @Override\n\t\t    public void onStatus(SimulScanStatusData simulScanStatusData) {\n\t\t\n\t\t    }  \n          \n        }      \n    \n\tWe will now create some global variables to hold the instance objects of [EMDKManager](#api-EMDKManager), [SimulScanManager](#api-SimulScanManager) and [SimulScanReader](#api-SimulScanReader). These variables would be used throughout the code.\n\n    We will then add some UI elements starting with a [TextView](http://developer.android.com/reference/android/widget/TextView.html) to display the status of SimulScan operation. The UI would have a [Spinner](http://developer.android.com/guide/topics/ui/controls/spinner.html) that would contain a list of SimulScan supported devices. The UI would also have two [Buttons](http://developer.android.com/guide/topics/ui/controls/button.html) to start and stop reading template.\n\n\n\tThe variables would also have a list (readerInfoList) to hold Simulscan supported device and another `synchronized` list (simulScanDataList) to hold various data of the scanned template along with an exception (lastException) to catch exceptions if any.   \n \n\tSo, overall the variables look like:   \t\n\n        :::java\n        // Tag for managing logs\n\t    private final static String TAG = MainActivity.class.getCanonicalName();\n\t\n\t    // TextView for displaying status of SimulScan operations\n\t    private TextView textViewStatus = null;\n\t    // Spinner for selecting scanning device for SimulScan operation\n\t    private Spinner deviceSelectionSpinner = null;\n\t    // Button that triggers reading form elements from the template\n\t    private Button readButton = null;\n\t    // Button to stop reading template\n\t    private Button stopReadButton = null;\n\t    // Declare a variable to store EMDKManager object\n\t    private EMDKManager emdkManager = null;\n\t    // Declare a variable to store SimulScanManager object\n\t    private SimulScanManager simulscanManager = null;\n\t    // List of SimulScan supported devices\n\t    private List<SimulScanReaderInfo> readerInfoList = null;\n\t    // object for holding EMDKResults data.\n\t    private EMDKResults results;\n\t    // provides access to physical SimulScan reader device.\n\t    private SimulScanReader selectedSimulScanReader = null;\n\t    // contains a list of SimulScanData, captured through SimulScan operations\n\t    private List<SimulScanData> simulScanDataList = Collections\n\t            .synchronizedList(new ArrayList<SimulScanData>());\n\t    // Catches Exception\n\t    private Exception lastException;\n\n    The code till here looks like:\n\n    ![img](images/SimulScanTutorialImages/variables_added_1.jpg)\n\t![img](images/SimulScanTutorialImages/variables_added_2.jpg) \n\n2. Now, let us design a simple UI that has UI components explained above.\n\n    So, remove all the code, inside \"res/layout/activity_main.xml\" and add following XML layout code for UI.\n\n        :::xml\n        <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t\t    android:layout_width=\"match_parent\"\n\t\t    android:layout_height=\"wrap_content\"\n\t\t    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n\t\t    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n\t\t    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n\t\t    android:paddingTop=\"@dimen/activity_vertical_margin\"\n\t\t    android:orientation=\"vertical\"\n\t\t    tools:context=\".MainActivity\" >\n\t\t\n\t\t    <TextView\n\t\t        android:id=\"@+id/status_view\"\n\t\t        android:layout_width=\"wrap_content\"\n\t\t        android:layout_height=\"wrap_content\" />\n\t\t\n\t\t    <Spinner\n\t\t        android:id=\"@+id/devices_spinner\"\n\t\t        android:layout_width=\"wrap_content\"\n\t\t        android:layout_height=\"wrap_content\"\n\t\t        android:layout_marginTop=\"10dp\" />\n\t\t\n\t\t    <LinearLayout\n\t\t        android:layout_width=\"match_parent\"\n\t\t        android:layout_height=\"wrap_content\" >\n\t\t\n\t\t        <Button\n\t\t            android:id=\"@+id/btn_start_read\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:text=\"Read\" />\n\t\t\n\t\t        <Button\n\t\t            android:id=\"@+id/btn_stop_read\"\n\t\t            android:layout_width=\"wrap_content\"\n\t\t            android:layout_height=\"wrap_content\"\n\t\t            android:text=\"stop\" />\n\t\t\n\t\t    </LinearLayout>\n\t\t\n\t\t</LinearLayout>\n\n    > Note: If you are using Android Studio, press CTRL+ALT+I or CMD+ALT+I to auto indent lines.\n\t> \n\t> OR\n\t> \n\t> If you are using Eclipse with ADT, press CTRL+SHFT+F or CMD+SHFT+F to auto indent lines     \n \n3. In the `onCreate` method, we take reference of UI elements that are declared in \"res/layout/activity_main.xml\" in order to use them in our [Activity](http://developer.android.com/reference/android/app/Activity.html) and add their respective onclick listeners. We then call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n\tFinally, we would add methods calls to handle buttons and check boxes events.  \n\n        :::java\n        // The EMDKManager object will be created and returned in the callback.\n        results = EMDKManager.getEMDKManager(getApplicationContext(), this);\n\n        // Get references for UI elements\n        textViewStatus = (TextView) findViewById(R.id.status_view);\n        deviceSelectionSpinner = (Spinner) findViewById(R.id.devices_spinner);\n        readButton = (Button) findViewById(R.id.btn_start_read);\n        stopReadButton = (Button) findViewById(R.id.btn_stop_read);\n\n        // Update Status TextView\n        textViewStatus.setText(\"Status: \" + \" Starting..\");\n\n        // Set listeners for Spinner and buttons\n        deviceSelectionSpinner.setOnItemSelectedListener(this);\n        readButton.setOnClickListener(this);\n        stopReadButton.setOnClickListener(this);\n\n        if (results.statusCode != EMDKResults.STATUS_CODE.SUCCESS) {\n            textViewStatus.setText(\"Status: \"\n                    + \"EMDKManager object request failed!\");\n        }\n\n    So the complete `onCreate` method looks like:\n     \n    ![img](images/SimulScanTutorialImages/on_create_added.jpg)\n\t\n\n4. Get [EMDK Manager](#api-EMDKManager) and [SimulScanManager](#api-SimulScanManager) objects in the `onOpened` method and update the `StatusView` TextView.\n\n\tNow get the list of SimulScan supported devices, iterate over it and set this list to the spinner that we have added in the UI followed by adding listener for this spinner.\n\n\tSo the code performing above operations in sequence looks like:\n\n\t\t:::java\n\t\t// This callback will be issued when the EMDK is ready to use.\n        this.emdkManager = emdkManager;\n\n        // Get the SimulScanManager object\n        simulscanManager = (SimulScanManager) emdkManager\n                .getInstance(EMDKManager.FEATURE_TYPE.SimulScan);\n\n        if (null == simulscanManager) {\n            textViewStatus.setText(\"Status: \"\n                    + \"Get SimulScanManager instance failed!\");\n            return;\n        }\n\n        // Get the SimulScan supported device list\n        readerInfoList = simulscanManager.getSupportedDevicesInfo();\n        List<String> nameList = new ArrayList<String>();\n        for (SimulScanReaderInfo rinfo : readerInfoList) {\n            nameList.add(rinfo.getFriendlyName());\n        }\n        // Add the simulscan supported list to spinner and\n        // set item selected listener\n        addItemsOnSpinner(deviceSelectionSpinner, nameList);\n        deviceSelectionSpinner.setOnItemSelectedListener(this);\n\n\tThe `onOpened` method should look like: \n\t\n\t![img](images/SimulScanTutorialImages/on_opened_method.jpg)\n\n5. You will see an error as we have not added `addItemsOnSpinner` method. So lets add it now. This method would basically get Spinner and list of SimulScan supported device as arguments. It would add this list in an adapter and set that adapter into spinner to display this list on UI.\n\n\t\t:::java\n\t\t// Add SimulScan supported device list to spinner\n\t    private void addItemsOnSpinner(Spinner spinner, List<String> list) {\n\t\n\t        ArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(\n\t                this, android.R.layout.simple_spinner_item, list);\n\t        dataAdapter\n\t                .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t        spinner.setAdapter(dataAdapter);\n\t    }\n\n\tThis method should look like:\t\n\n\t![img](images/SimulScanTutorialImages/add_items_on_spinner_method.jpg)\n\n6. The user would select any SimulScan supported device from the list in spinner. So we need get that [SimulScanReader](#api-SimulScanReader) and initiate it. Since the user would select it from the spinner, we need to add our code in `onItemSelected` method of the spinner that we have already overridden.\n\n\tSo this code would get user selected [SimulScanReaderInfo](#api-SimulScanReaderInfo) from the spinner and pass it to `simulScanManager.get` to get the user selected [SimulScanReader](#api-SimulScanReader) object. This [SimulScanReader](#api-SimulScanReader) object represents the current SimulScan Reader device selected by user from the spinner of simulscan supported devices. We would then initialize or deinitialize this [SimulScanReader](#api-SimulScanReader) using respective methods. \n\n\t\t:::java\n\t\t// Initialize the selected Simul Scan device\n        if (parent.equals(deviceSelectionSpinner)) {\n            if (simulscanManager != null) {\n                SimulScanReaderInfo readerInfo = readerInfoList.get(position);\n                if (readerInfo != null) {\n                    try {\n                        deinitCurrentScanner();\n                        selectedSimulScanReader = simulscanManager\n                                .getDevice(readerInfo);\n                        initCurrentScanner();\n                    } catch (SimulScanException e) {\n                        e.printStackTrace();\n                        textViewStatus.setText(\"Status: \"\n                                + \"Error enabling reader\");\n                    }\n                }\n            }\n        }\n\n\tSo the `onItemSelected` method should now look like:\n\n\t![img](images/SimulScanTutorialImages/on_item_selected_method.jpg)\n\n\tWe would simply de-initialize scanner in `onNothingSelected` method when nothing is selected in the spinner as follows:\n\n\t\t:::java\n\t\t// De-initialize device spinner when nothing is selected\n        if (parent.equals(deviceSelectionSpinner)) {\n            try {\n                deinitCurrentScanner();\n            } catch (SimulScanException e) {\n                e.printStackTrace();\n            }\n        }\n\n\tThe `onNothingSelected` method should now look like:\n\t\n\t![img](images/SimulScanTutorialImages/on_nothing_selected_method.jpg)\n \n\n7. Lets add `initCurrentScanner` and `deinitCurrentScanner` methods to initialize and de-initialize the current scanner respectively. This would also get read of errors. \n\n\t\t:::java\n\t\t// Initialize Simul scanner by enabling\n\t    // simulscan reader and setting listeners\n\t    private void initCurrentScanner() throws SimulScanException {\n\t        selectedSimulScanReader.addStatusListener(this);\n\t        selectedSimulScanReader.addDataListener(this);\n\t        selectedSimulScanReader.enable();\n\t    }\n\n\tThe `initCurrentScanner` method would add data and status listeners to the current scanner (SimulScanReader device) to receive scanned data and status notifications respectively. Finally it would enable the scanner.\n\n\n\t\t:::java\n\t\t// De-Initialize scanner by removing listeners and canceling pending reads\n\t    private void deinitCurrentScanner() throws SimulScanException {\n\t        if (selectedSimulScanReader != null) {\n\t            if (selectedSimulScanReader.isReadPending())\n\t                selectedSimulScanReader.cancelRead();\n\t            if (selectedSimulScanReader.isEnabled())\n\t                selectedSimulScanReader.disable();\n\t            selectedSimulScanReader.removeDataListener(this);\n\t            selectedSimulScanReader.removeStatusListener(this);\n\t            selectedSimulScanReader = null;\n\t        }\n\t    }\n\n\tThe `deinitCurrentScanner` method would cancel any pending reads and then disable the current scanner (SimulScanReader device). It would then remove data and status listeners. \n\n\tBoth `initCurrentScanner` and `deinitCurrentScanner` methods should look like:\n  \n\t![img](images/SimulScanTutorialImages/init_deinit_scanner_methods.jpg)\n\n8. According to the life cycle of Activity, we would add `onStart` and `onStop` methods to enable and disable the scanner (SimulScanReader device) respectively as follows:\n\n\tCode for `onStart` method:\n\n\t\t:::java\n\t\t @Override\n\t    public void onStart() {\n\t        super.onStart();\n\t        if (selectedSimulScanReader != null)\n\t            try {\n\t                if (!selectedSimulScanReader.isEnabled())\n\t                    // Enable SimulScan Reader\n\t                    selectedSimulScanReader.enable();\n\t            } catch (SimulScanException e) {\n\t                e.printStackTrace();\n\t                textViewStatus.setText(\"Status: \" + \"Error enabling reader\");\n\t            }\n\t    }\n\n\n\tCode for `onStop` method:\n\n\t\t:::java\n\t\t@Override\n\t    public void onStop() {\n\t        if (selectedSimulScanReader != null) {\n\t            if (selectedSimulScanReader.isReadPending()) {\n\t                try {\n\t                    // Cancel any pending SimulScan Read\n\t                    selectedSimulScanReader.cancelRead();\n\t                } catch (SimulScanException e) {\n\t                    e.printStackTrace();\n\t                }\n\t            }\n\t            try {\n\t                if (selectedSimulScanReader.isEnabled()) {\n\t                    // Disable SimulScan Reader\n\t                    selectedSimulScanReader.disable();\n\t                }\n\t            } catch (SimulScanException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t        super.onStop();\n\t    }\n\n\tBoth `onStart` and `onStop` methods should now look like: \n\n\t![img](images/SimulScanTutorialImages/on_start_method.jpg)\n\n\t![img](images/SimulScanTutorialImages/on_stop_method.jpg)\n\n\n9. Now we would add a method to set SimulScanConfig settings, where we would set different parameters for the current scanner (SimulScanReader device) as follows:\n\n\t\t:::java\n\t\t// Set SimulScan Config settings\n\t    private void setCurrentConfig() throws Exception {\n\t        if (selectedSimulScanReader != null) {\n\t            SimulScanConfig config = selectedSimulScanReader.getConfig();\n\t            if (config != null) {\n\t                // Get the template path from the storage\n\t                String templatePath = Environment.getExternalStorageDirectory().toString()\n\t                        + \"/simulscan/templates/MyTemplate.xml\";\n\t                File file = new File(templatePath);\n\t                // Get the SimulScan Template\n\t                SimulScanMultiTemplate myTemplate = new SimulScanMultiTemplate(simulscanManager, Uri.fromFile(file));\n\t\n\t                // Set the template with SimulScanConfig settings\n\t                if(myTemplate != null)\n\t                    config.multiTemplate = myTemplate;\n\t                // Amount of time in milliseconds to wait before timing out identification.    \n\t                config.identificationTimeout = 15000;\n\t                // Amount of time in milliseconds to wait before timing out processing.\n\t                config.processingTimeout = 10000;\n\t                // If userConfirmationOnScan is true, shows UI for user to confirm \n\t                // the scanned data before sending results to application.\n\t                config.userConfirmationOnScan = true;\n\t                // If true, form will be captured automatically when detected\n\t                config.autoCapture = true;\n\t                // If enabled, allows a session to write form capture, region images, \n\t                // region values, and other data to storage.\n\t                config.debugMode = false;\n\t                // Turn on/off audio feedback.\n\t                config.audioFeedback = true;\n\t                // Turn on/off haptic feedback.\n\t                config.hapticFeedback = true;\n\t                // Turn on/off LED feedback.\n\t                config.ledFeedback = true;\n\t                // Set SimulScanConfig\n\t                selectedSimulScanReader.setConfig(config);\n\t            }\n\t        }\n\t    }\n\n\t`setCurrentConfig` method should now look like:\n\n\t![img](images/SimulScanTutorialImages/set_current_config_method_1.jpg)\n\t\n\t![img](images/SimulScanTutorialImages/set_current_config_method_2.jpg)\n\n10. In this step, we would add methods that would actually start (`readCurrentScanner`) and stop (`stopReadCurrentScanner`) reading templates with the help of [SimulScanReader](#api-SimulScanReader) instance for the current scanner that we created.\n \n\tSo lets add `readCurrentScanner` method first.\n\n\t\t:::java\n\t\t// Start reading template through SimulScanReader\n\t    private void readCurrentScanner() throws Exception {\n\t        setCurrentConfig();\n\t        if (selectedSimulScanReader != null) {\n\t            selectedSimulScanReader.read();\n\t        }\n\t    }\n\n\tAnd then `stopReadCurrentScanner` method.\n\n\t\t:::java\n\t\t// Cancel/Stop reading template through SimulScanReader\n\t    private void stopReadCurrentScanner() throws SimulScanException {\n\t        if (selectedSimulScanReader != null)\n\t            selectedSimulScanReader.cancelRead();\n\t    }\n\n\tThe methods `readCurrentScanner` and `stopReadCurrentScanner` should now look like:\n\n\t![img](images/SimulScanTutorialImages/start_stop_reading_scanner.jpg)   \n    \n11. We would now add the code in `onClick` method that is overridden for the \"Start\" and \"Stop\" buttons in the UI that would call `readCurrentScanner` and `stopReadCurrentScanner` methods to start and stop the template reading respectively on click of these buttons.\n\n\tAdd following code in the `onClick` method.  \n\n\t\t:::java\n\t\t// Start reading template\n        if(v.equals(readButton)){\n            try {\n                readCurrentScanner();\n            } catch (Exception e) {\n                lastException = e;\n                textViewStatus.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        textViewStatus.setText(\"Status: \"\n                                + lastException.getMessage());\n                    }\n                });\n                e.printStackTrace();\n            }\n        }\n\n        // Cancel/Stop reading template\n        if(v.equals(stopReadButton)){\n            try {\n                stopReadCurrentScanner();\n            } catch (SimulScanException e) {\n                lastException = e;\n                textViewStatus.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        textViewStatus.setText(\"Status: \"\n                                + lastException.getMessage());\n                    }\n                });\n                e.printStackTrace();\n            }\n        }\n\n\tYou can see the code and understand that if \"readButton\" button is pressed, it calls `readCurrentScanner` method to read template. If \"stopReadButton\" button is pressed, it would call `stopReadCurrentScanner` method to stop/cancel reading the template. The status would be updated on \"ViewStatus\" text view in both the operations.  \n\n\tThe entire `onClick` method should now look like:\n\n\t![img](images/SimulScanTutorialImages/on_click_method_1.jpg)\n\n\t![img](images/SimulScanTutorialImages/on_click_method_2.jpg)\n\n12. Once we start scanning a template, we would get the template data in `onData` and status while executing scanning operations in `onStatus` methods respectively that have been overridden already but not handled yet.\n\n\tSo lets handle them starting with `onData` method, which is a callback method upon data availability. `onData` method contains [SimulScanData](#api-SimulScanData) object that has the scanned data of a template. We would add this object to simulScanDataList that we had created to use it while displaying data.\n\n\t\t:::java\n\t\t// clear the SimulScanDataList before adding new scanned data\n        synchronized (simulScanDataList) {\n            simulScanDataList.clear();\n        }\n\n        // Add Scanned data to SimulScanDataList\n        synchronized (simulScanDataList) {\n            simulScanDataList.add(simulScanData);\n        }\n\n\tSo the `onData` method should now look like:\n\n\t![img](images/SimulScanTutorialImages/on_data.jpg)\n\n13. The status of any SimulScan operation is received in `onStatus` method, which is a callback method upon scan status event occurs.\n\n\tWe would update the \"StatusView\" TextView based on the status on UI thread using following code in `onStatus` method.\n\n\t\t:::java\n\t\t// Update Status View with the updated SimulScan operation status\n        textViewStatus.post(new StatusDataRunnable(simulScanStatusData));\n\n\tThe `onStatus` method should look like:\n\n\t![img](images/SimulScanTutorialImages/on_status_method.jpg)\n\n14. You can see an error as we have not created a class `StatusDataRunnable` implementing runnable to update \"StatusView\" on UI thread.\n\n\tLets do that by creating a class implementing runnable and taking [SimulScanStatusData](#api-SimulScanStatusData) as an argument in constructor. `simulScanStatusData.getState()` would return you the current status of scanner, which would be updated on \"StatusView\" TextView.\n\n\tFollowing is the code for `StatusDataRunnable` class:\n\n\t\t:::java\n\t\t// Update SimulScan operation status on Status View\n\t    private class StatusDataRunnable implements Runnable {\n\t        SimulScanStatusData statusData = null;\n\t\n\t        StatusDataRunnable(SimulScanStatusData statusData) {\n\t            this.statusData = statusData;\n\t        }\n\t\n\t        @Override\n\t        public void run() {\n\t            if (statusData != null) {\n\t                switch (statusData.getState()) {\n\t                    case DISABLED:\n\t                        textViewStatus.setText(\"Status: \"\n\t                                + statusData.getFriendlyName()\n\t                                + \": Closed reader successfully\");\n\t                        break;\n\t                    case ENABLED:\n\t                        textViewStatus.setText(\"Status: \"\n\t                                + statusData.getFriendlyName()\n\t                                + \": Opened reader successfully\");\n\t                        break;\n\t                    case SCANNING:\n\t                        textViewStatus.setText(\"Status: \"\n\t                                + statusData.getFriendlyName()\n\t                                + \": Started reader successfully\");\n\t\n\t                        break;\n\t                    case IDLE:\n\t                        textViewStatus.setText(\"Status: \"\n\t                                + statusData.getFriendlyName()\n\t                                + \": Stopped reader successfully\");\n\t                        break;\n\t                    case ERROR:\n\t                        textViewStatus.setText(\"Status: \"\n\t                                + statusData.getFriendlyName() + \": Error-\"\n\t                                + statusData.extendedInfo.getExtendedStatus());\n\t                        break;\n\t                    case UNKNOWN:\n\t                    default:\n\t                        break;\n\t                }\n\t            }\n\t        }\n\t    }\n\n\tThe `StatusDataRunnable` class should look like:\n\n\t![img](images/SimulScanTutorialImages/status_data_runnable_1.jpg)\n\n\t![img](images/SimulScanTutorialImages/status_data_runnable_2.jpg)\n\n15. Finally, we would update \"StatusView\" TextView in the `onClosed` method for any abrupt closing of EMDK using following line.\n\n\t\t:::java\n\t\ttextViewStatus.setText(\"Status: \" + \"EMDK closed unexpectedly!\");\n\n\tSo the `onClosed` method should now look like:\n\n\t![img](images/SimulScanTutorialImages/on_closed.jpg)  \t       \n      \t\n\tThat's it!!! We are done with all the coding and configuration part that will let us scan the template stored in sdcard and display fields that we marked in the template, on Symbol device UI using [SimulScan APIs](#guide-reference-EMDKList?SimulScan%20APIs) introduced in EMDK V 3.1. Now let us run the application.\n \n## Running the Application\n\n1. Connect the device (having latest EMDK runtime) to USB port. \n\n    > Note:   \n    > Make sure the device is in USB debug.\n \n2. Run the application.\n\n    ![img](images/SimulScanTutorialImages/home_screen.png)\n\n    You can see a message on the \"StatusView\" that indicates EMDK Manager has been successfully initialized and reader has been opened successfully.\n\n\tYou can select different SimulScanReader device by clicking on Spinner but as of now TC55 supports only Internal Camera for SimulScan. Hence its the only device in the spinner.\n\n\t![img](images/SimulScanTutorialImages/spinner.png)\n  \n3. Once selecting Internal Camera as SimulScanReader device from the spinner, click read button. It opens the Internal Camera.\n\n\t![img](images/SimulScanTutorialImages/place_doc_for_scanning.png)\n\n\tYou can see that its searching for \"MyTemplate\" that we had set.\n\n4. Place Internal Camera above the printed copy of \"MyTemplate\". It would process the template by outlining it and read the marked fields in the template viz. Shipper's VAT/GST Number and barcode at the top right.\n\n    ![img](images/SimulScanTutorialImages/processing_template.png)\n\n\t![img](images/SimulScanTutorialImages/parsed_data.png)\n\n\tYou can see that SimulScanReader device has successfully scanned and parsed the Shipper's VAT/GST number and barcode fields and displayed them on UI. You can press \"Accept\" button at the bottom to use these values in your application.\n\n5. If the SimulScanReader device is not sure about the correctness of scanned fields, it would display them in red background. It means you need to re-scan the template by pressing \"Rescan\" button at the bottom left. \n\n\t![img](images/SimulScanTutorialImages/re_scan_template.png)\n\n6. You can see the message \"Check Result\", which indicates that you need to re-scan the template to get correct data from marked fields of the template until the \"Check Result\" message is not shown like below:\n\n\t![img](images/SimulScanTutorialImages/parsed_data.png)\n\n\tThis illustrates how to access critical fields from a document using [SimulScan APIs](#guide-reference-EMDKList?SimulScan%20APIs) by creating its template from the [Template Builder](https://simulscan.zebra.com).\n\n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n\t\t<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    \n\t>Note:\n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. Installing the EMDK for Android application without deploying the EMDK runtime on the Symbol device will fail because of missing shared library on the device.\n\n3. Place the template in the SD Card before accessing it from the application.\n \n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/SimulScanTutorial.zip)."}];